diff --git a/Documentation/devicetree/bindings/clock/idt,idt8t49n24x.txt b/Documentation/devicetree/bindings/clock/idt,idt8t49n24x.txt
new file mode 100644
index 000000000..8b52017cf
--- /dev/null
+++ b/Documentation/devicetree/bindings/clock/idt,idt8t49n24x.txt
@@ -0,0 +1,156 @@
+Binding for IDT 8T49N24x Universal Frequency Translator
+
+The 8T49N241 has one fractional-feedback PLL that can be used as a
+jitter attenuator and frequency translator. It is equipped with one
+integer and three fractional output dividers, allowing the generation
+of up to four different output frequencies, ranging from 8kHz to 1GHz.
+These frequencies are completely independent of each other, the input
+reference frequencies and the crystal reference frequency. The device
+places virtually no constraints on input to output frequency conversion,
+supporting all FEC rates, including the new revision of ITU-T
+Recommendation G.709 (2009), most with 0ppm conversion error.
+The outputs may select among LVPECL, LVDS, HCSL or LVCMOS output levels.
+
+The driver can read a full register map from the DT, and will use that
+register map to initialize the attached part (via I2C) when the system
+boots. Any configuration not supported by the common clock framework
+must be done via the full register map, including optimized settings.
+
+The 8T49N241 accepts up to two differential or single-ended input clocks
+and a fundamental-mode crystal input. The internal PLL can lock to either
+of the input reference clocks or just to the crystal to behave as a
+frequency synthesizer. The PLL can use the second input for redundant
+backup of the primary input reference, but in this case, both input clock
+references must be related in frequency.
+
+All outputs are currently assumed to be LVDS, unless overridden in the
+full register map in the DT.
+
+==I2C device node==
+
+Required properties:
+- compatible:	shall be one of "idt,idt8t49n241"
+- reg:		i2c device address, shall be one of 0x7C, 0x6C, 0x7D, 0x6D,
+		0x7E, 0x6E, 0x7F, 0x6F.
+- #clock-cells: From common clock bindings: Shall be 1.
+
+- clocks:	from common clock binding; input clock handle. Required.
+- clock-names:	from common clock binding; clock input names, shall be
+		one of "input-clk0", "input-clk1", "input-xtal". Required.
+
+==Mapping between clock specifier and physical pins==
+
+When referencing the provided clock in the DT using phandle and
+clock specifier, the following mapping applies:
+
+8T49N241:
+	0 -- Q0
+	1 -- Q1
+	2 -- Q2
+	3 -- Q3
+
+==Example==
+
+/* Example1: 25MHz input clock (via CLK0) */
+
+ref25: ref25m {
+	compatible = "fixed-clock";
+	#clock-cells = <0>;
+	clock-frequency = <25000000>;
+};
+
+i2c-master-node {
+
+	/* IDT 8T49N241 i2c universal frequency translator */
+	i2c241: clock-generator@6a {
+		compatible = "idt,idt8t49n241";
+		reg = <0x6c>;
+		#clock-cells = <1>;
+
+		/* Connect input-clk0 to 25MHz reference */
+		clocks = <&ref25m>;
+		clock-names = "input-clk0";
+	};
+};
+
+/* Consumer referencing the 8T49N241 pin Q1 */
+consumer {
+	...
+	clocks = <&i2c241 1>;
+	...
+}
+
+/* Example2: 40MHz xtal frequency, specify all settings */
+
+ref40: ref40m {
+	compatible = "fixed-clock";
+	#clock-cells = <0>;
+	clock-frequency = <40000000>;
+};
+
+i2c-master-node {
+
+	/* IDT 8T49N241 i2c universal frequency translator */
+	i2c241: clock-generator@6a {
+		compatible = "idt,idt8t49n241";
+		reg = <0x6c>;
+		#clock-cells = <1>;
+
+		/* Connect input-xtal to 40MHz reference */
+		clocks = <&ref40m>;
+		clock-names = "input-xtal";
+
+		settings=[
+09 50 00 60 67 C5 6C FF 03 00 30 00 00 01 00 00
+01 07 00 00 07 00 00 77 6D 06 00 00 00 00 00 FF
+FF FF FF 00 3F 00 2A 00 16 33 33 00 01 00 00 D0
+00 00 00 00 00 00 00 00 00 04 00 00 00 02 00 00
+00 00 00 00 00 00 00 17 00 00 00 00 00 00 00 00
+00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
+00 00 00 00 00 00 00 00 D7 0A 2B 20 00 00 00 0B
+00 00 00 00 00 00 00 00 00 00 27 00 00 00 00 00
+00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
+00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
+00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
+00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
+00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
+00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
+00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
+00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
+00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
+00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
+00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
+00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
+00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
+00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
+00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
+00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
+00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
+00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
+00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
+00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
+00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
+00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
+00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
+00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
+C3 00 08 01 00 00 00 00 00 00 00 00 00 30 00 00
+00 0A 00 00 00 00 00 00 00 00 00 00 00 00 00 00
+00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
+00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
+00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
+00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
+00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
+00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
+00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
+00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
+00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
+00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
+00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
+00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
+00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
+00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
+00 00 00 00 85 00 00 9C 01 D4 02 71 07 00 00 00
+00 83 00 10 02 08 8C
+];
+	};
+};
diff --git a/Documentation/devicetree/bindings/clock/silabs,si5324.txt b/Documentation/devicetree/bindings/clock/silabs,si5324.txt
new file mode 100644
index 000000000..642af113a
--- /dev/null
+++ b/Documentation/devicetree/bindings/clock/silabs,si5324.txt
@@ -0,0 +1,78 @@
+Binding for Silicon Labs si5324, si5328 and si5319 programmable
+I2C clock generator.
+
+Reference
+This binding uses the common clock binding[1].
+The si5324 is programmable i2c low-bandwidth, jitter-attenuating, precision
+clock multiplier with up to 2 output clocks. The internal structure can be
+found in [2].
+The internal pin structure of si5328 and si5319 can be found in [3].
+
+[1] Documentation/devicetree/bindings/clock/clock-bindings.txt
+[2] Si5324 Data Sheet
+	http://www.silabs.com/Support%20Documents/TechnicalDocs/Si5324.pdf
+[3] Si53xx Reference Manual
+	http://www.silabs.com/Support%20Documents/TechnicalDocs/
+	Si53xxReferenceManual.pdf
+
+==I2C device node==
+
+Required properties:
+- compatible: should be one of
+	"silabs,si5324"
+	"silabs,si5319"
+	"silabs,si5328"
+- reg: i2c device address.
+- #clock-cells: from common clock binding; shall be set to 1.
+- clocks: from common clock binding; list of parent clock
+  handles, clock name should be one of
+	"xtal"
+	"clkin1"
+	"clkin2"
+- #address-cells: shall be set to 1.
+- #size-cells: shall be set to 0.
+
+Optional properties:
+- silabs,pll-source: pair of (number, source) for each pll. Allows
+  to overwrite clock source of pll.
+
+==Child nodes==
+
+Each of the clock outputs can be overwritten individually by
+using a child node to the I2C device node. If a child node for a clock
+output is not set, the eeprom configuration is not overwritten.
+
+Required child node properties:
+- reg: number of clock output.
+- clock-frequency: default output frequency at power on
+
+Optional child node properties:
+- silabs,drive-strength: output drive strength in mA, shall be one of {2,4,6,8}.
+
+Example:
+Following example describes the ZCU102 board with hdmi design which
+uses si5319 as clock generator. XTAL is hard-wired on the board to act
+as input clock with a frequency of 114.285MHz.
+
+refhdmi: refhdmi {
+	compatible = "fixed-clock";
+	#clock-cells = <0>;
+	clock-frequency = <114285000>;
+};
+
+/* Si5319 i2c clock generator */
+si5319: clock-generator@68 {
+	status = "okay";
+	compatible = "silabs,si5319";
+	reg = <0x68>;
+	#address-cells = <1>;
+	#size-cells = <0>;
+	#clock-cells = <1>;
+	clocks = <&refhdmi>;
+	clock-names = "xtal";
+
+	clk0 {
+		reg = <0>;
+		clock-frequency = <27000000>;
+	};
+};
diff --git a/Documentation/devicetree/bindings/clock/silabs,si570.txt b/Documentation/devicetree/bindings/clock/silabs,si570.txt
index 901935e92..5dda17df1 100644
--- a/Documentation/devicetree/bindings/clock/silabs,si570.txt
+++ b/Documentation/devicetree/bindings/clock/silabs,si570.txt
@@ -28,6 +28,8 @@ Optional properties:
  - clock-frequency: Output frequency to generate. This defines the output
 		    frequency set during boot. It can be reprogrammed during
 		    runtime through the common clock framework.
+ - silabs,skip-recall: Do not perform NVM->RAM recall operation. It will rely
+		       on hardware loading of RAM from NVM at power on.
 
 Example:
 	si570: clock-generator@5d {
diff --git a/Documentation/devicetree/bindings/clock/xlnx,clocking-wizard.txt b/Documentation/devicetree/bindings/clock/xlnx,clocking-wizard.txt
new file mode 100644
index 000000000..aedac845d
--- /dev/null
+++ b/Documentation/devicetree/bindings/clock/xlnx,clocking-wizard.txt
@@ -0,0 +1,32 @@
+Binding for Xilinx Clocking Wizard IP Core
+
+This binding uses the common clock binding[1]. Details about the devices can be
+found in the product guide[2].
+
+[1] Documentation/devicetree/bindings/clock/clock-bindings.txt
+[2] Clocking Wizard Product Guide
+http://www.xilinx.com/support/documentation/ip_documentation/clk_wiz/v5_1/pg065-clk-wiz.pdf
+
+Required properties:
+ - compatible: Must be 'xlnx,clocking-wizard'
+ - #clock-cells: Number of cells in a clock specifier. Should be 1
+ - reg: Base and size of the cores register space
+ - clocks: Handle to input clock
+ - clock-names: Tuple containing 'clk_in1' and 's_axi_aclk'
+ - clock-output-names: Names for the output clocks
+
+Optional properties:
+ - speed-grade: Speed grade of the device (valid values are 1..3)
+
+Example:
+	clock-generator@40040000 {
+		#clock-cells = <1>;
+		reg = <0x40040000 0x1000>;
+		compatible = "xlnx,clocking-wizard";
+		speed-grade = <1>;
+		clock-names = "clk_in1", "s_axi_aclk";
+		clocks = <&clkc 15>, <&clkc 15>;
+		clock-output-names = "clk_out0", "clk_out1", "clk_out2",
+				     "clk_out3", "clk_out4", "clk_out5",
+				     "clk_out6", "clk_out7";
+	};
diff --git a/Documentation/devicetree/bindings/clock/xlnx,versal-wiz.yaml b/Documentation/devicetree/bindings/clock/xlnx,versal-wiz.yaml
new file mode 100644
index 000000000..00d657280
--- /dev/null
+++ b/Documentation/devicetree/bindings/clock/xlnx,versal-wiz.yaml
@@ -0,0 +1,58 @@
+# SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)
+%YAML 1.2
+---
+$id: http://devicetree.org/schemas/clock/xlnx,versal-wiz.yaml#
+$schema: http://devicetree.org/meta-schemas/core.yaml#
+
+title: Xilinx Versal clocking wizard
+
+maintainers:
+  - Shubhrajyoti Datta <shubhrajyoti.datta@xilinx.com>
+
+description: |
+  The clocking wizard is a soft ip clocking block of Xilinx versal. It
+  reads required input clock frequencies from the devicetree and acts as clock
+  clock output.
+
+select: false
+
+properties:
+  compatible:
+    const: xlnx,clk-wizard-1.0
+
+  "#clock-cells":
+    const: 1
+
+  clocks:
+    description: List of clock specifiers which are external input
+      clocks to the given clock controller.
+    items:
+      - description: clock input
+      - description: axi clock
+
+  clock-names:
+    items:
+      - const: clk_in1
+      - const: s_axi_aclk
+
+required:
+  - compatible
+  - "#clock-cells"
+  - clocks
+  - clock-names
+
+additionalProperties: false
+
+examples:
+  - |
+    clock-generator@40040000 {
+        #clock-cells = <1>;
+        reg = <0x40040000 0x1000>;
+        compatible = "xlnx,clk-wizard-1.0";
+        speed-grade = <1>;
+        clock-names = "clk_in1", "s_axi_aclk";
+        clocks = <&clkc 15>, <&clkc 15>;clock-output-names = "clk_out1", "clk_out2",
+        "clk_out3", "clk_out4", "clk_out5",
+        "clk_out6", "clk_out7";
+    };
+...
diff --git a/drivers/clk/Kconfig b/drivers/clk/Kconfig
index c715d4681..ed80aa2c7 100644
--- a/drivers/clk/Kconfig
+++ b/drivers/clk/Kconfig
@@ -158,6 +158,38 @@ config COMMON_CLK_BM1880
 	help
 	  This driver supports the clocks on Bitmain BM1880 SoC.
 
+config COMMON_CLK_SI5324
+	tristate "Clock driver for SiLabs 5324 and compatible devices"
+	depends on I2C
+	depends on OF
+	select REGMAP_I2C
+	help
+	  This driver supports Silicon Labs 5324/5319/5328 programmable
+	  clock generators. Dynamic programming of the oscillator is done
+	  via I2C.
+
+config COMMON_CLK_IDT8T49N24X
+	tristate "Clock driver for IDT 8T49N24x"
+	depends on I2C
+	depends on OF
+	select REGMAP_I2C
+	help
+	---help---
+	  This driver supports the IDT 8T49N24x universal frequency translator
+	  product family.  The only chip in the family that is currently
+	  supported is the 8T49N241. The driver supports setting the rate for
+	  all four outputs on the chip and automatically calculating/setting
+	  the appropriate VCO value.
+
+	  The driver can read a full register map from the DT,
+	  and will use that register map to initialize the attached part
+	  (via I2C) when the system boots. Any configuration not supported
+	  by the common clock framework must be done via the full register
+	  map, including optimized settings.
+
+	  All outputs are currently assumed to be LVDS, unless overridden
+	  in the full register map in the DT.
+
 config COMMON_CLK_CDCE706
 	tristate "Clock driver for TI CDCE706 clock synthesizer"
 	depends on I2C
@@ -359,6 +391,21 @@ config COMMON_CLK_FIXED_MMIO
 	help
 	  Support for Memory Mapped IO Fixed clocks
 
+config COMMON_CLK_XLNX_CLKWZRD
+	tristate "Xilinx Clocking Wizard"
+	depends on COMMON_CLK && OF
+	help
+	  Support for the Xilinx Clocking Wizard IP core clock generator.
+
+config COMMON_CLK_XLNX_CLKWZRD_V
+	tristate "Xilinx Versal Clocking Wizard"
+	depends on COMMON_CLK && OF
+	help
+	  Support for the Versal Xilinx Clocking Wizard IP core clock generator.
+	  Adds support for Versal clocking wizard 1.0 and compatible.
+	  This driver supports the Xilinx clocking wizard programmable clock
+	  synthesizer. The number of output is configurable in the design.
+
 source "drivers/clk/actions/Kconfig"
 source "drivers/clk/analogbits/Kconfig"
 source "drivers/clk/baikal-t1/Kconfig"
diff --git a/drivers/clk/Makefile b/drivers/clk/Makefile
index da8fcf147..ea3745ca2 100644
--- a/drivers/clk/Makefile
+++ b/drivers/clk/Makefile
@@ -62,6 +62,8 @@ obj-$(CONFIG_COMMON_CLK_SI570)		+= clk-si570.o
 obj-$(CONFIG_COMMON_CLK_STM32F)		+= clk-stm32f4.o
 obj-$(CONFIG_COMMON_CLK_STM32H7)	+= clk-stm32h7.o
 obj-$(CONFIG_COMMON_CLK_STM32MP157)	+= clk-stm32mp1.o
+clk-si5324drv-y				:= si5324drv.o clk-si5324.o
+obj-$(CONFIG_COMMON_CLK_SI5324)		+= clk-si5324drv.o
 obj-$(CONFIG_ARCH_TANGO)		+= clk-tango4.o
 obj-$(CONFIG_CLK_TWL6040)		+= clk-twl6040.o
 obj-$(CONFIG_ARCH_U300)			+= clk-u300.o
@@ -69,6 +71,8 @@ obj-$(CONFIG_ARCH_VT8500)		+= clk-vt8500.o
 obj-$(CONFIG_COMMON_CLK_VC5)		+= clk-versaclock5.o
 obj-$(CONFIG_COMMON_CLK_WM831X)		+= clk-wm831x.o
 obj-$(CONFIG_COMMON_CLK_XGENE)		+= clk-xgene.o
+obj-$(CONFIG_COMMON_CLK_XLNX_CLKWZRD)	+= clk-xlnx-clock-wizard.o
+obj-$(CONFIG_COMMON_CLK_XLNX_CLKWZRD_V)	+= clk-xlnx-clock-wizard-v.o
 
 # please keep this section sorted lexicographically by directory path name
 obj-y					+= actions/
@@ -82,6 +86,7 @@ obj-$(CONFIG_ARCH_BERLIN)		+= berlin/
 obj-$(CONFIG_ARCH_DAVINCI)		+= davinci/
 obj-$(CONFIG_H8300)			+= h8300/
 obj-$(CONFIG_ARCH_HISI)			+= hisilicon/
+obj-$(CONFIG_COMMON_CLK_IDT8T49N24X)	+= idt/
 obj-y					+= imgtec/
 obj-y					+= imx/
 obj-y					+= ingenic/
diff --git a/drivers/clk/clk-si5324.c b/drivers/clk/clk-si5324.c
new file mode 100644
index 000000000..7cfe75d7e
--- /dev/null
+++ b/drivers/clk/clk-si5324.c
@@ -0,0 +1,1227 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * clk-si5324.c - Si5324 clock driver
+ *
+ * Copyright (C) 2017-2018 Xilinx, Inc.
+ *
+ * Author:	Venkateshwar Rao G <vgannava.xilinx.com>
+ *		Leon Woestenberg <leon@sidebranch.com>
+ */
+
+#include <asm/div64.h>
+#include <linux/clk.h>
+#include <linux/clk-provider.h>
+#include <linux/delay.h>
+#include <linux/err.h>
+#include <linux/errno.h>
+#include <linux/i2c.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/of_platform.h>
+#include <linux/rational.h>
+#include <linux/regmap.h>
+#include <linux/slab.h>
+#include <linux/string.h>
+
+#include "clk-si5324.h"
+#include "si5324.h"
+#include "si5324drv.h"
+
+struct si5324_driver_data;
+
+/**
+ * struct si5324_parameters - si5324 core parameters
+ *
+ * @n1_hs_min:		Minimum high-speed n1 output divider
+ * @n1_hs_max:		Maximum high-speed n1 output divider
+ * @n1_hs:		n1 high-speed output divider
+ * @nc1_ls_min:		Minimum low-speed clkout1 output divider
+ * @nc1_ls_max:		Maximum low-speed clkout1 output divider
+ * @nc1_ls:		Clkout1 low-speed output divider
+ * @nc2_ls_min:		Minimum low-speed clkout2 output divider
+ * @nc2_ls_max:		Maximum low-speed clkout2 output divider
+ * @nc2_ls:		Clkout2 low-speed output divider
+ * @n2_hs:		High-speed feedback divider
+ * @n2_ls_min:		Minimum low-speed feedback divider
+ * @n2_ls_max:		Maximum low-speed feedback divider
+ * @n2_ls:		Low-speed feedback divider
+ * @n31_min:		Minimum input divider for clk1
+ * @n31_max:		Maximum input divider for clk1
+ * @n31:		Input divider for clk1
+ * @n32_min:		Minimum input divider for clk2
+ * @n32_max:		Maximum input divider for clk2
+ * @n32:		Input divider for clk2
+ * @fin:		Input frequency
+ * @fout:		Output frequency
+ * @fosc:		Osc frequency
+ * @best_delta_fout:	Delta out frequency
+ * @best_fout:		Best output frequency
+ * @best_n1_hs:		Best high speed output divider
+ * @best_nc1_ls:	Best low speed clkout1 divider
+ * @best_n2_hs:		Best high speed feedback divider
+ * @best_n2_ls:		Best low speed feedback divider
+ * @best_n3:		Best input clock divider
+ * @valid: Validility
+ */
+struct si5324_parameters {
+	u32 n1_hs_min;
+	u32 n1_hs_max;
+	u32 n1_hs;
+	u32 nc1_ls_min;
+	u32 nc1_ls_max;
+	u32 nc1_ls;
+	u32 nc2_ls_min;
+	u32 nc2_ls_max;
+	u32 nc2_ls;
+	u32 n2_hs;
+	u32 n2_ls_min;
+	u32 n2_ls_max;
+	u32 n2_ls;
+	u32 n31_min;
+	u32 n31_max;
+	u32 n31;
+	u32 n32_min;
+	u32 n32_max;
+	u32 n32;
+	u64 fin;
+	u64 fout;
+	u64 fosc;
+	u64 best_delta_fout;
+	u64 best_fout;
+	u32 best_n1_hs;
+	u32 best_nc1_ls;
+	u32 best_n2_hs;
+	u32 best_n2_ls;
+	u32 best_n3;
+	int valid;
+};
+
+/**
+ * struct si5324_hw_data - Clock parameters
+ *
+ * @hw:		Handle between common and hardware-specific interfaces
+ * @drvdata:	Driver private data
+ * @num:	Differential pair clock number
+ */
+struct si5324_hw_data {
+	struct clk_hw hw;
+	struct si5324_driver_data *drvdata;
+	unsigned char num;
+};
+
+/**
+ * struct si5324_driver_data - Driver parameters
+ * @client:		I2C client pointer
+ * @regmap:		Device's regmap
+ * @onecell:		Clock onecell data
+ * @params:		Device parameters
+ * @pxtal:		Clock
+ * @pxtal_name:		Clock name
+ * @xtal:		Reference clock
+ * @pclkin1:		Clock in 1
+ * @pclkin1_name:	Clock in 1 name
+ * @clkin1:		Differential input clock 1
+ * @pclkin2:		Clock in 2
+ * @pclkin2_name:	Clock in 2 name
+ * @clkin2:		Differential input clock 2
+ * @pll:		Pll clock
+ * @clkout:		Output clock
+ * @rate_clkout0:	Clock out 0 rate
+ * @rate_clkout1:	Clock out 1 rate
+ */
+struct si5324_driver_data {
+	struct i2c_client		*client;
+	struct regmap			*regmap;
+	struct clk_onecell_data		onecell;
+	struct si5324_parameters	params;
+	struct clk			*pxtal;
+	const char			*pxtal_name;
+	struct clk_hw			xtal;
+	struct clk			*pclkin1;
+	const char			*pclkin1_name;
+	struct clk_hw			clkin1;
+	struct clk			*pclkin2;
+	const char			*pclkin2_name;
+	struct clk_hw			clkin2;
+	struct si5324_hw_data		pll;
+	struct si5324_hw_data		*clkout;
+	unsigned long			rate_clkout0;
+	unsigned long			rate_clkout1;
+};
+
+static const char * const si5324_input_names[] = {
+	"xtal", "clkin1", "clkin2"
+};
+
+static const char * const si5324_pll_name = "pll";
+
+static const char * const si5324_clkout_names[] = {
+	"clk0", "clk1"
+};
+
+enum si53xx_variant {
+	si5319,
+	si5324,
+	si5328
+};
+
+static const char * const si53xx_variant_name[] = {
+	"si5319", "si5324", "si5328"
+};
+
+/**
+ * si5324_reg_read - Read a single si5324 register.
+ *
+ * @drvdata:	Device to read from.
+ * @reg:	Register to read.
+ *
+ * This function reads data from a single register
+ *
+ * Return:	Data of the register on success, error number on failure
+ */
+static inline int
+si5324_reg_read(struct si5324_driver_data *drvdata, u8 reg)
+{
+	u32 val;
+	int ret;
+
+	ret = regmap_read(drvdata->regmap, reg, &val);
+	if (ret < 0) {
+		dev_err(&drvdata->client->dev,
+			"unable to read from reg%02x\n", reg);
+		return ret;
+	}
+
+	return (u8)val;
+}
+
+/**
+ * si5324_bulk_read - Read multiple si5324 registers
+ *
+ * @drvdata:	Device to read from
+ * @reg:	First register to be read from
+ * @count:	Number of registers
+ * @buf:	Pointer to store read value
+ *
+ * This function reads from multiple registers which are in
+ * sequential order
+ *
+ * Return:	Number of bytes read
+ */
+static inline int si5324_bulk_read(struct si5324_driver_data *drvdata,
+				   u8 reg, u8 count, u8 *buf)
+{
+	return regmap_bulk_read(drvdata->regmap, reg, buf, count);
+}
+
+/**
+ * si5324_reg_write - Write a single si5324 register.
+ *
+ * @drvdata:	Device to write to.
+ * @reg:	Register to write to.
+ * @val:	Value to write.
+ *
+ * This function writes into a single register
+ *
+ * Return:	Zero on success, a negative error number on failure.
+ *
+ */
+static inline int si5324_reg_write(struct si5324_driver_data *drvdata,
+				   u8 reg, u8 val)
+{
+	int ret = regmap_write(drvdata->regmap, reg, val);
+
+	dev_dbg(&drvdata->client->dev, "%s 0x%02x @%02d\n", __func__,
+		(int)val, (int)reg);
+	return ret;
+}
+
+/**
+ * si5324_bulk_write - Write into multiple si5324 registers
+ *
+ * @drvdata:	Device to write to
+ * @reg:	First register
+ * @count:	Number of registers
+ * @buf:	Block of data to be written
+ *
+ * This function writes into multiple registers.
+ *
+ * Return:	Zero on success, a negative error number on failure.
+ */
+static inline int si5324_bulk_write(struct si5324_driver_data *drvdata,
+				    u8 reg, u8 count, const u8 *buf)
+{
+	return regmap_raw_write(drvdata->regmap, reg, buf, count);
+}
+
+/**
+ * si5324_set_bits - Set the value of a bitfield in a si5324 register
+ *
+ * @drvdata:	Device to write to.
+ * @reg:	Register to write to.
+ * @mask:	Mask of bits to set.
+ * @val:	Value to set (unshifted)
+ *
+ * This function set particular bits in register
+ *
+ * Return:	Zero on success, a negative error number on failure.
+ */
+static inline int si5324_set_bits(struct si5324_driver_data *drvdata,
+				  u8 reg, u8 mask, u8 val)
+{
+	return regmap_update_bits(drvdata->regmap, reg, mask, val);
+}
+
+/**
+ * si5324_bulk_scatter_write - Write into multiple si5324 registers
+ *
+ * @drvdata:	Device to write to
+ * @count:	Number of registers
+ * @buf:	Register and data to write
+ *
+ * This function writes into multiple registers which are need not
+ * to be in sequential order.
+ *
+ * Return:	Number of bytes written
+ */
+static inline int
+si5324_bulk_scatter_write(struct si5324_driver_data *drvdata,
+			  u8 count, const u8 *buf)
+{
+	int i;
+	int ret = 0;
+
+	for (i = 0; i < count; i++) {
+		ret = si5324_reg_write(drvdata, buf[i * 2], buf[i * 2 + 1]);
+		if (ret)
+			return ret;
+	}
+	return ret;
+}
+
+/**
+ * si5324_initialize - Initializes si5324 device
+ *
+ * @drvdata:	Device instance
+ *
+ * This function initializes si5324 with the following settings
+ * Keep reset asserted for 20ms
+ * 1. freerun mode
+ * 2. Disable output clocks during calibration
+ * 3. Clock selection mode : default value, manual
+ * 4. output signal format : LVDS for clkout1, disable clkout2
+ * 5. CS_CA pin in ignored
+ * 6. Set lock time to 13.3ms
+ * 7. Enables the fastlock.
+ *
+ * Return:	Zero on success, negative number on failure.
+ */
+static int si5324_initialize(struct si5324_driver_data *drvdata)
+{
+	int ret = 0;
+
+	si5324_set_bits(drvdata, SI5324_RESET_CALIB,
+			SI5324_RST_ALL, SI5324_RST_ALL);
+	msleep(SI5324_RESET_DELAY_MS);
+	si5324_set_bits(drvdata, SI5324_RESET_CALIB, SI5324_RST_ALL, 0);
+	msleep(SI5324_RESET_DELAY_MS);
+
+	ret = si5324_reg_read(drvdata, SI5324_CONTROL);
+	if (ret < 0)
+		return ret;
+
+	si5324_reg_write(drvdata, SI5324_CONTROL,
+			 (ret | SI5324_CONTROL_FREE_RUN));
+
+	ret = si5324_reg_read(drvdata, SI5324_CKSEL);
+	if (ret < 0)
+		return ret;
+
+	si5324_reg_write(drvdata, SI5324_CKSEL, (ret | SI5324_CKSEL_SQL_ICAL));
+	si5324_reg_write(drvdata, SI3324_AUTOSEL, SI5324_AUTOSEL_DEF);
+	si5324_reg_write(drvdata, SI5324_OUTPUT_SIGFMT,
+			 SI5324_OUTPUT_SF1_DEFAULT);
+
+	ret = si5324_reg_read(drvdata, SI5324_DSBL_CLKOUT);
+	if (ret < 0)
+		return ret;
+
+	si5324_reg_write(drvdata, SI5324_DSBL_CLKOUT,
+			 (ret | SI5324_DSBL_CLKOUT2));
+	ret = si5324_reg_read(drvdata, SI5324_POWERDOWN);
+	if (ret < 0)
+		return ret;
+
+	si5324_reg_write(drvdata, SI5324_POWERDOWN, (ret | SI5324_PD_CK2));
+	si5324_reg_write(drvdata, SI5324_FOS_LOCKT, SI5324_FOS_DEFAULT);
+
+	ret = si5324_reg_read(drvdata, SI5324_CK_ACTV_SEL);
+	if (ret < 0)
+		return ret;
+
+	si5324_reg_write(drvdata, SI5324_CK_ACTV_SEL, SI5324_CK_DEFAULT);
+	ret = si5324_reg_read(drvdata, SI5324_FASTLOCK);
+	if (ret < 0)
+		return ret;
+
+	si5324_reg_write(drvdata, SI5324_FASTLOCK, (ret | SI5324_FASTLOCK_EN));
+	return 0;
+}
+
+/**
+ * si5324_read_parameters - Reads clock divider parameters
+ *
+ * @drvdata:	Device to read from
+ *
+ * This function reads the clock divider parameters into driver structure.
+ *
+ * Following table gives the buffer index, register number and
+ * register name with bit fields
+ * 0 25 N1_HS[2:0]
+ * 6 31 NC1_LS[19:16]
+ * 7 32 NC1_LS[15:8]
+ * 8 33 NC1_LS[7:0]
+ * 9 34 NC2_LS[19:16]
+ * 10 35 NC2_LS[15:8]
+ * 11 36 NC2_LS[7:0]
+ * 15 40 N2_HS[2:0] N2_LS[19:16]
+ * 16 41 N2_LS[15:8]
+ * 17 42 N2_LS[7:0]
+ * 18 43 N31[18:16]
+ * 19 44 N31[15:8]
+ * 20 45 N31[7:0]
+ * 21 46 N32[18:16]
+ * 22 47 N32[15:8]
+ * 23 48 N32[7:0]
+ */
+static void si5324_read_parameters(struct si5324_driver_data *drvdata)
+{
+	u8 buf[SI5324_PARAM_LEN];
+
+	si5324_bulk_read(drvdata, SI5324_N1_HS, SI5324_N1_PARAM_LEN, &buf[0]);
+	si5324_bulk_read(drvdata, SI5324_NC1_LS_H, SI5324_NC_PARAM_LEN,
+			 &buf[6]);
+	si5324_bulk_read(drvdata, SI5324_N2_HS_LS_H, SI5324_N2_PARAM_LEN,
+			 &buf[15]);
+
+	drvdata->params.n1_hs = (buf[0] >> SI5324_N1_HS_VAL_SHIFT);
+	drvdata->params.n1_hs += 4;
+
+	drvdata->params.nc1_ls = ((buf[6] & SI5324_DIV_LS_MASK) <<
+				  SI5324_HSHIFT) | (buf[7] << SI5324_LSHIFT) |
+				  buf[8];
+	drvdata->params.nc1_ls += 1;
+	drvdata->params.nc2_ls = ((buf[9] & SI5324_DIV_LS_MASK) <<
+				  SI5324_HSHIFT) | (buf[10] << SI5324_LSHIFT) |
+				  buf[11];
+	drvdata->params.nc2_ls += 1;
+	drvdata->params.n2_ls = ((buf[15] & SI5324_DIV_LS_MASK) <<
+				 SI5324_HSHIFT) | (buf[16] << SI5324_LSHIFT) |
+				 buf[17];
+	drvdata->params.n2_ls += 1;
+	drvdata->params.n2_hs = buf[15] >> SI5324_N2_HS_LS_H_VAL_SHIFT;
+	drvdata->params.n2_hs += 4;
+	drvdata->params.n31 = ((buf[18] & SI5324_DIV_LS_MASK) <<
+				SI5324_HSHIFT) | (buf[19] << SI5324_LSHIFT) |
+				buf[20];
+	drvdata->params.n31 += 1;
+	drvdata->params.n32 = ((buf[21] & SI5324_DIV_LS_MASK) <<
+				SI5324_HSHIFT) | (buf[22] << SI5324_LSHIFT) |
+				buf[23];
+	drvdata->params.n32 += 1;
+	drvdata->params.valid = 1;
+}
+
+static bool si5324_regmap_is_volatile(struct device *dev, unsigned int reg)
+{
+	return true;
+}
+
+/**
+ * si5324_regmap_is_readable - Checks the register is readable or not
+ *
+ * @dev:	Registered device
+ * @reg:	Register offset
+ *
+ * Checks the register is readable or not.
+ *
+ * Return:	True if the register is reabdle, False if it is not readable.
+ */
+static bool si5324_regmap_is_readable(struct device *dev, unsigned int reg)
+{
+	if ((reg > SI5324_POWERDOWN && reg < SI5324_FOS_LOCKT) ||
+	    (reg > SI5324_N1_HS && reg < SI5324_NC1_LS_H) ||
+	    (reg > SI5324_NC2_LS_L && reg < SI5324_N2_HS_LS_H) ||
+	    (reg > SI5324_N32_CLKIN_L && reg < SI5324_FOS_CLKIN_RATE) ||
+	    (reg > SI5324_FOS_CLKIN_RATE && reg < SI5324_PLL_ACTV_CLK) ||
+	    reg > SI5324_SKEW2)
+		return false;
+
+	return true;
+}
+
+/**
+ * si5324_regmap_is_writable - Checks the register is writable or not
+ *
+ * @dev:	Registered device
+ * @reg:	Register offset
+ *
+ * Checks the register is writable or not.
+ *
+ * Return:	True if the register is writeable, False if it's not writeable.
+ */
+static bool si5324_regmap_is_writeable(struct device *dev, unsigned int reg)
+{
+	if ((reg > SI5324_POWERDOWN && reg < SI5324_FOS_LOCKT) ||
+	    (reg > SI5324_N1_HS && reg < SI5324_NC1_LS_H) ||
+	    (reg > SI5324_NC2_LS_L && reg < SI5324_N2_HS_LS_H) ||
+	    (reg > SI5324_N32_CLKIN_L && reg < SI5324_FOS_CLKIN_RATE) ||
+	    (reg > SI5324_FOS_CLKIN_RATE && reg < SI5324_PLL_ACTV_CLK) ||
+	    reg > SI5324_SKEW2 ||
+	    (reg >= SI5324_PLL_ACTV_CLK && reg <= SI5324_CLKIN_LOL_STATUS) ||
+	    (reg >= SI5324_PARTNO_H && reg <= SI5324_PARTNO_L))
+		return false;
+
+	return true;
+}
+
+static const struct regmap_config si5324_regmap_config = {
+	.reg_bits = 8,
+	.val_bits = 8,
+	.cache_type = REGCACHE_RBTREE,
+	.max_register = 144,
+	.writeable_reg = si5324_regmap_is_writeable,
+	.readable_reg = si5324_regmap_is_readable,
+	.volatile_reg = si5324_regmap_is_volatile,
+};
+
+static int si5324_xtal_prepare(struct clk_hw *hw)
+{
+	return 0;
+}
+
+static void si5324_xtal_unprepare(struct clk_hw *hw)
+{
+}
+
+static const struct clk_ops si5324_xtal_ops = {
+	.prepare = si5324_xtal_prepare,
+	.unprepare = si5324_xtal_unprepare,
+};
+
+/**
+ * si5324_clkin_prepare - Prepare the clkin
+ *
+ * @hw:		Handle between common and hardware-specific interfaces
+ *
+ * This function enables the particular clk
+ *
+ * Return:	Zero on success, a negative error number on failure.
+ */
+static int si5324_clkin_prepare(struct clk_hw *hw)
+{
+	int ret = 0;
+	struct si5324_driver_data *drvdata;
+	struct si5324_hw_data *hwdata =
+		container_of(hw, struct si5324_hw_data, hw);
+
+	if (hwdata->num == SI5324_CLKIN1) {
+		drvdata = container_of(hw, struct si5324_driver_data, clkin1);
+		ret = si5324_set_bits(drvdata, SI5324_CONTROL,
+				      SI5324_CONTROL_FREE_RUN, 0);
+		ret = si5324_set_bits(drvdata, SI5324_POWERDOWN, SI5324_PD_CK1 |
+				      SI5324_PD_CK2, SI5324_PD_CK2);
+	} else if (hwdata->num == SI5324_CLKIN2) {
+		drvdata = container_of(hw, struct si5324_driver_data, clkin2);
+		ret = si5324_set_bits(drvdata, SI5324_CONTROL,
+				      SI5324_CONTROL_FREE_RUN, 0);
+		ret = si5324_set_bits(drvdata, SI5324_POWERDOWN, SI5324_PD_CK1 |
+				      SI5324_PD_CK2, SI5324_PD_CK1);
+	}
+
+	return ret;
+}
+
+/**
+ * si5324_clkin_unprepare - Unprepare the clkin
+ *
+ * @hw:		Clock hardware
+ *
+ * This function enables the particular clk.
+ */
+static void si5324_clkin_unprepare(struct clk_hw *hw)
+{
+	struct si5324_driver_data *drvdata;
+	struct si5324_hw_data *hwdata =
+		container_of(hw, struct si5324_hw_data, hw);
+
+	if (hwdata->num == SI5324_CLKIN1) {
+		drvdata = container_of(hw, struct si5324_driver_data, clkin1);
+		si5324_set_bits(drvdata, SI5324_POWERDOWN,
+				SI5324_PD_CK1 | SI5324_PD_CK2, SI5324_PD_CK1);
+	} else if (hwdata->num == SI5324_CLKIN2) {
+		drvdata = container_of(hw, struct si5324_driver_data, clkin2);
+		si5324_set_bits(drvdata, SI5324_POWERDOWN,
+				SI5324_PD_CK1 | SI5324_PD_CK2, SI5324_PD_CK1);
+	}
+}
+
+static unsigned long si5324_clkin_recalc_rate(struct clk_hw *hw,
+					      unsigned long parent_rate)
+{
+	return 0;
+}
+
+static const struct clk_ops si5324_clkin_ops = {
+	.prepare = si5324_clkin_prepare,
+	.unprepare = si5324_clkin_unprepare,
+	.recalc_rate = si5324_clkin_recalc_rate,
+};
+
+static int si5324_pll_reparent(struct si5324_driver_data *drvdata,
+			       int num, enum si5324_pll_src parent)
+{
+	if (parent == SI5324_PLL_SRC_XTAL) {
+		si5324_set_bits(drvdata, SI5324_CONTROL,
+				SI5324_CONTROL_FREE_RUN,
+				SI5324_CONTROL_FREE_RUN);
+		si5324_set_bits(drvdata, SI5324_POWERDOWN,
+				SI5324_PD_CK1 | SI5324_PD_CK2, SI5324_PD_CK1);
+		si5324_set_bits(drvdata, SI5324_CKSEL,
+				SI5324_CK_SEL << SI5324_CKSEL_SHIFT,
+				1 << SI5324_CKSEL_SHIFT);
+	} else if (parent == SI5324_PLL_SRC_CLKIN1) {
+		si5324_set_bits(drvdata, SI5324_CONTROL,
+				SI5324_CONTROL_FREE_RUN, 0);
+		si5324_set_bits(drvdata, SI5324_POWERDOWN,
+				SI5324_PD_CK1 | SI5324_PD_CK2, SI5324_PD_CK2);
+		si5324_set_bits(drvdata, SI5324_CKSEL,
+				SI5324_CK_SEL << SI5324_CKSEL_SHIFT, 0);
+	} else if (parent == SI5324_PLL_SRC_CLKIN2) {
+		si5324_set_bits(drvdata, SI5324_CONTROL,
+				SI5324_CONTROL_FREE_RUN, 0);
+		si5324_set_bits(drvdata, SI5324_POWERDOWN,
+				SI5324_PD_CK1 | SI5324_PD_CK2, SI5324_PD_CK1);
+		si5324_set_bits(drvdata, SI5324_CKSEL,
+				SI5324_CK_SEL << SI5324_CKSEL_SHIFT,
+				1 << SI5324_CKSEL_SHIFT);
+	}
+
+	return 0;
+}
+
+static unsigned char si5324_pll_get_parent(struct clk_hw *hw)
+{
+	return 0;
+}
+
+/**
+ * si5324_pll_set_parent - Set parent of clock
+ *
+ * @hw:		Handle between common and hardware-specific interfaces
+ * @index:	Parent index
+ *
+ * This function sets the paraent of clock.
+ *
+ * Return:	0 on success, negative error number on failure
+ */
+static int si5324_pll_set_parent(struct clk_hw *hw, u8 index)
+{
+	struct si5324_hw_data *hwdata =
+		container_of(hw, struct si5324_hw_data, hw);
+	enum si5324_pll_src parent;
+
+	if (index == SI5324_SRC_XTAL)
+		parent = SI5324_PLL_SRC_XTAL;
+	else if (index == SI5324_SRC_CLKIN1)
+		parent = SI5324_PLL_SRC_CLKIN1;
+	else if (index == SI5324_SRC_CLKIN2)
+		parent = SI5324_PLL_SRC_CLKIN2;
+	else
+		return -EINVAL;
+
+	return si5324_pll_reparent(hwdata->drvdata, hwdata->num, parent);
+}
+
+/**
+ * si5324_pll_recalc_rate - Recalculate clock frequency
+ *
+ * @hw:			Handle between common and hardware-specific interfaces
+ * @parent_rate:	Clock frequency of parent clock
+ *
+ * This function recalculate clock frequency.
+ *
+ * Return:		Current clock frequency
+ */
+static unsigned long si5324_pll_recalc_rate(struct clk_hw *hw,
+					    unsigned long parent_rate)
+{
+	unsigned long rate;
+	struct si5324_hw_data *hwdata =
+		container_of(hw, struct si5324_hw_data, hw);
+
+	if (!hwdata->drvdata->params.valid)
+		si5324_read_parameters(hwdata->drvdata);
+	WARN_ON(!hwdata->drvdata->params.valid);
+
+	rate = parent_rate * hwdata->drvdata->params.n2_ls *
+		hwdata->drvdata->params.n2_hs;
+
+	dev_dbg(&hwdata->drvdata->client->dev,
+		"%s - %s: n2_ls = %u, n2_hs = %u, parent_rate = %lu, rate = %lu\n",
+		__func__, clk_hw_get_name(hw),
+		hwdata->drvdata->params.n2_ls, hwdata->drvdata->params.n2_hs,
+		parent_rate, (unsigned long)rate);
+
+	return rate;
+}
+
+static long si5324_pll_round_rate(struct clk_hw *hw, unsigned long rate,
+				  unsigned long *parent_rate)
+{
+	return rate;
+}
+
+static int si5324_pll_set_rate(struct clk_hw *hw, unsigned long rate,
+			       unsigned long parent_rate)
+{
+	return 0;
+}
+
+static const struct clk_ops si5324_pll_ops = {
+	.set_parent = si5324_pll_set_parent,
+	.get_parent = si5324_pll_get_parent,
+	.recalc_rate = si5324_pll_recalc_rate,
+	.round_rate = si5324_pll_round_rate,
+	.set_rate = si5324_pll_set_rate,
+};
+
+static int si5324_clkout_set_drive_strength(
+	struct si5324_driver_data *drvdata, int num,
+	enum si5324_drive_strength drive)
+{
+	return 0;
+}
+
+static int si5324_clkout_prepare(struct clk_hw *hw)
+{
+	return 0;
+}
+
+static void si5324_clkout_unprepare(struct clk_hw *hw)
+{
+}
+
+static unsigned long si5324_clkout_recalc_rate(struct clk_hw *hw,
+					       unsigned long parent_rate)
+{
+	unsigned long rate;
+
+	struct si5324_hw_data *hwdata =
+		container_of(hw, struct si5324_hw_data, hw);
+
+	rate = hwdata->drvdata->rate_clkout0;
+
+	return rate;
+}
+
+/**
+ * si5324_clkout_round_rate - selects the closest value to requested one.
+ *
+ * @hw:			Handle between common and hardware-specific interfaces
+ * @rate:		Clock rate
+ * @parent_rate:	Parent clock rate
+ *
+ * This function selects the rate closest to the requested one.
+ *
+ * Return:		Clock rate on success, negative error number on failure
+ */
+static long si5324_clkout_round_rate(struct clk_hw *hw, unsigned long rate,
+				     unsigned long *parent_rate)
+{
+	u32 ncn_ls, n2_ls, n3n, actual_rate;
+	u8 n1_hs, n2_hs, bwsel;
+	int ret;
+
+	ret = si5324_calcfreqsettings(SI5324_REF_CLOCK, rate, &actual_rate,
+				      &n1_hs, &ncn_ls, &n2_hs, &n2_ls, &n3n,
+				      &bwsel);
+	if (ret < 0)
+		return ret;
+
+	return actual_rate;
+}
+
+static int si5324_clkout_set_rate(struct clk_hw *hw, unsigned long rate,
+				  unsigned long parent_rate)
+{
+	struct si5324_hw_data *hwdata =
+		container_of(hw, struct si5324_hw_data, hw);
+
+	u32 ncn_ls, n2_ls, n3n, actual_rate;
+	u8 n1_hs, n2_hs, bwsel, buf[SI5324_OUT_REGS * 2];
+	int i, ret, rc;
+
+	ret = si5324_calcfreqsettings(SI5324_REF_CLOCK, rate, &actual_rate,
+				      &n1_hs, &ncn_ls, &n2_hs, &n2_ls, &n3n,
+				      &bwsel);
+	if (ret < 0)
+		return ret;
+
+	hwdata->drvdata->rate_clkout0 = rate;
+	i = 0;
+
+	/* Enable Free running mode */
+	buf[i] = SI5324_CONTROL;
+	buf[i + 1] = SI5324_FREE_RUN_EN;
+	i += 2;
+
+	/* Loop bandwidth */
+	buf[i] = SI5324_BWSEL;
+	buf[i + 1] = (bwsel << SI5324_BWSEL_SHIFT) | SI5324_BWSEL_DEF_VAL;
+	i += 2;
+
+	/* Enable reference clock 2 in free running mode */
+	buf[i] = SI5324_POWERDOWN;
+	/* Enable input clock 2, Disable input clock 1 */
+	buf[i + 1] = SI5324_PD_CK1_DIS;
+	i += 2;
+
+	/* N1_HS */
+	buf[i] = SI5324_N1_HS;
+	buf[i + 1] = n1_hs << SI5324_N1_HS_VAL_SHIFT;
+	i += 2;
+
+	/* NC1_LS */
+	buf[i] = SI5324_NC1_LS_H;
+	buf[i + 1] = (u8)((ncn_ls & 0x000F0000) >> 16);
+	buf[i + 2] = SI5324_NC1_LS_M;
+	buf[i + 3] = (u8)((ncn_ls & 0x0000FF00) >> 8);
+	buf[i + 4] = SI5324_NC1_LS_L;
+	buf[i + 5] = (u8)(ncn_ls & 0x000000FF);
+	i += 6;
+
+	/* N2_HS and N2_LS */
+	buf[i] = SI5324_N2_HS_LS_H;
+	buf[i + 1] = (n2_hs << SI5324_N2_HS_LS_H_VAL_SHIFT);
+	buf[i + 1] |= (u8)((n2_ls & 0x000F0000) >> 16);
+	buf[i + 2] = SI5324_N2_LS_H;
+	buf[i + 3] = (u8)((n2_ls & 0x0000FF00) >> 8);
+	buf[i + 4] = SI5324_N2_LS_L;
+	buf[i + 5] = (u8)(n2_ls & 0x000000FF);
+	i += 6;
+
+	/* N32 (CLKIN2 or XTAL in FREERUNNING mode) */
+	buf[i] = SI5324_N32_CLKIN_H;
+	buf[i + 2] = SI5324_N32_CLKIN_M;
+	buf[i + 4] = SI5324_N32_CLKIN_L;
+	buf[i + 1] = (u8)((n3n & 0x00070000) >> 16);
+	buf[i + 3] = (u8)((n3n & 0x0000FF00) >> 8);
+	buf[i + 5] = (u8)(n3n & 0x000000FF);
+	i += 6;
+
+	/* Start calibration */
+	buf[i] = SI5324_RESET_CALIB;
+	buf[i + 1] = SI5324_CALIB_EN;
+	i += 2;
+
+	hwdata->drvdata->params.valid = 0;
+	rc = si5324_bulk_scatter_write(hwdata->drvdata, SI5324_OUT_REGS, buf);
+
+	return rc;
+}
+
+static const struct clk_ops si5324_clkout_ops = {
+	.prepare = si5324_clkout_prepare,
+	.unprepare = si5324_clkout_unprepare,
+	.recalc_rate = si5324_clkout_recalc_rate,
+	.round_rate = si5324_clkout_round_rate,
+	.set_rate = si5324_clkout_set_rate,
+};
+
+static const struct of_device_id si5324_dt_ids[] = {
+	{ .compatible = "silabs,si5319" },
+	{ .compatible = "silabs,si5324" },
+	{ .compatible = "silabs,si5328" },
+	{ }
+};
+MODULE_DEVICE_TABLE(of, si5324_dt_ids);
+
+static int si5324_dt_parse(struct i2c_client *client)
+{
+	struct device_node *child, *np = client->dev.of_node;
+	struct si5324_platform_data *pdata;
+	struct property *prop;
+	const __be32 *p;
+	int num = 0;
+	u32 val;
+
+	if (!np)
+		return 0;
+
+	pdata = devm_kzalloc(&client->dev, sizeof(*pdata), GFP_KERNEL);
+	if (!pdata)
+		return -ENOMEM;
+
+	/*
+	 * property silabs,pll-source : <num src>, [<..>]
+	 * allow to selectively set pll source
+	 */
+	of_property_for_each_u32(np, "silabs,pll-source", prop, p, num) {
+		if (num >= 1) {
+			dev_err(&client->dev,
+				"invalid pll %d on pll-source prop\n", num);
+			return -EINVAL;
+		}
+		p = of_prop_next_u32(prop, p, &val);
+		if (!p) {
+			dev_err(&client->dev,
+				"missing pll-source for pll %d\n", num);
+			return -EINVAL;
+		}
+
+		switch (val) {
+		case 0:
+			dev_dbg(&client->dev, "using xtal as parent for pll\n");
+			pdata->pll_src = SI5324_PLL_SRC_XTAL;
+			break;
+		case 1:
+			dev_dbg(&client->dev,
+				"using clkin1 as parent for pll\n");
+			pdata->pll_src = SI5324_PLL_SRC_CLKIN1;
+			break;
+		case 2:
+			dev_dbg(&client->dev,
+				"using clkin2 as parent for pll\n");
+			pdata->pll_src = SI5324_PLL_SRC_CLKIN2;
+			break;
+		default:
+			dev_err(&client->dev,
+				"invalid parent %d for pll %d\n", val, num);
+			return -EINVAL;
+		}
+	}
+	/* per clkout properties */
+	for_each_child_of_node(np, child) {
+		if (of_property_read_u32(child, "reg", &num)) {
+			dev_err(&client->dev, "missing reg property of %s\n",
+				child->name);
+			goto put_child;
+		}
+
+		if (num >= 2) {
+			dev_err(&client->dev, "invalid clkout %d\n", num);
+			goto put_child;
+		}
+
+		if (!of_property_read_u32(child, "silabs,drive-strength",
+					  &val)) {
+			switch (val) {
+			case SI5324_DRIVE_2MA:
+			case SI5324_DRIVE_4MA:
+			case SI5324_DRIVE_6MA:
+			case SI5324_DRIVE_8MA:
+				pdata->clkout[num].drive = val;
+				break;
+			default:
+				dev_err(&client->dev,
+					"invalid drive strength %d for clkout %d\n",
+					val, num);
+				goto put_child;
+			}
+		}
+
+		if (!of_property_read_u32(child, "clock-frequency", &val)) {
+			dev_dbg(&client->dev, "clock-frequency = %u\n", val);
+			pdata->clkout[num].rate = val;
+		} else {
+			dev_err(&client->dev,
+				"missing clock-frequency property of %s\n",
+				child->name);
+			goto put_child;
+		}
+	}
+	client->dev.platform_data = pdata;
+
+	return 0;
+put_child:
+	of_node_put(child);
+	return -EINVAL;
+}
+
+static u8 instance;
+
+static int si5324_i2c_probe(struct i2c_client *client,
+			    const struct i2c_device_id *id)
+{
+	struct si5324_platform_data *pdata;
+	struct si5324_driver_data *drvdata;
+	struct clk_init_data init;
+	struct clk *clk;
+	const char *parent_names[3];
+	char inst_names[NUM_NAME_IDS][MAX_NAME_LEN];
+	u8 num_parents, num_clocks;
+	int ret, n;
+	enum si53xx_variant variant = id->driver_data;
+
+	if (variant > si5328) {
+		dev_err(&client->dev, "si53xx device not present\n");
+		return -ENODEV;
+	}
+
+	dev_info(&client->dev, "%s probed\n", si53xx_variant_name[variant]);
+	ret = si5324_dt_parse(client);
+	if (ret)
+		return ret;
+
+	pdata = client->dev.platform_data;
+	if (!pdata)
+		return -EINVAL;
+
+	drvdata = devm_kzalloc(&client->dev, sizeof(*drvdata), GFP_KERNEL);
+	if (!drvdata)
+		return -ENOMEM;
+
+	drvdata->client = client;
+	drvdata->pxtal = devm_clk_get(&client->dev, "xtal");
+	drvdata->pclkin1 = devm_clk_get(&client->dev, "clkin1");
+	drvdata->pclkin2 = devm_clk_get(&client->dev, "clkin2");
+
+	if (PTR_ERR(drvdata->pxtal) == -EPROBE_DEFER ||
+	    PTR_ERR(drvdata->pclkin1) == -EPROBE_DEFER ||
+	    PTR_ERR(drvdata->pclkin2) == -EPROBE_DEFER)
+		return -EPROBE_DEFER;
+
+	drvdata->regmap = devm_regmap_init_i2c(client, &si5324_regmap_config);
+	if (IS_ERR(drvdata->regmap)) {
+		dev_err(&client->dev, "failed to allocate register map\n");
+		return PTR_ERR(drvdata->regmap);
+	}
+
+	i2c_set_clientdata(client, drvdata);
+	si5324_initialize(drvdata);
+
+	/* setup input clock configuration */
+	ret = si5324_pll_reparent(drvdata, 0, pdata->pll_src);
+	if (ret) {
+		dev_err(&client->dev,
+			"failed to reparent pll to %d\n",
+			pdata->pll_src);
+		return ret;
+	}
+
+	for (n = 0; n < SI5324_MAX_CLKOUTS; n++) {
+		ret = si5324_clkout_set_drive_strength(drvdata, n,
+						       pdata->clkout[n].drive);
+		if (ret) {
+			dev_err(&client->dev,
+				"failed set drive strength of clkout%d to %d\n",
+				n, pdata->clkout[n].drive);
+			return ret;
+		}
+	}
+
+	if (!IS_ERR(drvdata->pxtal))
+		clk_prepare_enable(drvdata->pxtal);
+	if (!IS_ERR(drvdata->pclkin1))
+		clk_prepare_enable(drvdata->pclkin1);
+	if (!IS_ERR(drvdata->pclkin2))
+		clk_prepare_enable(drvdata->pclkin2);
+
+	/* create instance names by appending instance id */
+	for (n = 0; n < SI5324_SRC_CLKS; n++) {
+		sprintf(inst_names[n], "%s_%d", si5324_input_names[n],
+			instance);
+	}
+	sprintf(inst_names[3], "%s_%d", si5324_pll_name, instance);
+	for (n = 0; n < SI5324_MAX_CLKOUTS; n++) {
+		sprintf(inst_names[n + 4], "%s_%d", si5324_clkout_names[n],
+			instance);
+	}
+
+	/* register xtal input clock gate */
+	memset(&init, 0, sizeof(init));
+	init.name = inst_names[0];
+	init.ops = &si5324_xtal_ops;
+	init.flags = 0;
+
+	if (!IS_ERR(drvdata->pxtal)) {
+		drvdata->pxtal_name = __clk_get_name(drvdata->pxtal);
+		init.parent_names = &drvdata->pxtal_name;
+		init.num_parents = 1;
+	}
+	drvdata->xtal.init = &init;
+
+	clk = devm_clk_register(&client->dev, &drvdata->xtal);
+	if (IS_ERR(clk)) {
+		dev_err(&client->dev, "unable to register %s\n", init.name);
+		ret = PTR_ERR(clk);
+		goto err_clk;
+	}
+
+	/* register clkin1 input clock gate */
+	memset(&init, 0, sizeof(init));
+	init.name = inst_names[1];
+	init.ops = &si5324_clkin_ops;
+	if (!IS_ERR(drvdata->pclkin1)) {
+		drvdata->pclkin1_name = __clk_get_name(drvdata->pclkin1);
+		init.parent_names = &drvdata->pclkin1_name;
+		init.num_parents = 1;
+	}
+
+	drvdata->clkin1.init = &init;
+	clk = devm_clk_register(&client->dev, &drvdata->clkin1);
+	if (IS_ERR(clk)) {
+		dev_err(&client->dev, "unable to register %s\n",
+			init.name);
+		ret = PTR_ERR(clk);
+		goto err_clk;
+	}
+
+	/* register clkin2 input clock gate */
+	memset(&init, 0, sizeof(init));
+	init.name = inst_names[2];
+	init.ops = &si5324_clkin_ops;
+	if (!IS_ERR(drvdata->pclkin2)) {
+		drvdata->pclkin2_name = __clk_get_name(drvdata->pclkin2);
+		init.parent_names = &drvdata->pclkin2_name;
+		init.num_parents = 1;
+	}
+
+	drvdata->clkin2.init = &init;
+	clk = devm_clk_register(&client->dev, &drvdata->clkin2);
+	if (IS_ERR(clk)) {
+		dev_err(&client->dev, "unable to register %s\n",
+			init.name);
+		ret = PTR_ERR(clk);
+		goto err_clk;
+	}
+
+	/* Si5324 allows to mux xtal or clkin1 or clkin2 to PLL input */
+	num_parents = SI5324_SRC_CLKS;
+	parent_names[0] = inst_names[0];
+	parent_names[1] = inst_names[1];
+	parent_names[2] = inst_names[2];
+
+	/* register PLL */
+	drvdata->pll.drvdata = drvdata;
+	drvdata->pll.hw.init = &init;
+	memset(&init, 0, sizeof(init));
+	init.name = inst_names[3];
+	init.ops = &si5324_pll_ops;
+	init.flags = 0;
+	init.flags |= CLK_SET_RATE_PARENT | CLK_GET_RATE_NOCACHE;
+	init.parent_names = parent_names;
+	init.num_parents = num_parents;
+
+	clk = devm_clk_register(&client->dev, &drvdata->pll.hw);
+	if (IS_ERR(clk)) {
+		dev_err(&client->dev, "unable to register %s\n", init.name);
+		ret = PTR_ERR(clk);
+		goto err_clk;
+	}
+
+	/* register clk out divider */
+	num_clocks = 2;
+	num_parents = 1;
+	parent_names[0] = inst_names[3];
+
+	drvdata->clkout = devm_kzalloc(&client->dev, num_clocks *
+				       sizeof(*drvdata->clkout), GFP_KERNEL);
+
+	drvdata->onecell.clk_num = num_clocks;
+	drvdata->onecell.clks = devm_kzalloc(&client->dev,
+					     num_clocks *
+					     sizeof(*drvdata->onecell.clks),
+					     GFP_KERNEL);
+
+	if (WARN_ON(!drvdata->clkout) || !drvdata->onecell.clks) {
+		ret = -ENOMEM;
+		goto err_clk;
+	}
+
+	for (n = 0; n < num_clocks; n++) {
+		drvdata->clkout[n].num = n;
+		drvdata->clkout[n].drvdata = drvdata;
+		drvdata->clkout[n].hw.init = &init;
+		memset(&init, 0, sizeof(init));
+		init.name = inst_names[4 + n];
+		init.ops = &si5324_clkout_ops;
+		init.flags = 0;
+		init.flags |= CLK_SET_RATE_PARENT;
+		init.parent_names = parent_names;
+		init.num_parents = num_parents;
+
+		clk = devm_clk_register(&client->dev, &drvdata->clkout[n].hw);
+		if (IS_ERR(clk)) {
+			dev_err(&client->dev, "unable to register %s\n",
+				init.name);
+			ret = PTR_ERR(clk);
+			goto err_clk;
+		}
+		/* refer to output clock in onecell */
+		drvdata->onecell.clks[n] = clk;
+
+		/* set initial clkout rate */
+		if (pdata->clkout[n].rate != 0) {
+			int ret;
+
+			ret = clk_set_rate(clk, pdata->clkout[n].rate);
+			if (ret != 0) {
+				dev_err(&client->dev, "Cannot set rate : %d\n",
+					ret);
+			}
+		}
+	}
+
+	ret = of_clk_add_provider(client->dev.of_node, of_clk_src_onecell_get,
+				  &drvdata->onecell);
+	if (ret) {
+		dev_err(&client->dev, "unable to add clk provider\n");
+		goto err_clk;
+	}
+
+	dev_info(&client->dev, "%s probe successful\n",
+		 si53xx_variant_name[variant]);
+	instance++;
+	return 0;
+
+err_clk:
+	if (!IS_ERR(drvdata->pxtal))
+		clk_disable_unprepare(drvdata->pxtal);
+	if (!IS_ERR(drvdata->pclkin1))
+		clk_disable_unprepare(drvdata->pclkin1);
+	if (!IS_ERR(drvdata->pclkin2))
+		clk_disable_unprepare(drvdata->pclkin2);
+
+	return ret;
+}
+
+static int si5324_i2c_remove(struct i2c_client *client)
+{
+	of_clk_del_provider(client->dev.of_node);
+	return 0;
+}
+
+static const struct i2c_device_id si5324_i2c_ids[] = {
+	{ "si5319", si5319 },
+	{ "si5324", si5324 },
+	{ "si5328", si5328 },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, si5324_i2c_ids);
+
+static struct i2c_driver si5324_driver = {
+	.driver = {
+		.name = "si5324",
+		.of_match_table = of_match_ptr(si5324_dt_ids),
+	},
+	.probe = si5324_i2c_probe,
+	.remove = si5324_i2c_remove,
+	.id_table = si5324_i2c_ids,
+};
+module_i2c_driver(si5324_driver);
+
+MODULE_AUTHOR("Venkateshwar Rao G <vgannava@xilinx.com>");
+MODULE_DESCRIPTION("Silicon Labs 5319/5324/5328 clock driver");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/clk/clk-si5324.h b/drivers/clk/clk-si5324.h
new file mode 100644
index 000000000..48e62a67f
--- /dev/null
+++ b/drivers/clk/clk-si5324.h
@@ -0,0 +1,140 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Si5324 clock driver
+ *
+ * Copyright (C) 2017-2018 Xilinx, Inc.
+ *
+ * Authors:	Leon Woestenberg <leon@sidebranch.com>
+ *		Venkateshwar Rao <vgannava@xilinx.com>
+ */
+
+#ifndef _CLK_SI5324_H_
+#define _CLK_SI5324_H_
+
+#define SI5324_BUS_BASE_ADDR		0x68
+
+#define SI5324_CONTROL			0
+#define SI5324_CONTROL_FREE_RUN		BIT(6)
+#define SI5324_FREE_RUN_EN		0x54
+
+#define SI5324_INCK_PRIOR		1
+#define SI5324_INCK_PRIOR_1_MASK	0xC
+#define SI5324_INCK_PRIOI_2_MASK	0x3
+
+#define SI5324_BWSEL			2
+#define SI5324_BWSEL_MASK		0xF0
+#define SI5324_BWSEL_SHIFT		4
+#define SI5324_BWSEL_DEF_VAL		2
+
+#define SI5324_CKSEL			3
+#define SI5324_CKSEL_SQL_ICAL		BIT(4)
+#define SI5324_CKSEL_SHIFT		6
+#define SI5324_CK_SEL			3
+
+#define SI3324_AUTOSEL			4
+#define SI5324_AUTOSEL_DEF		0x12
+
+#define SI5324_ICMOS			5
+#define SI5324_OUTPUT_SIGFMT		6
+#define SI5324_OUTPUT_SF1_DEFAULT	0xF
+#define SI5324_REFFRE_FOS		7
+#define SI5324_HLOG			8
+#define SI5324_AVG_HIST			9
+#define SI5324_DSBL_CLKOUT		10
+#define SI5324_DSBL_CLKOUT2		BIT(3)
+#define SI5324_POWERDOWN		11
+#define SI5324_PD_CK1			BIT(0)
+#define SI5324_PD_CK2			BIT(1)
+#define SI5324_PD_CK1_DIS		0x41
+#define SI5324_PD_CK2_DIS		0x42
+#define SI5324_FOS_LOCKT		19
+#define SI5324_FOS_DEFAULT		0x23
+#define SI5324_CK_ACTV_SEL		21
+#define SI5324_CK_DEFAULT		0xFC
+#define SI5324_CK_ACTV			BIT(1)
+#define SI5324_CK_SELPIN		BIT(1)
+#define SI5324_LOS_MSK			23
+#define SI5324_FOS_L0L_MASK		24
+
+/* output clock dividers */
+#define SI5324_N1_HS			25
+#define SI5324_N1_HS_VAL_SHIFT		5
+#define SI5324_HSHIFT			16
+#define SI5324_LSHIFT			8
+#define SI5324_NC1_LS_H			31
+#define SI5324_NC1_LS_M			32
+#define SI5324_NC1_LS_L			33
+#define SI5324_DIV_LS_MASK		0x0F
+#define SI5324_DIV_HS_MASK		0xF0
+#define SI5324_NC2_LS_H			34
+#define SI5324_NC2_LS_M			35
+#define SI5324_NC2_LS_L			36
+
+#define SI5324_N2_HS_LS_H		40
+#define SI5324_N2_HS_LS_H_VAL_SHIFT	5
+#define SI5324_N2_LS_H			41
+#define SI5324_N2_LS_L			42
+#define SI5324_N31_CLKIN_H		43
+#define SI5324_N31_CLKIN_M		44
+#define SI5324_N31_CLKIN_L		45
+#define SI5324_N32_CLKIN_H		46
+#define SI5324_N32_CLKIN_M		47
+#define SI5324_N32_CLKIN_L		48
+#define SI5324_FOS_CLKIN_RATE		55
+#define SI5324_PLL_ACTV_CLK		128
+#define SI5324_LOS_STATUS		129
+#define SI5324_CLKIN_LOL_STATUS		130
+#define SI5324_LOS_FLG			131
+#define SI5324_FOS_FLG			132
+#define SI5324_PARTNO_H			134
+#define SI5324_PARTNO_L			135
+
+#define SI5324_RESET_CALIB		136
+#define SI5324_RST_ALL			BIT(7)
+#define SI5324_CALIB_EN			BIT(6)
+
+#define SI5324_FASTLOCK			137
+#define SI5324_FASTLOCK_EN		BIT(0)
+#define SI5324_LOS1_LOS2_EN		138
+#define SI5324_SKEW1			142
+#define SI5324_SKEW2			143
+
+/* selects 2kHz to 710 MHz */
+#define SI5324_CLKIN_MIN_FREQ		2000
+#define SI5324_CLKIN_MAX_FREQ		(710 * 1000 * 1000)
+
+/* generates 2kHz to 945 MHz */
+#define SI5324_CLKOUT_MIN_FREQ		2000
+#define SI5324_CLKOUT_MAX_FREQ		(945 * 1000 * 1000)
+
+/* The following constants define the limits of the divider settings. */
+#define SI5324_N1_HS_MIN		6
+#define SI5324_N1_HS_MAX		11
+#define SI5324_NC_LS_MIN		1
+#define SI5324_NC_LS_MAX		0x100000
+#define SI5324_N2_HS_MIN		4
+#define SI5324_N2_HS_MAX		11
+#define SI5324_N2_LS_MIN		2
+#define SI5324_N2_LS_MAX		0x100000
+#define SI5324_N3_MIN			1
+#define SI5324_N3_MAX			0x080000
+
+#define SI5324_SRC_XTAL			0
+#define SI5324_SRC_CLKIN1		1
+#define SI5324_SRC_CLKIN2		2
+#define SI5324_SRC_CLKS			3
+
+#define SI5324_CLKIN1			0
+#define SI5324_CLKIN2			1
+#define SI5324_MAX_CLKOUTS		2
+#define NUM_NAME_IDS			6 /* 3 clkin, 1 pll, 2 clkout */
+#define MAX_NAME_LEN			11
+#define SI5324_PARAM_LEN		24
+#define SI5324_NC_PARAM_LEN		6
+#define SI5324_OUT_REGS			14
+#define SI5324_N1_PARAM_LEN		1
+#define SI5324_N2_PARAM_LEN		9
+#define SI5324_REF_CLOCK		114285000UL
+#define SI5324_RESET_DELAY_MS		20
+
+#endif
diff --git a/drivers/clk/clk-si570.c b/drivers/clk/clk-si570.c
index 34b25609f..eea501217 100644
--- a/drivers/clk/clk-si570.c
+++ b/drivers/clk/clk-si570.c
@@ -4,7 +4,7 @@
  *
  * Copyright (C) 2010, 2011 Ericsson AB.
  * Copyright (C) 2011 Guenter Roeck.
- * Copyright (C) 2011 - 2013 Xilinx Inc.
+ * Copyright (C) 2011 - 2021 Xilinx Inc.
  *
  * Author: Guenter Roeck <guenter.roeck@ericsson.com>
  *	   Sören Brinkmann <soren.brinkmann@xilinx.com>
@@ -123,14 +123,18 @@ static int si570_get_divs(struct clk_si570 *data, u64 *rfreq,
  * si570_get_defaults() - Get default values
  * @data:	Driver data structure
  * @fout:	Factory frequency output
+ * @skip_recall:	If true, don't recall NVM into RAM
  * Returns 0 on success, negative errno otherwise.
  */
-static int si570_get_defaults(struct clk_si570 *data, u64 fout)
+static int si570_get_defaults(struct clk_si570 *data, u64 fout,
+			      bool skip_recall)
 {
 	int err;
 	u64 fdco;
 
-	regmap_write(data->regmap, SI570_REG_CONTROL, SI570_CNTRL_RECALL);
+	if (!skip_recall)
+		regmap_write(data->regmap, SI570_REG_CONTROL,
+			     SI570_CNTRL_RECALL);
 
 	err = si570_get_divs(data, &data->rfreq, &data->n1, &data->hs_div);
 	if (err)
@@ -400,6 +404,7 @@ static int si570_probe(struct i2c_client *client,
 	struct clk_si570 *data;
 	struct clk_init_data init;
 	u32 initial_fout, factory_fout, stability;
+	bool skip_recall;
 	int err;
 	enum clk_si570_variant variant = id->driver_data;
 
@@ -441,6 +446,9 @@ static int si570_probe(struct i2c_client *client,
 		return err;
 	}
 
+	skip_recall = of_property_read_bool(client->dev.of_node,
+					    "silabs,skip-recall");
+
 	data->regmap = devm_regmap_init_i2c(client, &si570_regmap_config);
 	if (IS_ERR(data->regmap)) {
 		dev_err(&client->dev, "failed to allocate register map\n");
@@ -448,7 +456,7 @@ static int si570_probe(struct i2c_client *client,
 	}
 
 	i2c_set_clientdata(client, data);
-	err = si570_get_defaults(data, factory_fout);
+	err = si570_get_defaults(data, factory_fout, skip_recall);
 	if (err)
 		return err;
 
diff --git a/drivers/clk/clk-xlnx-clock-wizard-v.c b/drivers/clk/clk-xlnx-clock-wizard-v.c
new file mode 100644
index 000000000..d14f70e09
--- /dev/null
+++ b/drivers/clk/clk-xlnx-clock-wizard-v.c
@@ -0,0 +1,765 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Xilinx 'Clocking Wizard' driver
+ *
+ *  Copyright (C) 2020 Xilinx
+ *
+ *  Shubhrajyoti Datta <shubhrajyoti.datta@xilinx.com>
+ */
+
+#include <linux/platform_device.h>
+#include <linux/clk.h>
+#include <linux/clk-provider.h>
+#include <linux/slab.h>
+#include <linux/io.h>
+#include <linux/of.h>
+#include <linux/module.h>
+#include <linux/err.h>
+#include <linux/iopoll.h>
+
+#define WZRD_NUM_OUTPUTS	7
+#define WZRD_ACLK_MAX_FREQ	250000000UL
+
+#define WZRD_CLK_CFG_REG(n)	(0x330 + 4 * (n))
+
+#define WZRD_CLKFBOUT_1		0
+#define WZRD_CLKFBOUT_2		1
+#define WZRD_CLKOUT0_1		2
+#define WZRD_CLKOUT0_2		3
+#define WZRD_DESKEW_2		20
+#define WZRD_DIVCLK		21
+#define WZRD_CLKFBOUT_4		51
+#define WZRD_CLKFBOUT_3		48
+#define WZRD_DUTY_CYCLE		2
+#define WZRD_O_DIV		4
+
+#define WZRD_CLKFBOUT_FRAC_EN	BIT(1)
+#define WZRD_CLKFBOUT_PREDIV2	(BIT(11) | BIT(12) | BIT(9))
+#define WZRD_MULT_PREDIV2	(BIT(10) | BIT(9) | BIT(12))
+#define WZRD_CLKFBOUT_EDGE	BIT(8)
+#define WZRD_P5EN		BIT(13)
+#define WZRD_P5FEDGE		BIT(15)
+#define WZRD_DIVCLK_EDGE	BIT(10)
+#define WZRD_CLKOUT0_PREDIV2	BIT(11)
+
+#define WZRD_CLKFBOUT_L_SHIFT	0
+#define WZRD_CLKFBOUT_H_SHIFT	8
+#define WZRD_CLKFBOUT_L_MASK	GENMASK(7, 0)
+#define WZRD_CLKFBOUT_H_MASK	GENMASK(15, 8)
+#define WZRD_CLKFBOUT_FRAC_SHIFT	16
+#define WZRD_CLKFBOUT_FRAC_MASK		GENMASK(5, 0)
+#define WZRD_DIVCLK_DIVIDE_SHIFT	0
+#define WZRD_DIVCLK_DIVIDE_MASK		(0xff << WZRD_DIVCLK_DIVIDE_SHIFT)
+#define WZRD_CLKOUT_DIVIDE_SHIFT	0
+#define WZRD_CLKOUT_DIVIDE_WIDTH	8
+#define WZRD_CLKOUT_DIVIDE_MASK		(0xff << WZRD_DIVCLK_DIVIDE_SHIFT)
+#define WZRD_CLKOUT_FRAC_SHIFT		8
+#define WZRD_CLKOUT_FRAC_MASK		0x3ff
+
+#define WZRD_DR_MAX_INT_DIV_VALUE	32767
+#define WZRD_DR_STATUS_REG_OFFSET	0x04
+#define WZRD_DR_LOCK_BIT_MASK		0x00000001
+#define WZRD_DR_INIT_REG_OFFSET		0x14
+#define WZRD_DR_DIV_TO_PHASE_OFFSET	4
+#define WZRD_DR_BEGIN_DYNA_RECONF	0x03
+#define WZRD_MIN_ERR			500000
+#define WZRD_USEC_POLL			10
+#define WZRD_TIMEOUT_POLL		1000
+#define WZRD_FRAC_GRADIENT		64
+#define PREDIV2_MULT			2
+
+#define DIV_O				1
+#define DIV_ALL				3
+
+#define WZRD_M_MIN			4
+#define WZRD_M_MAX			432
+#define WZRD_D_MIN			1
+#define WZRD_D_MAX			123
+#define WZRD_VCO_MIN			2160000000
+#define WZRD_VCO_MAX			4320000000
+#define WZRD_O_MIN			2
+#define WZRD_O_MAX			511
+
+/* Get the mask from width */
+#define div_mask(width)			((1 << (width)) - 1)
+
+/* Extract divider instance from clock hardware instance */
+#define to_clk_wzrd_divider(_hw) container_of(_hw, struct clk_wzrd_divider, hw)
+
+enum clk_wzrd_int_clks {
+	wzrd_clk_mul,
+	wzrd_clk_mul_div,
+	wzrd_clk_mul_frac,
+	wzrd_clk_int_max
+};
+
+/**
+ * struct clk_wzrd - Clock wizard private data structure
+ *
+ * @clk_data:		Clock data
+ * @nb:			Notifier block
+ * @base:		Memory base
+ * @clk_in1:		Handle to input clock 'clk_in1'
+ * @axi_clk:		Handle to input clock 's_axi_aclk'
+ * @clks_internal:	Internal clocks
+ * @clkout:		Output clocks
+ * @suspended:		Flag indicating power state of the device
+ * @is_versal:		Flag indicating if it versal device
+ */
+struct clk_wzrd {
+	struct clk_onecell_data clk_data;
+	struct notifier_block nb;
+	void __iomem *base;
+	struct clk *clk_in1;
+	struct clk *axi_clk;
+	struct clk *clks_internal[wzrd_clk_int_max];
+	struct clk *clkout[WZRD_NUM_OUTPUTS];
+	bool suspended;
+	bool is_versal;
+};
+
+/**
+ * struct clk_wzrd_divider - clock divider specific to clk_wzrd
+ *
+ * @hw:		handle between common and hardware-specific interfaces
+ * @base:	base address of register containing the divider
+ * @offset:	offset address of register containing the divider
+ * @shift:	shift to the divider bit field
+ * @width:	width of the divider bit field
+ * @flags:	clk_wzrd divider flags
+ * @valuem:	value of the multiplier
+ * @valued:	value of the common divider
+ * @valueo:	value of the leaf divider
+ * @table:	array of value/divider pairs, last entry should have div = 0
+ * @lock:	register lock
+ */
+struct clk_wzrd_divider {
+	struct clk_hw hw;
+	void __iomem *base;
+	u16 offset;
+	u8 shift;
+	u8 width;
+	u8 flags;
+	u32 valuem;
+	u32 valued;
+	u32 valueo;
+	const struct clk_div_table *table;
+	spinlock_t *lock;  /* divider lock */
+};
+
+#define to_clk_wzrd(_nb) container_of(_nb, struct clk_wzrd, nb)
+
+/* spin lock variable for clk_wzrd */
+static DEFINE_SPINLOCK(clkwzrd_lock);
+
+static unsigned long clk_wzrd_recalc_rate_all(struct clk_hw *hw,
+					      unsigned long parent_rate)
+{
+	struct clk_wzrd_divider *divider = to_clk_wzrd_divider(hw);
+	u32 edged, div, div2, p5en, edge, prediv2, all, regl, regh, mult, reg;
+
+	edge = !!(readl(divider->base + WZRD_CLK_CFG_REG(WZRD_CLKFBOUT_1)) & WZRD_CLKFBOUT_EDGE);
+
+	reg = readl(divider->base + WZRD_CLK_CFG_REG(WZRD_CLKFBOUT_2));
+	regl = FIELD_GET(WZRD_CLKFBOUT_L_MASK, reg);
+	regh = FIELD_GET(WZRD_CLKFBOUT_H_MASK, reg);
+
+	mult = regl + regh + edge;
+	if (!mult)
+		mult = 1;
+
+	regl = readl(divider->base + WZRD_CLK_CFG_REG(WZRD_CLKFBOUT_4)) &
+		     WZRD_CLKFBOUT_FRAC_EN;
+	if (regl) {
+		regl = readl(divider->base + WZRD_CLK_CFG_REG(WZRD_CLKFBOUT_3)) &
+			WZRD_CLKFBOUT_FRAC_MASK;
+		mult = mult * WZRD_FRAC_GRADIENT + regl;
+		parent_rate = DIV_ROUND_CLOSEST((parent_rate * mult), WZRD_FRAC_GRADIENT);
+	} else {
+		parent_rate = parent_rate * mult;
+	}
+
+	/* O Calculation */
+	reg = readl(divider->base + WZRD_CLK_CFG_REG(WZRD_CLKOUT0_1));
+	edged = FIELD_GET(WZRD_CLKFBOUT_EDGE, reg);
+	p5en = FIELD_GET(WZRD_P5EN, reg);
+	prediv2 = FIELD_GET(WZRD_CLKOUT0_PREDIV2, reg);
+
+	reg = readl(divider->base + WZRD_CLK_CFG_REG(WZRD_CLKOUT0_2));
+	/* Low time */
+	regl = FIELD_GET(WZRD_CLKFBOUT_L_MASK, reg);
+	/* High time */
+	regh = FIELD_GET(WZRD_CLKFBOUT_H_MASK, reg);
+	all = regh + regl + edged;
+	if (!all)
+		all = 1;
+
+	if (prediv2)
+		div2 = PREDIV2_MULT * all + p5en;
+	else
+		div2 = all;
+
+	/* D calculation */
+	edged = !!(readl(divider->base + WZRD_CLK_CFG_REG(WZRD_DESKEW_2)) &
+		     WZRD_DIVCLK_EDGE);
+	reg = readl(divider->base + WZRD_CLK_CFG_REG(WZRD_DIVCLK));
+	/* Low time */
+	regl = FIELD_GET(WZRD_CLKFBOUT_L_MASK, reg);
+	/* High time */
+	regh = FIELD_GET(WZRD_CLKFBOUT_H_MASK, reg);
+	div = regl + regh + edged;
+	if (!div)
+		div = 1;
+
+	div = div * div2;
+	return divider_recalc_rate(hw, parent_rate, div, divider->table,
+			divider->flags, divider->width);
+}
+
+static int clk_wzrd_get_divisors(struct clk_hw *hw, unsigned long rate,
+				 unsigned long parent_rate)
+{
+	struct clk_wzrd_divider *divider = to_clk_wzrd_divider(hw);
+	u64 vco_freq, freq, diff;
+	u32 m, d, o;
+
+	for (m = WZRD_M_MIN; m <= WZRD_M_MAX; m++) {
+		for (d = WZRD_D_MIN; d <= WZRD_D_MAX; d++) {
+			vco_freq = DIV_ROUND_CLOSEST((parent_rate * m), d);
+			if (vco_freq >= WZRD_VCO_MIN && vco_freq <= WZRD_VCO_MAX) {
+				for (o = WZRD_O_MIN; o <= WZRD_O_MAX; o++) {
+					freq = DIV_ROUND_CLOSEST(vco_freq, o);
+					diff = abs(freq - rate);
+
+					if (diff < WZRD_MIN_ERR) {
+						divider->valuem = m;
+						divider->valued = d;
+						divider->valueo = o;
+						return 0;
+					}
+				}
+			}
+		}
+	}
+	return -EBUSY;
+}
+
+static int clk_wzrd_dynamic_all_nolock(struct clk_hw *hw, unsigned long rate,
+				       unsigned long parent_rate)
+{
+	struct clk_wzrd_divider *divider = to_clk_wzrd_divider(hw);
+	u32 value, regh, edged, p5en, p5fedge, value2, m, regval, regval1;
+	int err;
+
+	err = clk_wzrd_get_divisors(hw, rate, parent_rate);
+	if (err)
+		return err;
+
+	writel(0, divider->base + WZRD_CLK_CFG_REG(WZRD_CLKFBOUT_4));
+
+	m = divider->valuem;
+	edged = m % WZRD_DUTY_CYCLE;
+	regh = m / WZRD_DUTY_CYCLE;
+	regval1 = readl(divider->base + WZRD_CLK_CFG_REG(WZRD_CLKFBOUT_1));
+	regval1 |= WZRD_MULT_PREDIV2;
+	if (edged)
+		regval1 = regval1 | WZRD_CLKFBOUT_EDGE;
+	else
+		regval1 = regval1 & ~WZRD_CLKFBOUT_EDGE;
+	writel(regval1, divider->base + WZRD_CLK_CFG_REG(WZRD_CLKFBOUT_1));
+	regval1 = regh | regh << WZRD_CLKFBOUT_H_SHIFT;
+	writel(regval1, divider->base + WZRD_CLK_CFG_REG(WZRD_CLKFBOUT_2));
+
+	value2 = divider->valued;
+	edged = value2 % WZRD_DUTY_CYCLE;
+	regh = (value2 / WZRD_DUTY_CYCLE);
+	regval1 = FIELD_PREP(WZRD_DIVCLK_EDGE, edged);
+	writel(regval1, divider->base + WZRD_CLK_CFG_REG(WZRD_DESKEW_2));
+	regval1 = regh | regh << WZRD_CLKFBOUT_H_SHIFT;
+	writel(regval1, divider->base + WZRD_CLK_CFG_REG(WZRD_DIVCLK));
+
+	value = divider->valueo;
+	regh = value / WZRD_O_DIV;
+	regval1 = readl(divider->base + WZRD_CLK_CFG_REG(WZRD_CLKOUT0_1));
+	regval1 |= WZRD_CLKFBOUT_PREDIV2;
+	regval1 = regval1 & ~(WZRD_CLKFBOUT_EDGE | WZRD_P5EN | WZRD_P5FEDGE);
+	if (value % WZRD_O_DIV > 1) {
+		edged = 1;
+		regval1 |= edged << WZRD_CLKFBOUT_H_SHIFT;
+	}
+	p5fedge = value % WZRD_DUTY_CYCLE;
+	p5en = value % WZRD_DUTY_CYCLE;
+
+	regval1 = regval1 | FIELD_PREP(WZRD_P5EN, p5en) | FIELD_PREP(WZRD_P5FEDGE, p5fedge);
+	writel(regval1, divider->base + WZRD_CLK_CFG_REG(WZRD_CLKOUT0_1));
+	regval = regh | regh << WZRD_CLKFBOUT_H_SHIFT;
+	writel(regval, divider->base + WZRD_CLK_CFG_REG(WZRD_CLKOUT0_2));
+
+	/* Check status register */
+	err = readl_poll_timeout(divider->base + WZRD_DR_STATUS_REG_OFFSET,
+				 value, value & WZRD_DR_LOCK_BIT_MASK,
+				 WZRD_USEC_POLL, WZRD_TIMEOUT_POLL);
+	if (err)
+		return err;
+
+	/* Initiate reconfiguration */
+	writel(WZRD_DR_BEGIN_DYNA_RECONF,
+	       divider->base + WZRD_DR_INIT_REG_OFFSET);
+
+	/* Check status register */
+	return  readl_poll_timeout(divider->base + WZRD_DR_STATUS_REG_OFFSET,
+				 value, value & WZRD_DR_LOCK_BIT_MASK,
+				 WZRD_USEC_POLL, WZRD_TIMEOUT_POLL);
+}
+
+static int clk_wzrd_dynamic_all(struct clk_hw *hw, unsigned long rate,
+				unsigned long parent_rate)
+{
+	struct clk_wzrd_divider *divider = to_clk_wzrd_divider(hw);
+	unsigned long flags = 0;
+	int ret;
+
+	if (divider->lock)
+		spin_lock_irqsave(divider->lock, flags);
+	else
+		__acquire(divider->lock);
+
+	ret = clk_wzrd_dynamic_all_nolock(hw, rate, parent_rate);
+
+	if (divider->lock)
+		spin_unlock_irqrestore(divider->lock, flags);
+	else
+		__release(divider->lock);
+
+	return ret;
+}
+
+static unsigned long clk_wzrd_recalc_rate(struct clk_hw *hw,
+					  unsigned long parent_rate)
+{
+	struct clk_wzrd_divider *divider = to_clk_wzrd_divider(hw);
+	void __iomem *div_addr =
+			(void __iomem *)((u64)divider->base + divider->offset);
+	unsigned int vall, valh;
+	u32 div;
+	u32 p5en, edge, prediv2;
+	u32 all;
+
+	edge = !!(readl(div_addr) & BIT(8));
+	p5en = !!(readl(div_addr) & BIT(13));
+	prediv2 = !!(readl(div_addr) & BIT(11));
+	vall = readl(div_addr + 4) & 0xff;
+	valh = readl(div_addr + 4) >> 8;
+	all = valh + vall + edge;
+	if (!all)
+		all = 1;
+	if (prediv2)
+		div =  (2 * all + prediv2 * p5en);
+	else
+		div = all;
+
+	return DIV_ROUND_UP_ULL((u64)parent_rate, div);
+}
+
+static int clk_wzrd_dynamic_reconfig(struct clk_hw *hw, unsigned long rate,
+				     unsigned long parent_rate)
+{
+	int err;
+	u32 value;
+	unsigned long flags = 0;
+	u32 regh, edged;
+	u32 p5en, p5fedge;
+	u32 regval, regval1;
+	struct clk_wzrd_divider *divider = to_clk_wzrd_divider(hw);
+	void __iomem *div_addr =
+			(void __iomem *)((u64)divider->base + divider->offset);
+	if (divider->lock)
+		spin_lock_irqsave(divider->lock, flags);
+	else
+		__acquire(divider->lock);
+
+	value = DIV_ROUND_CLOSEST(parent_rate, rate);
+	regh = (value / 4);
+	regval = regh | (regh << 8);
+	regval1 = readl(div_addr);
+	regval1 |= WZRD_CLKFBOUT_PREDIV2;
+	regval1 = regval1 &  ~(BIT(8) | BIT(13) | BIT(15));
+	if (value % 4 > 1) {
+		edged = 1;
+		regval1 |= (edged << 8);
+	}
+	p5fedge = value % 2;
+	p5en = value % 2;
+	regval1 = regval1 | p5en << 13 | p5fedge << 15;
+	writel(regval1, div_addr);
+	regval = regh | regh << 8;
+	writel(regval, div_addr + 4);
+	/* Check status register */
+	err = readl_poll_timeout(divider->base + WZRD_DR_STATUS_REG_OFFSET,
+				 value, value & WZRD_DR_LOCK_BIT_MASK,
+				 WZRD_USEC_POLL, WZRD_TIMEOUT_POLL);
+	if (err)
+		goto err_reconfig;
+
+	/* Initiate reconfiguration */
+	writel(WZRD_DR_BEGIN_DYNA_RECONF,
+	       divider->base + WZRD_DR_INIT_REG_OFFSET);
+
+	/* Check status register */
+	err = readl_poll_timeout(divider->base + WZRD_DR_STATUS_REG_OFFSET,
+				 value, value & WZRD_DR_LOCK_BIT_MASK,
+				 WZRD_USEC_POLL, WZRD_TIMEOUT_POLL);
+
+err_reconfig:
+	if (divider->lock)
+		spin_unlock_irqrestore(divider->lock, flags);
+	else
+		__release(divider->lock);
+
+	return err;
+}
+
+static long clk_wzrd_round_rate_all(struct clk_hw *hw, unsigned long rate,
+				    unsigned long *prate)
+{
+	return rate;
+}
+
+static long clk_wzrd_round_rate(struct clk_hw *hw, unsigned long rate,
+				unsigned long *prate)
+{
+	u8 div;
+
+	/*
+	 * since we donot change parent rate we just round rate to closest
+	 * achievable
+	 */
+	div = DIV_ROUND_CLOSEST(*prate, rate);
+
+	return (*prate / div);
+}
+
+static const struct clk_ops clk_wzrd_clk_divider_ops = {
+	.round_rate = clk_wzrd_round_rate,
+	.set_rate = clk_wzrd_dynamic_reconfig,
+	.recalc_rate = clk_wzrd_recalc_rate,
+};
+
+static const struct clk_ops clk_wzrd_clk_div_all_ops = {
+	.round_rate = clk_wzrd_round_rate_all,
+	.set_rate = clk_wzrd_dynamic_all,
+	.recalc_rate = clk_wzrd_recalc_rate_all,
+};
+
+static struct clk *clk_wzrd_register_divider(struct device *dev,
+					     const char *name,
+					     const char *parent_name,
+					     unsigned long flags,
+					     void __iomem *base, u16 offset,
+					     u8 shift, u8 width,
+					     u8 clk_divider_flags,
+					     u32 div_type,
+					     spinlock_t *lock)
+{
+	struct clk_wzrd_divider *div;
+	struct clk_hw *hw;
+	struct clk_init_data init;
+	int ret;
+
+	if (clk_divider_flags & CLK_DIVIDER_HIWORD_MASK) {
+		if (width + shift > 16) {
+			pr_warn("divider value exceeds LOWORD field\n");
+			return ERR_PTR(-EINVAL);
+		}
+	}
+
+	/* allocate the divider */
+	div = kzalloc(sizeof(*div), GFP_KERNEL);
+	if (!div)
+		return ERR_PTR(-ENOMEM);
+
+	init.name = name;
+	if (clk_divider_flags & CLK_DIVIDER_READ_ONLY)
+		init.ops = &clk_divider_ro_ops;
+	else if (div_type == DIV_O)
+		init.ops = &clk_wzrd_clk_divider_ops;
+	else
+		init.ops = &clk_wzrd_clk_div_all_ops;
+
+	init.flags = flags;
+	init.parent_names = (parent_name ? &parent_name : NULL);
+	init.num_parents = (parent_name ? 1 : 0);
+
+	/* struct clk_divider assignments */
+	div->base = base;
+	div->offset = offset;
+	div->shift = shift;
+	div->width = width;
+	div->flags = clk_divider_flags;
+	div->lock = lock;
+	div->hw.init = &init;
+	div->table = NULL;
+
+	/* register the clock */
+	hw = &div->hw;
+	ret = clk_hw_register(dev, hw);
+	if (ret) {
+		kfree(div);
+		hw = ERR_PTR(ret);
+	}
+
+	return hw->clk;
+}
+
+static int __maybe_unused clk_wzrd_suspend(struct device *dev)
+{
+	struct clk_wzrd *clk_wzrd = dev_get_drvdata(dev);
+
+	clk_disable_unprepare(clk_wzrd->axi_clk);
+	clk_wzrd->suspended = true;
+
+	return 0;
+}
+
+static int __maybe_unused clk_wzrd_resume(struct device *dev)
+{
+	int ret;
+	struct clk_wzrd *clk_wzrd = dev_get_drvdata(dev);
+
+	ret = clk_prepare_enable(clk_wzrd->axi_clk);
+	if (ret) {
+		dev_err(dev, "unable to enable s_axi_aclk\n");
+		return ret;
+	}
+
+	clk_wzrd->suspended = false;
+
+	return 0;
+}
+
+static SIMPLE_DEV_PM_OPS(clk_wzrd_dev_pm_ops, clk_wzrd_suspend,
+			 clk_wzrd_resume);
+
+static int clk_wzrd_probe(struct platform_device *pdev)
+{
+	int i, ret;
+	u32 regl, regh, edge, mult;
+	u32 regld, reghd, edged, div;
+	unsigned long rate;
+	const char *clk_name;
+	struct clk_wzrd *clk_wzrd;
+	struct resource *mem;
+	int outputs;
+	struct device_node *np = pdev->dev.of_node;
+
+	clk_wzrd = devm_kzalloc(&pdev->dev, sizeof(*clk_wzrd), GFP_KERNEL);
+	if (!clk_wzrd)
+		return -ENOMEM;
+	platform_set_drvdata(pdev, clk_wzrd);
+
+	mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	clk_wzrd->base = devm_ioremap_resource(&pdev->dev, mem);
+	if (IS_ERR(clk_wzrd->base))
+		return PTR_ERR(clk_wzrd->base);
+
+	clk_wzrd->clk_in1 = devm_clk_get(&pdev->dev, "clk_in1");
+	if (IS_ERR(clk_wzrd->clk_in1)) {
+		if (clk_wzrd->clk_in1 != ERR_PTR(-EPROBE_DEFER))
+			dev_err(&pdev->dev, "clk_in1 not found\n");
+		return PTR_ERR(clk_wzrd->clk_in1);
+	}
+
+	clk_wzrd->axi_clk = devm_clk_get(&pdev->dev, "s_axi_aclk");
+	if (IS_ERR(clk_wzrd->axi_clk)) {
+		if (clk_wzrd->axi_clk != ERR_PTR(-EPROBE_DEFER))
+			dev_err(&pdev->dev, "s_axi_aclk not found\n");
+		return PTR_ERR(clk_wzrd->axi_clk);
+	}
+	ret = clk_prepare_enable(clk_wzrd->axi_clk);
+	if (ret) {
+		dev_err(&pdev->dev, "enabling s_axi_aclk failed\n");
+		return ret;
+	}
+	rate = clk_get_rate(clk_wzrd->axi_clk);
+	if (rate > WZRD_ACLK_MAX_FREQ) {
+		dev_err(&pdev->dev, "s_axi_aclk frequency (%lu) too high\n",
+			rate);
+		ret = -EINVAL;
+		goto err_disable_clk;
+	}
+
+	outputs = of_property_count_strings(np, "clock-output-names");
+	clk_name = kasprintf(GFP_KERNEL, "%s_mul_div", dev_name(&pdev->dev));
+	if (!clk_name) {
+		ret = -ENOMEM;
+		goto err_rm_int_clk;
+	}
+
+	if (outputs == 1) {
+		const char *clkout_name;
+
+		if (of_property_read_string_index(np, "clock-output-names", i,
+						  &clkout_name)) {
+			dev_err(&pdev->dev,
+				"clock output name not specified\n");
+			ret = -EINVAL;
+			goto err_rm_int_clks;
+		}
+
+		clk_wzrd->clkout[0] = clk_wzrd_register_divider
+				(&pdev->dev, clkout_name,
+				__clk_get_name(clk_wzrd->clk_in1), 0,
+				clk_wzrd->base, WZRD_CLK_CFG_REG(3),
+				WZRD_CLKOUT_DIVIDE_SHIFT,
+				WZRD_CLKOUT_DIVIDE_WIDTH,
+				CLK_DIVIDER_ONE_BASED | CLK_DIVIDER_ALLOW_ZERO,
+				DIV_ALL, &clkwzrd_lock);
+
+		goto out;
+	}
+
+	/* register multiplier */
+	edge = !!(readl(clk_wzrd->base + WZRD_CLK_CFG_REG(0)) & BIT(8));
+	regl = (readl(clk_wzrd->base + WZRD_CLK_CFG_REG(1)) &
+		     WZRD_CLKFBOUT_L_MASK) >> WZRD_CLKFBOUT_L_SHIFT;
+	regh = (readl(clk_wzrd->base + WZRD_CLK_CFG_REG(1)) &
+		     WZRD_CLKFBOUT_H_MASK) >> WZRD_CLKFBOUT_H_SHIFT;
+	mult = (regl  + regh + edge);
+	if (!mult)
+		mult = 1;
+	mult = mult * 64;
+
+	regl = readl(clk_wzrd->base + WZRD_CLK_CFG_REG(51)) &
+		     WZRD_CLKFBOUT_FRAC_EN;
+	if (regl) {
+		regl = readl(clk_wzrd->base + WZRD_CLK_CFG_REG(48)) &
+			WZRD_CLKFBOUT_FRAC_MASK;
+		mult = mult + regl;
+	}
+
+	clk_name = kasprintf(GFP_KERNEL, "%s_mul", dev_name(&pdev->dev));
+	if (!clk_name) {
+		ret = -ENOMEM;
+		goto err_disable_clk;
+	}
+	clk_wzrd->clks_internal[wzrd_clk_mul] = clk_register_fixed_factor
+			(&pdev->dev, clk_name,
+			 __clk_get_name(clk_wzrd->clk_in1),
+			0, mult, 64);
+	kfree(clk_name);
+	if (IS_ERR(clk_wzrd->clks_internal[wzrd_clk_mul])) {
+		dev_err(&pdev->dev, "unable to register fixed-factor clock\n");
+		ret = PTR_ERR(clk_wzrd->clks_internal[wzrd_clk_mul]);
+		goto err_disable_clk;
+	}
+
+	/* register div */
+	edged = !!(readl(clk_wzrd->base + WZRD_CLK_CFG_REG(20)) &
+		     BIT(10));
+	regld = (readl(clk_wzrd->base + WZRD_CLK_CFG_REG(21)) &
+		     WZRD_CLKFBOUT_L_MASK) >> WZRD_CLKFBOUT_L_SHIFT;
+	reghd = (readl(clk_wzrd->base + WZRD_CLK_CFG_REG(21)) &
+		     WZRD_CLKFBOUT_H_MASK) >> WZRD_CLKFBOUT_H_SHIFT;
+	div = (regld  + reghd + edged);
+	if (!div)
+		div = 1;
+	clk_wzrd->clks_internal[wzrd_clk_mul_div] = clk_register_fixed_factor
+			(&pdev->dev, clk_name,
+			 __clk_get_name(clk_wzrd->clks_internal[wzrd_clk_mul]),
+			0, 1, div);
+	if (IS_ERR(clk_wzrd->clks_internal[wzrd_clk_mul_div])) {
+		dev_err(&pdev->dev, "unable to register divider clock\n");
+		ret = PTR_ERR(clk_wzrd->clks_internal[wzrd_clk_mul_div]);
+		goto err_rm_int_clk;
+	}
+
+	/* register div per output */
+	for (i = outputs - 1; i >= 0 ; i--) {
+		const char *clkout_name;
+
+		if (of_property_read_string_index(np, "clock-output-names", i,
+						  &clkout_name)) {
+			dev_err(&pdev->dev,
+				"clock output name not specified\n");
+			ret = -EINVAL;
+			goto err_rm_int_clks;
+		}
+
+			clk_wzrd->clkout[i] = clk_wzrd_register_divider
+				(&pdev->dev, clkout_name,
+				clk_name, 0,
+				clk_wzrd->base, (WZRD_CLK_CFG_REG(3) + i * 8),
+				WZRD_CLKOUT_DIVIDE_SHIFT,
+				WZRD_CLKOUT_DIVIDE_WIDTH,
+				CLK_DIVIDER_ONE_BASED | CLK_DIVIDER_ALLOW_ZERO,
+				DIV_O, &clkwzrd_lock);
+
+		if (IS_ERR(clk_wzrd->clkout[i])) {
+			int j;
+
+			for (j = i + 1; j < outputs; j++)
+				clk_unregister(clk_wzrd->clkout[j]);
+			dev_err(&pdev->dev,
+				"unable to register divider clock\n");
+			ret = PTR_ERR(clk_wzrd->clkout[i]);
+			goto err_rm_int_clks;
+		}
+	}
+
+	kfree(clk_name);
+
+out:
+	clk_wzrd->clk_data.clks = clk_wzrd->clkout;
+	clk_wzrd->clk_data.clk_num = ARRAY_SIZE(clk_wzrd->clkout);
+	of_clk_add_provider(np, of_clk_src_onecell_get, &clk_wzrd->clk_data);
+
+	return 0;
+
+err_rm_int_clks:
+	clk_unregister(clk_wzrd->clks_internal[1]);
+err_rm_int_clk:
+	kfree(clk_name);
+	clk_unregister(clk_wzrd->clks_internal[0]);
+err_disable_clk:
+	clk_disable_unprepare(clk_wzrd->axi_clk);
+
+	return ret;
+}
+
+static int clk_wzrd_remove(struct platform_device *pdev)
+{
+	int i;
+	struct clk_wzrd *clk_wzrd = platform_get_drvdata(pdev);
+
+	of_clk_del_provider(pdev->dev.of_node);
+
+	for (i = 0; i < WZRD_NUM_OUTPUTS; i++)
+		clk_unregister(clk_wzrd->clkout[i]);
+	for (i = 0; i < wzrd_clk_int_max; i++)
+		clk_unregister(clk_wzrd->clks_internal[i]);
+
+	clk_disable_unprepare(clk_wzrd->axi_clk);
+
+	return 0;
+}
+
+static const struct of_device_id clk_wzrd_ids[] = {
+	{ .compatible = "xlnx,clk-wizard-1.0" },
+	{ },
+};
+MODULE_DEVICE_TABLE(of, clk_wzrd_ids);
+
+static struct platform_driver clk_wzrd_driver = {
+	.driver = {
+		.name = "clk-wizard",
+		.of_match_table = clk_wzrd_ids,
+		.pm = &clk_wzrd_dev_pm_ops,
+	},
+	.probe = clk_wzrd_probe,
+	.remove = clk_wzrd_remove,
+};
+module_platform_driver(clk_wzrd_driver);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Shubhrajyoti Datta <shubhrajyoti.datta@xilinx.com>");
+MODULE_DESCRIPTION("Driver for the Versal Clocking Wizard IP core");
diff --git a/drivers/clk/clk-xlnx-clock-wizard.c b/drivers/clk/clk-xlnx-clock-wizard.c
new file mode 100644
index 000000000..da585b9e2
--- /dev/null
+++ b/drivers/clk/clk-xlnx-clock-wizard.c
@@ -0,0 +1,936 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Xilinx 'Clocking Wizard' driver
+ *
+ *  Copyright (C) 2013 - 2014 Xilinx
+ *
+ *  Sören Brinkmann <soren.brinkmann@xilinx.com>
+ */
+
+#include <linux/platform_device.h>
+#include <linux/clk.h>
+#include <linux/clk-provider.h>
+#include <linux/slab.h>
+#include <linux/io.h>
+#include <linux/of.h>
+#include <linux/module.h>
+#include <linux/err.h>
+
+#define WZRD_NUM_OUTPUTS	7
+#define WZRD_ACLK_MAX_FREQ	250000000UL
+
+#define WZRD_CLK_CFG_REG(n)	(0x200 + 4 * (n))
+
+#define WZRD_CLKOUT0_FRAC_EN	BIT(18)
+#define WZRD_CLKFBOUT_FRAC_EN	BIT(26)
+
+#define WZRD_CLKFBOUT_MULT_SHIFT	8
+#define WZRD_CLKFBOUT_MULT_MASK		GENMASK(15, 8)
+#define WZRD_CLKFBOUT_FRAC_SHIFT	16
+#define WZRD_CLKFBOUT_FRAC_MASK		(0x3ff << WZRD_CLKFBOUT_FRAC_SHIFT)
+#define WZRD_DIVCLK_DIVIDE_SHIFT	0
+#define WZRD_DIVCLK_DIVIDE_MASK		GENMASK(7, 0)
+#define WZRD_CLKOUT_DIVIDE_SHIFT	0
+#define WZRD_CLKOUT_DIVIDE_WIDTH	8
+#define WZRD_CLKOUT_DIVIDE_MASK		GENMASK(7, 0)
+#define WZRD_CLKOUT_FRAC_SHIFT		8
+#define WZRD_CLKOUT_FRAC_MASK		0x3ff
+#define WZRD_CLKOUT0_FRAC_MASK		GENMASK(17, 8)
+
+#define WZRD_DR_MAX_INT_DIV_VALUE	255
+#define WZRD_DR_NUM_RETRIES		10000
+#define WZRD_DR_STATUS_REG_OFFSET	0x04
+#define WZRD_DR_LOCK_BIT_MASK		0x00000001
+#define WZRD_DR_INIT_REG_OFFSET		0x25C
+#define WZRD_DR_DIV_TO_PHASE_OFFSET	4
+#define WZRD_DR_BEGIN_DYNA_RECONF	0x03
+
+/* Multiplier limits, from UG572 Table 3-4 for Ultrascale+ */
+#define CLKFBOUT_MULT_F_MIN		2000U
+#define CLKFBOUT_MULT_F_MAX		128000U
+
+/* Divider limits, from UG572 Table 3-4 for Ultrascale+ */
+#define DIVCLK_DIVIDE_MIN		1U
+#define DIVCLK_DIVIDE_MAX		106U
+#define DIV_O				0x01
+#define DIV_ALL				0x03
+
+#define WZRD_M_MIN			2
+#define WZRD_M_MAX			128
+#define WZRD_D_MIN			1
+#define WZRD_D_MAX			106
+#define WZRD_VCO_MIN			800000000
+#define WZRD_VCO_MAX			1600000000
+#define WZRD_O_MIN			1
+#define WZRD_O_MAX			128
+#define WZRD_MIN_ERR			20000
+#define WZRD_FRAC_POINTS		1000
+
+/* Get the mask from width */
+#define div_mask(width)			((1 << (width)) - 1)
+
+/* Extract divider instance from clock hardware instance */
+#define to_clk_wzrd_divider(_hw) container_of(_hw, struct clk_wzrd_divider, hw)
+
+enum clk_wzrd_int_clks {
+	wzrd_clk_mul = 0,
+	wzrd_clk_mul_div = 1,
+	wzrd_clk_mul_frac = 2,
+	wzrd_clk_int_max = 3,
+};
+
+/*
+ *         MMCM Block Diagram
+ *
+ *         +----------------+  +-----------------+
+ * input ->| vco_clk_div_hw |->| vco_clk_mul_hw  |--+
+ * rate    | (int divide)   |  | (frac multiply) |  |
+ *         +----------------+  +-----------------+  |
+ *                                                  |
+ *      +--------------------------------VCO-rate---+
+ *      |
+ *      |  +----------------+
+ *      +->| clkout[0]      |-> output0 rate
+ *      |  | (frac divide)  |
+ *      |  +----------------+
+ *      |
+ *      |  +----------------+
+ *      +->| clkout[1]      |-> output1 rate
+ *      |  | (int divide)   |
+ *      |  +----------------+
+ *      |
+ *     ...
+ *      |
+ *      |  +----------------+
+ *      +->| clkout[1]      |-> output6 rate
+ *         | (int divide)   |
+ *         +----------------+
+ *
+ * struct clk_wzrd - Clock wizard private data structure
+ *
+ * @clk_data:		Clock data
+ * @nb:			Notifier block
+ * @base:		Memory base
+ * @clk_in1:		Handle to input clock 'clk_in1'
+ * @axi_clk:		Handle to input clock 's_axi_aclk'
+ * @clks_internal:	Internal clocks
+ * @clkout:		Output clocks
+ * @speed_grade:	Speed grade of the device
+ * @suspended:		Flag indicating power state of the device
+ */
+struct clk_wzrd {
+	struct clk_onecell_data clk_data;
+	struct notifier_block nb;
+	void __iomem *base;
+	struct clk *clk_in1;
+	struct clk *axi_clk;
+	struct clk *clks_internal[wzrd_clk_int_max];
+	struct clk *clkout[WZRD_NUM_OUTPUTS];
+	unsigned int speed_grade;
+	bool suspended;
+};
+
+/**
+ * struct clk_wzrd_divider - clock divider specific to clk_wzrd
+ *
+ * @hw:		handle between common and hardware-specific interfaces
+ * @base:	base address of register containing the divider
+ * @offset:	offset address of register containing the divider
+ * @shift:	shift to the divider bit field
+ * @width:	width of the divider bit field
+ * @flags:	clk_wzrd divider flags
+ * @valuem:	value of the multiplier
+ * @valued:	value of the common divider
+ * @valueo:	value of the leaf divider
+ * @table:	array of value/divider pairs, last entry should have div = 0
+ * @lock:	register lock
+ */
+struct clk_wzrd_divider {
+	struct clk_hw hw;
+	void __iomem *base;
+	u16 offset;
+	u8 shift;
+	u8 width;
+	u8 flags;
+	const struct clk_div_table *table;
+	u32 valuem;
+	u32 valued;
+	u32 valueo;
+	spinlock_t *lock;  /* divider lock */
+};
+
+#define to_clk_wzrd(_nb) container_of(_nb, struct clk_wzrd, nb)
+
+/* maximum frequencies for input/output clocks per speed grade */
+static const unsigned long clk_wzrd_max_freq[] = {
+	800000000UL,
+	933000000UL,
+	1066000000UL
+};
+
+/* spin lock variable for clk_wzrd */
+static DEFINE_SPINLOCK(clkwzrd_lock);
+
+static unsigned long clk_wzrd_recalc_rate(struct clk_hw *hw,
+					  unsigned long parent_rate)
+{
+	struct clk_wzrd_divider *divider = to_clk_wzrd_divider(hw);
+	void __iomem *div_addr =
+			(void __iomem *)(divider->base + divider->offset);
+	unsigned int val;
+
+	val = readl(div_addr) >> divider->shift;
+	val &= div_mask(divider->width);
+
+	return divider_recalc_rate(hw, parent_rate, val, divider->table,
+			divider->flags, divider->width);
+}
+
+static int clk_wzrd_dynamic_reconfig(struct clk_hw *hw, unsigned long rate,
+				     unsigned long parent_rate)
+{
+	int err = 0;
+	u16 retries;
+	u32 value;
+	unsigned long flags = 0;
+	struct clk_wzrd_divider *divider = to_clk_wzrd_divider(hw);
+	void __iomem *div_addr =
+			(void __iomem *)(divider->base + divider->offset);
+
+	if (divider->lock)
+		spin_lock_irqsave(divider->lock, flags);
+	else
+		__acquire(divider->lock);
+
+	value = DIV_ROUND_CLOSEST(parent_rate, rate);
+
+	/* Cap the value to max */
+	if (value > WZRD_DR_MAX_INT_DIV_VALUE)
+		value = WZRD_DR_MAX_INT_DIV_VALUE;
+
+	/* Set divisor and clear phase offset */
+	writel(value, div_addr);
+	writel(0x00, div_addr + WZRD_DR_DIV_TO_PHASE_OFFSET);
+
+	/* Check status register */
+	retries = WZRD_DR_NUM_RETRIES;
+	while (retries--) {
+		if (readl(divider->base + WZRD_DR_STATUS_REG_OFFSET) &
+							WZRD_DR_LOCK_BIT_MASK)
+			break;
+	}
+
+	if (retries == 0) {
+		err = -ETIMEDOUT;
+		goto err_reconfig;
+	}
+
+	/* Initiate reconfiguration */
+	writel(WZRD_DR_BEGIN_DYNA_RECONF,
+	       divider->base + WZRD_DR_INIT_REG_OFFSET);
+
+	/* Check status register */
+	retries = WZRD_DR_NUM_RETRIES;
+	while (retries--) {
+		if (readl(divider->base + WZRD_DR_STATUS_REG_OFFSET) &
+							WZRD_DR_LOCK_BIT_MASK)
+			break;
+	}
+
+	if (retries == 0)
+		err = -ETIMEDOUT;
+
+err_reconfig:
+	if (divider->lock)
+		spin_unlock_irqrestore(divider->lock, flags);
+	else
+		__release(divider->lock);
+
+	return err;
+}
+
+static long clk_wzrd_round_rate(struct clk_hw *hw, unsigned long rate,
+				unsigned long *prate)
+{
+	u8 div;
+
+	/*
+	 * since we donot change parent rate we just round rate to closest
+	 * achievable
+	 */
+	div = DIV_ROUND_CLOSEST(*prate, rate);
+
+	return (*prate / div);
+}
+
+static u64 clk_wzrd_get_divisors(struct clk_hw *hw, unsigned long rate,
+				 unsigned long parent_rate)
+{
+	struct clk_wzrd_divider *divider = to_clk_wzrd_divider(hw);
+	u64 vco_freq, freq, diff;
+	u32 m, d, o;
+	u64 diff2 = U64_MAX;
+
+	for (m = WZRD_M_MIN; m <= WZRD_M_MAX; m++) {
+		for (d = WZRD_D_MIN; d <= WZRD_D_MAX; d++) {
+			vco_freq = DIV_ROUND_CLOSEST((parent_rate * m), d);
+			if (vco_freq >= WZRD_VCO_MIN && vco_freq <= WZRD_VCO_MAX) {
+				for (o = WZRD_O_MIN; o <= WZRD_O_MAX; o++) {
+					freq = DIV_ROUND_CLOSEST(vco_freq, o);
+					diff = abs(freq - rate);
+
+					if (diff < WZRD_MIN_ERR) {
+						divider->valuem = m;
+						divider->valued = d;
+						divider->valueo = o;
+						diff2 = diff;
+						return 0;
+					}
+					if (diff < diff2) {
+						divider->valuem = m;
+						divider->valued = d;
+						divider->valueo = o;
+						diff2 = diff;
+					}
+				}
+			}
+		}
+	}
+	return -EBUSY;
+}
+
+static int clk_wzrd_dynamic_all_nolock(struct clk_hw *hw, unsigned long rate,
+				       unsigned long parent_rate)
+{
+	struct clk_wzrd_divider *divider = to_clk_wzrd_divider(hw);
+	u32 reg, pre;
+	u16 retries;
+	int err;
+	u64 vco_freq, rate_div, f, clockout0_div;
+
+	err = clk_wzrd_get_divisors(hw, rate, parent_rate);
+	if (err)
+		pr_err("failed to get divisors\n");
+
+	vco_freq = DIV_ROUND_CLOSEST((parent_rate * divider->valuem), divider->valued);
+	rate_div = DIV_ROUND_CLOSEST((vco_freq * WZRD_FRAC_POINTS), rate);
+
+	clockout0_div = rate_div / WZRD_FRAC_POINTS;
+
+	pre = DIV_ROUND_CLOSEST((vco_freq * WZRD_FRAC_POINTS), rate);
+	f = (u32)(pre - (clockout0_div * WZRD_FRAC_POINTS));
+	f = f & WZRD_CLKOUT_FRAC_MASK;
+
+	reg = FIELD_PREP(WZRD_CLKOUT_DIVIDE_MASK, clockout0_div) |
+	      FIELD_PREP(WZRD_CLKOUT0_FRAC_MASK, f);
+
+	writel(reg, divider->base + WZRD_CLK_CFG_REG(2));
+	/* Set divisor and clear phase offset */
+	reg = FIELD_PREP(WZRD_CLKFBOUT_MULT_MASK, divider->valuem) |
+	      FIELD_PREP(WZRD_DIVCLK_DIVIDE_MASK, divider->valued);
+	writel(reg, divider->base + WZRD_CLK_CFG_REG(0));
+	writel(divider->valueo, divider->base + WZRD_CLK_CFG_REG(2));
+	writel(0, divider->base + WZRD_CLK_CFG_REG(3));
+	/* Check status register */
+	retries = WZRD_DR_NUM_RETRIES;
+	while (retries--) {
+		if (readl(divider->base + WZRD_DR_STATUS_REG_OFFSET) &
+							WZRD_DR_LOCK_BIT_MASK)
+			break;
+	}
+
+	if (!retries)
+		return -ETIMEDOUT;
+
+	/* Initiate reconfiguration */
+	writel(WZRD_DR_BEGIN_DYNA_RECONF,
+	       divider->base + WZRD_DR_INIT_REG_OFFSET);
+
+	/* Check status register */
+	retries = WZRD_DR_NUM_RETRIES;
+	while (retries--) {
+		if (readl(divider->base + WZRD_DR_STATUS_REG_OFFSET) &
+							WZRD_DR_LOCK_BIT_MASK)
+			break;
+	}
+
+	if (!retries)
+		return -ETIMEDOUT;
+
+	return 0;
+}
+
+static int clk_wzrd_dynamic_all(struct clk_hw *hw, unsigned long rate,
+				unsigned long parent_rate)
+{
+	struct clk_wzrd_divider *divider = to_clk_wzrd_divider(hw);
+	unsigned long flags = 0;
+	int ret;
+
+	if (divider->lock)
+		spin_lock_irqsave(divider->lock, flags);
+	else
+		__acquire(divider->lock);
+
+	ret = clk_wzrd_dynamic_all_nolock(hw, rate, parent_rate);
+
+	if (divider->lock)
+		spin_unlock_irqrestore(divider->lock, flags);
+	else
+		__release(divider->lock);
+
+	return ret;
+}
+
+static unsigned long clk_wzrd_recalc_rate_all(struct clk_hw *hw,
+					      unsigned long parent_rate)
+{
+	struct clk_wzrd_divider *divider = to_clk_wzrd_divider(hw);
+	u32 m, d, o, div, reg, f;
+
+	reg = readl(divider->base + WZRD_CLK_CFG_REG(0));
+	d = FIELD_GET(WZRD_DIVCLK_DIVIDE_MASK, reg);
+	m = FIELD_GET(WZRD_CLKFBOUT_MULT_MASK, reg);
+	reg = readl(divider->base + WZRD_CLK_CFG_REG(2));
+	o = FIELD_GET(WZRD_DIVCLK_DIVIDE_MASK, reg);
+	f = FIELD_GET(WZRD_CLKOUT0_FRAC_MASK, reg);
+
+	div = DIV_ROUND_CLOSEST(d * (WZRD_FRAC_POINTS * o + f), WZRD_FRAC_POINTS);
+	return divider_recalc_rate(hw, parent_rate * m, div, divider->table,
+			divider->flags, divider->width);
+}
+
+static long clk_wzrd_round_rate_all(struct clk_hw *hw, unsigned long rate,
+				    unsigned long *prate)
+{
+	return rate;
+}
+
+static const struct clk_ops clk_wzrd_clk_divider_ops = {
+	.round_rate = clk_wzrd_round_rate,
+	.set_rate = clk_wzrd_dynamic_reconfig,
+	.recalc_rate = clk_wzrd_recalc_rate,
+};
+
+static const struct clk_ops clk_wzrd_clk_div_all_ops = {
+	.round_rate = clk_wzrd_round_rate_all,
+	.set_rate = clk_wzrd_dynamic_all,
+	.recalc_rate = clk_wzrd_recalc_rate_all,
+};
+
+static unsigned long clk_wzrd_recalc_ratef(struct clk_hw *hw,
+					   unsigned long parent_rate)
+{
+	unsigned int val;
+	u32 div, frac;
+	struct clk_wzrd_divider *divider = to_clk_wzrd_divider(hw);
+	void __iomem *div_addr =
+			(void __iomem *)(divider->base + divider->offset);
+
+	val = readl(div_addr);
+	div = val & div_mask(divider->width);
+	frac = (val >> WZRD_CLKOUT_FRAC_SHIFT) & WZRD_CLKOUT_FRAC_MASK;
+
+	return ((parent_rate * 1000) / ((div * 1000) + frac));
+}
+
+static int clk_wzrd_dynamic_reconfig_f(struct clk_hw *hw, unsigned long rate,
+				       unsigned long parent_rate)
+{
+	int err = 0;
+	u16 retries;
+	u32 value, pre;
+	unsigned long flags = 0;
+	unsigned long rate_div, f, clockout0_div;
+	struct clk_wzrd_divider *divider = to_clk_wzrd_divider(hw);
+	void __iomem *div_addr =
+			(void __iomem *)(divider->base + divider->offset);
+
+	if (divider->lock)
+		spin_lock_irqsave(divider->lock, flags);
+	else
+		__acquire(divider->lock);
+
+	rate_div = ((parent_rate * 1000) / rate);
+	clockout0_div = rate_div / 1000;
+
+	pre = DIV_ROUND_CLOSEST((parent_rate * 1000), rate);
+	f = (u32)(pre - (clockout0_div * 1000));
+	f = f & WZRD_CLKOUT_FRAC_MASK;
+
+	value = ((f << WZRD_CLKOUT_DIVIDE_WIDTH) | (clockout0_div &
+			WZRD_CLKOUT_DIVIDE_MASK));
+
+	/* Set divisor and clear phase offset */
+	writel(value, div_addr);
+	writel(0x0, div_addr + WZRD_DR_DIV_TO_PHASE_OFFSET);
+
+	/* Check status register */
+	retries = WZRD_DR_NUM_RETRIES;
+	while (retries--) {
+		if (readl(divider->base + WZRD_DR_STATUS_REG_OFFSET) &
+							WZRD_DR_LOCK_BIT_MASK)
+			break;
+	}
+
+	if (!retries) {
+		err = -ETIMEDOUT;
+		goto err_reconfig;
+	}
+
+	/* Initiate reconfiguration */
+	writel(WZRD_DR_BEGIN_DYNA_RECONF,
+	       divider->base + WZRD_DR_INIT_REG_OFFSET);
+
+	/* Check status register */
+	retries = WZRD_DR_NUM_RETRIES;
+	while (retries--) {
+		if (readl(divider->base + WZRD_DR_STATUS_REG_OFFSET) &
+							WZRD_DR_LOCK_BIT_MASK)
+			break;
+	}
+
+	if (!retries)
+		err = -ETIMEDOUT;
+
+err_reconfig:
+	if (divider->lock)
+		spin_unlock_irqrestore(divider->lock, flags);
+	else
+		__release(divider->lock);
+
+	return err;
+}
+
+static long clk_wzrd_round_rate_f(struct clk_hw *hw, unsigned long rate,
+				  unsigned long *prate)
+{
+	return rate;
+}
+
+static const struct clk_ops clk_wzrd_clk_divider_ops_f = {
+	.round_rate = clk_wzrd_round_rate_f,
+	.set_rate = clk_wzrd_dynamic_reconfig_f,
+	.recalc_rate = clk_wzrd_recalc_ratef,
+};
+
+static struct clk *clk_wzrd_register_divf(struct device *dev,
+					  const char *name,
+					  const char *parent_name,
+					  unsigned long flags,
+					  void __iomem *base, u16 offset,
+					  u8 shift, u8 width,
+					  u8 clk_divider_flags,
+					  u32 div_type,
+					  spinlock_t *lock)
+{
+	struct clk_wzrd_divider *div;
+	struct clk_hw *hw;
+	struct clk_init_data init;
+	int ret;
+
+	if (clk_divider_flags & CLK_DIVIDER_HIWORD_MASK) {
+		if (width + shift > 16) {
+			pr_warn("divider value exceeds LOWORD field\n");
+			return ERR_PTR(-EINVAL);
+		}
+	}
+
+	/* allocate the divider */
+	div = kzalloc(sizeof(*div), GFP_KERNEL);
+	if (!div)
+		return ERR_PTR(-ENOMEM);
+
+	init.name = name;
+
+	if (clk_divider_flags & CLK_DIVIDER_READ_ONLY)
+		init.ops = &clk_divider_ro_ops;
+	else
+		init.ops = &clk_wzrd_clk_divider_ops_f;
+
+	init.flags = flags;
+	init.parent_names = (parent_name ? &parent_name : NULL);
+	init.num_parents = (parent_name ? 1 : 0);
+
+	/* struct clk_divider assignments */
+	div->base = base;
+	div->offset = offset;
+	div->shift = shift;
+	div->width = width;
+	div->flags = clk_divider_flags;
+	div->lock = lock;
+	div->hw.init = &init;
+	div->table = NULL;
+
+	/* register the clock */
+	hw = &div->hw;
+	ret = clk_hw_register(dev, hw);
+	if (ret) {
+		kfree(div);
+		return ERR_PTR(ret);
+	}
+
+	return hw->clk;
+}
+
+static struct clk *clk_wzrd_register_divider(struct device *dev,
+					     const char *name,
+					     const char *parent_name,
+					     unsigned long flags,
+					     void __iomem *base, u16 offset,
+					     u8 shift, u8 width,
+					     u8 clk_divider_flags,
+					     u32 div_type,
+					     spinlock_t *lock)
+{
+	struct clk_wzrd_divider *div;
+	struct clk_hw *hw;
+	struct clk_init_data init;
+	int ret;
+
+	if (clk_divider_flags & CLK_DIVIDER_HIWORD_MASK) {
+		if (width + shift > 16) {
+			pr_warn("divider value exceeds LOWORD field\n");
+			return ERR_PTR(-EINVAL);
+		}
+	}
+
+	/* allocate the divider */
+	div = kzalloc(sizeof(*div), GFP_KERNEL);
+	if (!div)
+		return ERR_PTR(-ENOMEM);
+
+	init.name = name;
+	if (clk_divider_flags & CLK_DIVIDER_READ_ONLY)
+		init.ops = &clk_divider_ro_ops;
+	else if (div_type == DIV_O)
+		init.ops = &clk_wzrd_clk_divider_ops;
+	else
+		init.ops = &clk_wzrd_clk_div_all_ops;
+	init.flags = flags;
+	init.parent_names = (parent_name ? &parent_name : NULL);
+	init.num_parents = (parent_name ? 1 : 0);
+
+	/* struct clk_divider assignments */
+	div->base = base;
+	div->offset = offset;
+	div->shift = shift;
+	div->width = width;
+	div->flags = clk_divider_flags;
+	div->lock = lock;
+	div->hw.init = &init;
+	div->table = NULL;
+
+	/* register the clock */
+	hw = &div->hw;
+	ret = clk_hw_register(dev, hw);
+	if (ret) {
+		kfree(div);
+		hw = ERR_PTR(ret);
+	}
+
+	return hw->clk;
+}
+
+static int clk_wzrd_clk_notifier(struct notifier_block *nb, unsigned long event,
+				 void *data)
+{
+	unsigned long max;
+	struct clk_notifier_data *ndata = data;
+	struct clk_wzrd *clk_wzrd = to_clk_wzrd(nb);
+
+	if (clk_wzrd->suspended)
+		return NOTIFY_OK;
+
+	if (ndata->clk == clk_wzrd->clk_in1)
+		max = clk_wzrd_max_freq[clk_wzrd->speed_grade - 1];
+	else if (ndata->clk == clk_wzrd->axi_clk)
+		max = WZRD_ACLK_MAX_FREQ;
+	else
+		return NOTIFY_DONE;	/* should never happen */
+
+	switch (event) {
+	case PRE_RATE_CHANGE:
+		if (ndata->new_rate > max)
+			return NOTIFY_BAD;
+		return NOTIFY_OK;
+	case POST_RATE_CHANGE:
+	case ABORT_RATE_CHANGE:
+	default:
+		return NOTIFY_DONE;
+	}
+}
+
+static int __maybe_unused clk_wzrd_suspend(struct device *dev)
+{
+	struct clk_wzrd *clk_wzrd = dev_get_drvdata(dev);
+
+	clk_disable_unprepare(clk_wzrd->axi_clk);
+	clk_wzrd->suspended = true;
+
+	return 0;
+}
+
+static int __maybe_unused clk_wzrd_resume(struct device *dev)
+{
+	int ret;
+	struct clk_wzrd *clk_wzrd = dev_get_drvdata(dev);
+
+	ret = clk_prepare_enable(clk_wzrd->axi_clk);
+	if (ret) {
+		dev_err(dev, "unable to enable s_axi_aclk\n");
+		return ret;
+	}
+
+	clk_wzrd->suspended = false;
+
+	return 0;
+}
+
+static SIMPLE_DEV_PM_OPS(clk_wzrd_dev_pm_ops, clk_wzrd_suspend,
+			 clk_wzrd_resume);
+
+static int clk_wzrd_probe(struct platform_device *pdev)
+{
+	int i, ret;
+	u32 reg, reg_f, mult;
+	unsigned long rate;
+	const char *clk_name;
+	void __iomem *ctrl_reg;
+	struct clk_wzrd *clk_wzrd;
+	struct resource *mem;
+	int outputs;
+	unsigned long flags = 0;
+	const char *clkout_name;
+	struct device_node *np = pdev->dev.of_node;
+
+	clk_wzrd = devm_kzalloc(&pdev->dev, sizeof(*clk_wzrd), GFP_KERNEL);
+	if (!clk_wzrd)
+		return -ENOMEM;
+	platform_set_drvdata(pdev, clk_wzrd);
+
+	mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	clk_wzrd->base = devm_ioremap_resource(&pdev->dev, mem);
+	if (IS_ERR(clk_wzrd->base))
+		return PTR_ERR(clk_wzrd->base);
+
+	ret = of_property_read_u32(np, "speed-grade", &clk_wzrd->speed_grade);
+	if (!ret) {
+		if (clk_wzrd->speed_grade < 1 || clk_wzrd->speed_grade > 3) {
+			dev_warn(&pdev->dev, "invalid speed grade '%d'\n",
+				 clk_wzrd->speed_grade);
+			clk_wzrd->speed_grade = 0;
+		}
+	}
+
+	clk_wzrd->clk_in1 = devm_clk_get(&pdev->dev, "clk_in1");
+	if (IS_ERR(clk_wzrd->clk_in1)) {
+		if (clk_wzrd->clk_in1 != ERR_PTR(-EPROBE_DEFER))
+			dev_err(&pdev->dev, "clk_in1 not found\n");
+		return PTR_ERR(clk_wzrd->clk_in1);
+	}
+
+	clk_wzrd->axi_clk = devm_clk_get(&pdev->dev, "s_axi_aclk");
+	if (IS_ERR(clk_wzrd->axi_clk)) {
+		if (clk_wzrd->axi_clk != ERR_PTR(-EPROBE_DEFER))
+			dev_err(&pdev->dev, "s_axi_aclk not found\n");
+		return PTR_ERR(clk_wzrd->axi_clk);
+	}
+	ret = clk_prepare_enable(clk_wzrd->axi_clk);
+	if (ret) {
+		dev_err(&pdev->dev, "enabling s_axi_aclk failed\n");
+		return ret;
+	}
+	rate = clk_get_rate(clk_wzrd->axi_clk);
+	if (rate > WZRD_ACLK_MAX_FREQ) {
+		dev_err(&pdev->dev, "s_axi_aclk frequency (%lu) too high\n",
+			rate);
+		ret = -EINVAL;
+		goto err_disable_clk;
+	}
+
+	outputs = of_property_count_strings(np, "clock-output-names");
+	clk_name = kasprintf(GFP_KERNEL, "%s_mul_div", dev_name(&pdev->dev));
+	if (!clk_name) {
+		ret = -ENOMEM;
+		goto err_rm_int_clk;
+	}
+
+	if (outputs == 1) {
+		if (of_property_read_string_index(np, "clock-output-names", 0,
+						  &clkout_name)) {
+			dev_err(&pdev->dev,
+				"clock output name not specified\n");
+			ret = -EINVAL;
+			goto err_rm_int_clks;
+		}
+
+		clk_wzrd->clkout[0] = clk_wzrd_register_divider
+				(&pdev->dev, clkout_name,
+				__clk_get_name(clk_wzrd->clk_in1), 0,
+				clk_wzrd->base, WZRD_CLK_CFG_REG(3),
+				WZRD_CLKOUT_DIVIDE_SHIFT,
+				WZRD_CLKOUT_DIVIDE_WIDTH,
+				CLK_DIVIDER_ONE_BASED | CLK_DIVIDER_ALLOW_ZERO,
+				DIV_ALL, &clkwzrd_lock);
+
+		goto out;
+	}
+
+	/* register multiplier */
+	reg = (readl(clk_wzrd->base + WZRD_CLK_CFG_REG(0)) &
+		     WZRD_CLKFBOUT_MULT_MASK) >> WZRD_CLKFBOUT_MULT_SHIFT;
+	reg_f = (readl(clk_wzrd->base + WZRD_CLK_CFG_REG(0)) &
+		     WZRD_CLKFBOUT_FRAC_MASK) >> WZRD_CLKFBOUT_FRAC_SHIFT;
+
+	mult = ((reg * 1000) + reg_f);
+	clk_name = kasprintf(GFP_KERNEL, "%s_mul", dev_name(&pdev->dev));
+	if (!clk_name) {
+		ret = -ENOMEM;
+		goto err_disable_clk;
+	}
+	clk_wzrd->clks_internal[wzrd_clk_mul] = clk_register_fixed_factor
+			(&pdev->dev, clk_name,
+			 __clk_get_name(clk_wzrd->clk_in1),
+			0, mult, 1000);
+	kfree(clk_name);
+	if (IS_ERR(clk_wzrd->clks_internal[wzrd_clk_mul])) {
+		dev_err(&pdev->dev, "unable to register fixed-factor clock\n");
+		ret = PTR_ERR(clk_wzrd->clks_internal[wzrd_clk_mul]);
+		goto err_disable_clk;
+	}
+
+	clk_name = kasprintf(GFP_KERNEL, "%s_mul_div", dev_name(&pdev->dev));
+	if (!clk_name) {
+		ret = -ENOMEM;
+		goto err_rm_int_clk;
+	}
+
+	ctrl_reg = clk_wzrd->base + WZRD_CLK_CFG_REG(0);
+	/* register div */
+	clk_wzrd->clks_internal[wzrd_clk_mul_div] = clk_register_divider
+			(&pdev->dev, clk_name,
+			 __clk_get_name(clk_wzrd->clks_internal[wzrd_clk_mul]),
+			flags, ctrl_reg, 0, 8, CLK_DIVIDER_ONE_BASED |
+			CLK_DIVIDER_ALLOW_ZERO, &clkwzrd_lock);
+	if (IS_ERR(clk_wzrd->clks_internal[wzrd_clk_mul_div])) {
+		dev_err(&pdev->dev, "unable to register divider clock\n");
+		ret = PTR_ERR(clk_wzrd->clks_internal[wzrd_clk_mul_div]);
+		goto out;
+	}
+
+	/* register div per output */
+	for (i = outputs - 1; i >= 0 ; i--) {
+		if (of_property_read_string_index(np, "clock-output-names", i,
+						  &clkout_name)) {
+			dev_err(&pdev->dev,
+				"clock output name not specified\n");
+			ret = -EINVAL;
+			goto err_rm_int_clks;
+		}
+		if (!i)
+			clk_wzrd->clkout[i] = clk_wzrd_register_divf
+				(&pdev->dev, clkout_name,
+				clk_name, flags,
+				clk_wzrd->base, (WZRD_CLK_CFG_REG(2) + i * 12),
+				WZRD_CLKOUT_DIVIDE_SHIFT,
+				WZRD_CLKOUT_DIVIDE_WIDTH,
+				CLK_DIVIDER_ONE_BASED | CLK_DIVIDER_ALLOW_ZERO,
+				DIV_O, &clkwzrd_lock);
+		else
+			clk_wzrd->clkout[i] = clk_wzrd_register_divider
+				(&pdev->dev, clkout_name,
+				clk_name, 0,
+				clk_wzrd->base, (WZRD_CLK_CFG_REG(2) + i * 12),
+				WZRD_CLKOUT_DIVIDE_SHIFT,
+				WZRD_CLKOUT_DIVIDE_WIDTH,
+				CLK_DIVIDER_ONE_BASED | CLK_DIVIDER_ALLOW_ZERO,
+				DIV_O, &clkwzrd_lock);
+		if (IS_ERR(clk_wzrd->clkout[i])) {
+			int j;
+
+			for (j = i + 1; j < outputs; j++)
+				clk_unregister(clk_wzrd->clkout[j]);
+			dev_err(&pdev->dev,
+				"unable to register divider clock\n");
+			ret = PTR_ERR(clk_wzrd->clkout[i]);
+			goto err_rm_int_clks;
+		}
+	}
+
+	kfree(clk_name);
+out:
+	clk_wzrd->clk_data.clks = clk_wzrd->clkout;
+	clk_wzrd->clk_data.clk_num = ARRAY_SIZE(clk_wzrd->clkout);
+	of_clk_add_provider(np, of_clk_src_onecell_get, &clk_wzrd->clk_data);
+
+	if (clk_wzrd->speed_grade) {
+		clk_wzrd->nb.notifier_call = clk_wzrd_clk_notifier;
+
+		ret = clk_notifier_register(clk_wzrd->clk_in1,
+					    &clk_wzrd->nb);
+		if (ret)
+			dev_warn(&pdev->dev,
+				 "unable to register clock notifier\n");
+
+		ret = clk_notifier_register(clk_wzrd->axi_clk, &clk_wzrd->nb);
+		if (ret)
+			dev_warn(&pdev->dev,
+				 "unable to register clock notifier\n");
+	}
+
+	return 0;
+
+err_rm_int_clks:
+	clk_unregister(clk_wzrd->clks_internal[1]);
+err_rm_int_clk:
+	kfree(clk_name);
+	clk_unregister(clk_wzrd->clks_internal[0]);
+err_disable_clk:
+	clk_disable_unprepare(clk_wzrd->axi_clk);
+
+	return ret;
+}
+
+static int clk_wzrd_remove(struct platform_device *pdev)
+{
+	int i;
+	struct clk_wzrd *clk_wzrd = platform_get_drvdata(pdev);
+
+	of_clk_del_provider(pdev->dev.of_node);
+
+	for (i = 0; i < WZRD_NUM_OUTPUTS; i++)
+		clk_unregister(clk_wzrd->clkout[i]);
+	for (i = 0; i < wzrd_clk_int_max; i++)
+		clk_unregister(clk_wzrd->clks_internal[i]);
+
+	if (clk_wzrd->speed_grade) {
+		clk_notifier_unregister(clk_wzrd->axi_clk, &clk_wzrd->nb);
+		clk_notifier_unregister(clk_wzrd->clk_in1, &clk_wzrd->nb);
+	}
+
+	clk_disable_unprepare(clk_wzrd->axi_clk);
+
+	return 0;
+}
+
+static const struct of_device_id clk_wzrd_ids[] = {
+	{ .compatible = "xlnx,clocking-wizard" },
+	{ },
+};
+MODULE_DEVICE_TABLE(of, clk_wzrd_ids);
+
+static struct platform_driver clk_wzrd_driver = {
+	.driver = {
+		.name = "clk-wizard",
+		.of_match_table = clk_wzrd_ids,
+		.pm = &clk_wzrd_dev_pm_ops,
+	},
+	.probe = clk_wzrd_probe,
+	.remove = clk_wzrd_remove,
+};
+module_platform_driver(clk_wzrd_driver);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Soeren Brinkmann <soren.brinkmann@xilinx.com");
+MODULE_DESCRIPTION("Driver for the Xilinx Clocking Wizard IP core");
diff --git a/drivers/clk/idt/Makefile b/drivers/clk/idt/Makefile
new file mode 100644
index 000000000..4cf2b6e48
--- /dev/null
+++ b/drivers/clk/idt/Makefile
@@ -0,0 +1,3 @@
+obj-y += clk-idt8t49n24x-core.o
+obj-y += clk-idt8t49n24x-debugfs.o
+obj-y += clk-idt8t49n24x.o
diff --git a/drivers/clk/idt/clk-idt8t49n24x-core.c b/drivers/clk/idt/clk-idt8t49n24x-core.c
new file mode 100644
index 000000000..ad23014e7
--- /dev/null
+++ b/drivers/clk/idt/clk-idt8t49n24x-core.c
@@ -0,0 +1,933 @@
+// SPDX-License-Identifier: GPL-2.0
+/* clk-idt8t49n24x-core.c - Program 8T49N24x settings via I2C (common code)
+ *
+ * Copyright (C) 2018, Integrated Device Technology, Inc. <david.cater@idt.com>
+ *
+ * See https://www.gnu.org/licenses/old-licenses/gpl-2.0.en.html
+ * This program is distributed "AS IS" and  WITHOUT ANY WARRANTY;
+ * including the implied warranties of MERCHANTABILITY, FITNESS FOR
+ * A PARTICULAR PURPOSE, or NON-INFRINGEMENT.
+ */
+
+#include <linux/i2c.h>
+#include <linux/regmap.h>
+
+#include "clk-idt8t49n24x-core.h"
+
+/*
+ * In Timing Commander, Q0 is changed from 25MHz to Q0 75MHz, the following
+ * changes occur:
+ *
+ * 2 bytes change in EEPROM data string.
+ *
+ * DSM_INT R0025[0],R0026[7:0] : 35 => 30
+ * NS2_Q0 R0040[7:0],R0041[7:0] : 14 => 4
+ *
+ * In EEPROM
+ * 1. R0026
+ * 2. R0041
+ *
+ * Note that VCO_Frequency (metadata) also changed (3500 =>3000).
+ * This reflects a change to DSM_INT.
+ *
+ * Note that the Timing Commander code has workarounds in the workflow scripts
+ * to handle dividers for the 8T49N241 (because the development of that GUI
+ * predates chip override functionality). That affects NS1_Qx (x in 1-3)
+ * and NS2_Qx. NS1_Qx contains the upper bits of NS_Qx, and NS2_Qx contains
+ * the lower bits. That is NOT the case for Q0, though. In that case NS1_Q0
+ * is the 1st stage output divider (/5, /6, /4) and NS2_Q0 is the 16-bit
+ * second stage (with actual divide being twice the value stored in the
+ * register).
+ *
+ * NS1_Q0 R003F[1:0]
+ */
+
+#define IDT24x_VCO_MIN			2999997000u
+#define IDT24x_VCO_MAX			4000004000u
+#define IDT24x_VCO_OPT			3500000000u
+#define IDT24x_MIN_INT_DIVIDER		6
+#define IDT24x_MIN_NS1			4
+#define IDT24x_MAX_NS1			6
+
+static u8 q0_ns1_options[3] = { 5, 6, 4 };
+
+/**
+ * bits_to_shift - num bits to shift given specified mask
+ * @mask:	32-bit word input to count zero bits on right
+ *
+ * Given a bit mask indicating where a value will be stored in
+ * a register, return the number of bits you need to shift the value
+ * before ORing it into the register value.
+ *
+ * Return: number of bits to shift
+ */
+int bits_to_shift(unsigned int mask)
+{
+	/* the number of zero bits on the right */
+	unsigned int c = 32;
+
+	mask &= ~mask + 1;
+	if (mask)
+		c--;
+	if (mask & 0x0000FFFF)
+		c -= 16;
+	if (mask & 0x00FF00FF)
+		c -= 8;
+	if (mask & 0x0F0F0F0F)
+		c -= 4;
+	if (mask & 0x33333333)
+		c -= 2;
+	if (mask & 0x55555555)
+		c -= 1;
+	return c;
+}
+
+/*
+ * TODO: Consider replacing this with regmap_multi_reg_write, which
+ * supports introducing a delay after each write. Experiment to see if
+ * the writes succeed consistently when using that API.
+ */
+static int regmap_bulk_write_with_retry(
+	struct regmap *map, unsigned int offset, u8 val[],
+	int val_count, int max_attempts)
+{
+	int err = 0;
+	int count = 1;
+
+	do {
+		err = regmap_bulk_write(map, offset, val, val_count);
+		if (err == 0)
+			return 0;
+
+		usleep_range(100, 200);
+	} while (count++ <= max_attempts);
+	return err;
+}
+
+static int regmap_write_with_retry(
+	struct regmap *map, unsigned int offset, unsigned int val,
+	int max_attempts)
+{
+	int err = 0;
+	int count = 1;
+
+	do {
+		err = regmap_write(map, offset, val);
+		if (err == 0)
+			return 0;
+		usleep_range(100, 200);
+	} while (count++ <= max_attempts);
+	return err;
+}
+
+/*
+ * TODO: Consider using regmap_multi_reg_write instead. Explore
+ * use of regmap to configure WRITE_BLOCK_SIZE, and using the delay
+ * mechanism in regmap_multi_reg_write instead of retrying multiple
+ * times (regmap_bulk_write_with_retry).
+ */
+int i2cwritebulk(
+	struct i2c_client *client, struct regmap *map,
+	unsigned int reg, u8 val[], size_t val_count)
+{
+	char dbg[128];
+	u8 block[WRITE_BLOCK_SIZE];
+	unsigned int block_offset = reg;
+	int x;
+	int err = 0;
+	int currentOffset = 0;
+
+	dev_dbg(&client->dev, "I2C->0x%04x : [hex] . First byte: %02x, Second byte: %02x",
+		reg, reg >> 8, reg & 0xFF);
+	dbg[0] = 0;
+
+	for (x = 0; x < val_count; x++) {
+		char data[4];
+
+		block[currentOffset++] = val[x];
+		sprintf(data, "%02x ", val[x]);
+		strcat(dbg, data);
+		if (x > 0 && (x + 1) % WRITE_BLOCK_SIZE == 0) {
+			dev_dbg(&client->dev, "%s", dbg);
+			dbg[0] = '\0';
+			sprintf(dbg,
+				"(loop) calling regmap_bulk_write @ 0x%04x [%d bytes]",
+				block_offset, WRITE_BLOCK_SIZE);
+			dev_dbg(&client->dev, "%s", dbg);
+			dbg[0] = '\0';
+			err = regmap_bulk_write_with_retry(
+				map, block_offset, block, WRITE_BLOCK_SIZE, 5);
+			if (err != 0)
+				break;
+			block_offset += WRITE_BLOCK_SIZE;
+			currentOffset = 0;
+		}
+	}
+	if (err == 0 && currentOffset > 0) {
+		dev_dbg(&client->dev, "%s", dbg);
+		dev_dbg(&client->dev, "(final) calling regmap_bulk_write @ 0x%04x [%d bytes]",
+			block_offset, currentOffset);
+		err = regmap_bulk_write_with_retry(
+			map, block_offset, block, currentOffset, 5);
+	}
+
+	return err;
+}
+
+static int i2cwrite(
+	struct i2c_client *client, struct regmap *map,
+	unsigned int reg, unsigned int val)
+{
+	int err;
+
+	dev_dbg(&client->dev, "I2C->0x%x : [hex] %x", reg, val);
+	err = regmap_write_with_retry(map, reg, val, 5);
+	usleep_range(100, 200);
+	return err;
+}
+
+static int i2cwritewithmask(
+	struct i2c_client *client, struct regmap *map, unsigned int reg,
+	u8 val, u8 original, u8 mask)
+{
+	return i2cwrite(client, map, reg,
+		((val << bits_to_shift(mask)) & mask) | (original & ~mask));
+}
+
+int idt24x_get_offsets(
+	u8 output_num,
+	struct clk_register_offsets *offsets)
+{
+	switch (output_num) {
+	case 0:
+		offsets->oe_offset = IDT24x_REG_OUTEN;
+		offsets->oe_mask = IDT24x_REG_OUTEN0_MASK;
+		offsets->dis_mask = IDT24x_REG_Q0_DIS_MASK;
+		offsets->ns1_offset = IDT24x_REG_NS1_Q0;
+		offsets->ns1_offset_mask = IDT24x_REG_NS1_Q0_MASK;
+		offsets->ns2_15_8_offset = IDT24x_REG_NS2_Q0_15_8;
+		offsets->ns2_7_0_offset = IDT24x_REG_NS2_Q0_7_0;
+		break;
+	case 1:
+		offsets->oe_offset = IDT24x_REG_OUTEN;
+		offsets->oe_mask = IDT24x_REG_OUTEN1_MASK;
+		offsets->dis_mask = IDT24x_REG_Q1_DIS_MASK;
+		offsets->n_17_16_offset = IDT24x_REG_N_Q1_17_16;
+		offsets->n_17_16_mask = IDT24x_REG_N_Q1_17_16_MASK;
+		offsets->n_15_8_offset = IDT24x_REG_N_Q1_15_8;
+		offsets->n_7_0_offset = IDT24x_REG_N_Q1_7_0;
+		offsets->nfrac_27_24_offset = IDT24x_REG_NFRAC_Q1_27_24;
+		offsets->nfrac_27_24_mask =
+			IDT24x_REG_NFRAC_Q1_27_24_MASK;
+		offsets->nfrac_23_16_offset = IDT24x_REG_NFRAC_Q1_23_16;
+		offsets->nfrac_15_8_offset = IDT24x_REG_NFRAC_Q1_15_8;
+		offsets->nfrac_7_0_offset = IDT24x_REG_NFRAC_Q1_7_0;
+		break;
+	case 2:
+		offsets->oe_offset = IDT24x_REG_OUTEN;
+		offsets->oe_mask = IDT24x_REG_OUTEN2_MASK;
+		offsets->dis_mask = IDT24x_REG_Q2_DIS_MASK;
+		offsets->n_17_16_offset = IDT24x_REG_N_Q2_17_16;
+		offsets->n_17_16_mask = IDT24x_REG_N_Q2_17_16_MASK;
+		offsets->n_15_8_offset = IDT24x_REG_N_Q2_15_8;
+		offsets->n_7_0_offset = IDT24x_REG_N_Q2_7_0;
+		offsets->nfrac_27_24_offset = IDT24x_REG_NFRAC_Q2_27_24;
+		offsets->nfrac_27_24_mask =
+			IDT24x_REG_NFRAC_Q2_27_24_MASK;
+		offsets->nfrac_23_16_offset = IDT24x_REG_NFRAC_Q2_23_16;
+		offsets->nfrac_15_8_offset = IDT24x_REG_NFRAC_Q2_15_8;
+		offsets->nfrac_7_0_offset = IDT24x_REG_NFRAC_Q2_7_0;
+		break;
+	case 3:
+		offsets->oe_offset = IDT24x_REG_OUTEN;
+		offsets->oe_mask = IDT24x_REG_OUTEN3_MASK;
+		offsets->dis_mask = IDT24x_REG_Q3_DIS_MASK;
+		offsets->n_17_16_offset = IDT24x_REG_N_Q3_17_16;
+		offsets->n_17_16_mask = IDT24x_REG_N_Q3_17_16_MASK;
+		offsets->n_15_8_offset = IDT24x_REG_N_Q3_15_8;
+		offsets->n_7_0_offset = IDT24x_REG_N_Q3_7_0;
+		offsets->nfrac_27_24_offset = IDT24x_REG_NFRAC_Q3_27_24;
+		offsets->nfrac_27_24_mask =
+			IDT24x_REG_NFRAC_Q3_27_24_MASK;
+		offsets->nfrac_23_16_offset = IDT24x_REG_NFRAC_Q3_23_16;
+		offsets->nfrac_15_8_offset = IDT24x_REG_NFRAC_Q3_15_8;
+		offsets->nfrac_7_0_offset = IDT24x_REG_NFRAC_Q3_7_0;
+		break;
+	default:
+		return -EINVAL;
+	}
+	return 0;
+}
+
+/**
+ * idt24x_calc_div_q0 - Calculate dividers and VCO freq to generate
+ *		the specified Q0 frequency.
+ * @chip:	Device data structure. contains all requested frequencies
+ *		for all outputs.
+ *
+ * The actual output divider is ns1 * ns2 * 2. fOutput = fVCO / (ns1 * ns2 * 2)
+ *
+ * The options for ns1 (when the source is the VCO) are 4,5,6. ns2 is a
+ * 16-bit value.
+ *
+ * chip->divs: structure for specifying ns1/ns2 values. If 0 after this
+ * function, Q0 is not requested
+ *
+ * Return: 0 on success, negative errno otherwise.
+ */
+static int idt24x_calc_div_q0(struct clk_idt24x_chip *chip)
+{
+	u8 x;
+	u32 min_div, max_div, best_vco = 0;
+	u16 min_ns2, max_ns2;
+	bool is_lower_vco = false;
+
+	chip->divs.ns1_q0 = 0;
+	chip->divs.ns2_q0 = 0;
+
+	if (chip->clk[0].requested == 0)
+		return 0;
+
+	min_div = div64_u64(
+		(u64)IDT24x_VCO_MIN, chip->clk[0].requested * 2) * 2;
+	max_div = div64_u64(
+		(u64)IDT24x_VCO_MAX, chip->clk[0].requested * 2) * 2;
+
+	dev_dbg(&chip->i2c_client->dev,
+		"%s. requested: %u, min_div: %u, max_div: %u",
+		__func__, chip->clk[0].requested, min_div, max_div);
+
+	min_ns2 = div64_u64((u64)min_div, IDT24x_MAX_NS1 * 2);
+	max_ns2 = div64_u64((u64)max_div, IDT24x_MIN_NS1 * 2);
+
+	dev_dbg(&chip->i2c_client->dev,
+		"%s. min_ns2: %u, max_ns2: %u", __func__, min_ns2, max_ns2);
+
+	for (x = 0; x < ARRAY_SIZE(q0_ns1_options); x++) {
+		u16 y = min_ns2;
+
+		while (y <= max_ns2) {
+			u32 actual_div = q0_ns1_options[x] * y * 2;
+			u32 current_vco = actual_div *
+				chip->clk[0].requested;
+
+			if (current_vco < IDT24x_VCO_MIN)
+				dev_dbg(&chip->i2c_client->dev,
+					"%s. ignore div: (ns1=%u * ns2=%u * 2 * %u) == %u < %u",
+					__func__, q0_ns1_options[x], y,
+					chip->clk[0].requested,
+					current_vco, IDT24x_VCO_MIN);
+			else if (current_vco > IDT24x_VCO_MAX) {
+				dev_dbg(&chip->i2c_client->dev,
+					"%s. ignore div: (ns1=%u * ns2=%u * 2 * %u) == %u > %u. EXIT LOOP.",
+					__func__, q0_ns1_options[x], y,
+					chip->clk[0].requested,
+					current_vco, IDT24x_VCO_MAX);
+				y = max_ns2;
+			} else {
+				bool use = false;
+
+				dev_dbg(&chip->i2c_client->dev,
+					"%s. contender: (ns1=%u * ns2=%u * 2 * %u) == %u [in range]",
+					__func__, q0_ns1_options[x], y,
+					chip->clk[0].requested,
+					current_vco);
+				if (current_vco <= IDT24x_VCO_OPT) {
+					if (current_vco > best_vco ||
+					    !is_lower_vco) {
+						is_lower_vco = true;
+						use = true;
+					}
+				} else if (!is_lower_vco &&
+					   current_vco > best_vco)
+					use = true;
+				if (use) {
+					chip->divs.ns1_q0 = x;
+					chip->divs.ns2_q0 = y;
+					best_vco = current_vco;
+				}
+			}
+			y++;
+		}
+	}
+
+	dev_dbg(&chip->i2c_client->dev,
+		"%s. best: (ns1=%u [/%u] * ns2=%u * 2 * %u) == %u",
+		__func__, chip->divs.ns1_q0, q0_ns1_options[chip->divs.ns1_q0],
+		chip->divs.ns2_q0, chip->clk[0].requested, best_vco);
+	return 0;
+}
+
+/**
+ * idt24x_calc_divs - Calculate dividers to generate the specified frequency.
+ * @chip:	Device data structure. contains all requested frequencies
+ *		for all outputs.
+ *
+ * Calculate the clock dividers (dsmint, dsmfrac for vco; ns1/ns2 for q0,
+ * n/nfrac for q1-3) for a given target frequency.
+ *
+ * Return: 0 on success, negative errno otherwise.
+ */
+static int idt24x_calc_divs(struct clk_idt24x_chip *chip)
+{
+	u32 vco = 0;
+	int result;
+
+	result = idt24x_calc_div_q0(chip);
+	if (result < 0)
+		return result;
+
+	dev_dbg(&chip->i2c_client->dev,
+		"%s: after idt24x_calc_div_q0. ns1: %u [/%u], ns2: %u",
+		__func__, chip->divs.ns1_q0, q0_ns1_options[chip->divs.ns1_q0],
+		chip->divs.ns2_q0);
+
+	chip->divs.dsmint = 0;
+	chip->divs.dsmfrac = 0;
+
+	if (chip->clk[0].requested > 0) {
+		/* Q0 is in use and is governing the actual VCO freq */
+		vco = q0_ns1_options[chip->divs.ns1_q0] * chip->divs.ns2_q0 *
+			2 * chip->clk[0].requested;
+	} else {
+		u32 freq = 0;
+		u32 walk;
+		u32 min_div, max_div;
+		bool is_lower_vco = false;
+
+		/*
+		 * Q0 is not in use. Use the first requested (fractional)
+		 * output frequency as the one controlling the VCO.
+		 */
+		for (walk = 1; walk < NUM_OUTPUTS; walk++) {
+			if (chip->clk[walk].requested != 0) {
+				freq = chip->clk[walk].requested;
+				break;
+			}
+		}
+
+		if (freq == 0) {
+			dev_err(&chip->i2c_client->dev,
+				"%s: NO FREQUENCIES SPECIFIED", __func__);
+			return -EINVAL;
+		}
+
+		/*
+		 * First, determine the min/max div for the output frequency.
+		 */
+		min_div = IDT24x_MIN_INT_DIVIDER;
+		max_div = div64_u64((u64)IDT24x_VCO_MAX, freq * 2) * 2;
+
+		dev_dbg(&chip->i2c_client->dev,
+			"%s: calc_divs for fractional output. freq: %u, min_div: %u, max_div: %u",
+			__func__, freq, min_div, max_div);
+
+		walk = min_div;
+
+		while (walk <= max_div) {
+			u32 current_vco = freq * walk;
+
+			dev_dbg(&chip->i2c_client->dev,
+				"%s: calc_divs for fractional output. walk: %u, freq: %u, vco: %u",
+				__func__, walk, freq, vco);
+			if (current_vco >= IDT24x_VCO_MIN &&
+			    vco <= IDT24x_VCO_MAX) {
+				if (current_vco <= IDT24x_VCO_OPT) {
+					if (current_vco > vco ||
+					    !is_lower_vco) {
+						is_lower_vco = true;
+						vco = current_vco;
+					}
+				} else if (!is_lower_vco && current_vco > vco) {
+					vco = current_vco;
+				}
+			}
+			/* Divider must be even. */
+			walk += 2;
+		}
+	}
+
+	if (vco != 0) {
+		u32 pfd;
+		u64 rem;
+		int x;
+
+		/* Setup dividers for outputs with fractional dividers. */
+		for (x = 1; x < NUM_OUTPUTS; x++) {
+			if (chip->clk[x].requested != 0) {
+				/*
+				 * The value written to the chip is half
+				 * the calculated divider.
+				 */
+				chip->divs.nint[x - 1] = div64_u64_rem(
+					(u64)vco,
+					chip->clk[x].requested * 2,
+					&rem);
+				chip->divs.nfrac[x - 1] = div64_u64(
+					rem * 1 << 28,
+					chip->clk[x].requested * 2);
+				dev_dbg(&chip->i2c_client->dev,
+					"%s: div to get Q%i freq %u from vco %u: int part: %u, rem: %llu, frac part: %u",
+					__func__, x,
+					chip->clk[x].requested,
+					vco, chip->divs.nint[x - 1], rem,
+					chip->divs.nfrac[x - 1]);
+			}
+		}
+
+		/* Calculate freq for pfd */
+		pfd = chip->input_clk_freq * (chip->doubler_disabled ? 1 : 2);
+
+		/*
+		 * Calculate dsmint & dsmfrac:
+		 * -----------------------------
+		 * dsm = float(vco)/float(pfd)
+		 * dsmfrac = dsm-floor(dsm) * 2^21
+		 * rem = vco % pfd
+		 * therefore:
+		 * dsmfrac = (rem * 2^21)/pfd
+		 */
+		chip->divs.dsmint = div64_u64_rem(vco, pfd, &rem);
+		chip->divs.dsmfrac = div64_u64(rem * 1 << 21, pfd);
+
+		dev_dbg(&chip->i2c_client->dev,
+			"%s: vco: %u, pfd: %u, dsmint: %u, dsmfrac: %u, rem: %llu",
+			__func__, vco, pfd, chip->divs.dsmint,
+			chip->divs.dsmfrac, rem);
+	} else {
+		dev_err(&chip->i2c_client->dev,
+			"%s: no integer divider in range found. NOT SUPPORTED.",
+			__func__);
+		return -EINVAL;
+	}
+	return 0;
+}
+
+/**
+ * idt24x_enable_output - Enable/disable a particular output
+ * @chip:	Device data structure
+ * @output:	Output to enable/disable
+ * @enable:	Enable (true/false)
+ *
+ * Return: passes on regmap_write return value.
+ */
+static int idt24x_enable_output(
+	struct clk_idt24x_chip *chip, u8 output, bool enable)
+{
+	struct clk_register_offsets offsets;
+	int err;
+	struct i2c_client *client = chip->i2c_client;
+
+	/*
+	 * When an output is enabled, enable it in the original
+	 * data read from the chip and cached. Otherwise it may be
+	 * accidentally	turned off when another output is enabled.
+	 *
+	 * E.g., the driver starts with all outputs off in reg_out_en_x.
+	 * Q1 is enabled with the appropriate mask. Q2 is then enabled,
+	 * which results in Q1 being turned back off (because Q1 was off
+	 * in reg_out_en_x).
+	 */
+
+	err = idt24x_get_offsets(output, &offsets);
+	if (err) {
+		dev_err(&client->dev,
+			"%s: error calling idt24x_get_offsets for %d: %i",
+			__func__, output, err);
+		return err;
+	}
+
+	dev_dbg(&client->dev,
+		"%s: q%u enable? %d. reg_out_en_x before: 0x%x, reg_out_mode_0_1 before: 0x%x, reg_out_mode_2_3 before: 0x%x, reg_qx_dis before: 0x%x",
+		__func__, output, enable, chip->reg_out_en_x,
+		chip->reg_out_mode_0_1, chip->reg_out_mode_2_3,
+		chip->reg_qx_dis);
+
+	chip->reg_out_en_x = chip->reg_out_en_x & ~offsets.oe_mask;
+	if (enable)
+		chip->reg_out_en_x |= (1 << bits_to_shift(offsets.oe_mask));
+
+	chip->reg_qx_dis = chip->reg_qx_dis & ~offsets.dis_mask;
+	dev_dbg(&client->dev,
+		"%s: q%u enable? %d. reg_qx_dis mask: 0x%x, before checking enable: 0x%x",
+		__func__, output, enable, offsets.dis_mask,
+		chip->reg_qx_dis);
+	if (!enable)
+		chip->reg_qx_dis |= (1 << bits_to_shift(offsets.dis_mask));
+
+	dev_dbg(&client->dev,
+		"%s: q%u enable? %d. reg_out_en_x after: 0x%x, reg_qx_dis after: 0x%x",
+		__func__, output, enable, chip->reg_out_en_x,
+		chip->reg_qx_dis);
+
+	err = i2cwrite(
+		client, chip->regmap, IDT24x_REG_OUTEN, chip->reg_out_en_x);
+	if (err) {
+		dev_err(&client->dev,
+			"%s: error setting IDT24x_REG_OUTEN: %i",
+			__func__, err);
+		return err;
+	}
+
+	err = i2cwrite(
+		client, chip->regmap, IDT24x_REG_OUTMODE0_1,
+		chip->reg_out_mode_0_1);
+	if (err) {
+		dev_err(&client->dev,
+			"%s: error setting IDT24x_REG_OUTMODE0_1: %i",
+			__func__, err);
+		return err;
+	}
+
+	err = i2cwrite(
+		client, chip->regmap, IDT24x_REG_OUTMODE2_3,
+		chip->reg_out_mode_2_3);
+	if (err) {
+		dev_err(&client->dev,
+			"%s: error setting IDT24x_REG_OUTMODE2_3: %i",
+			__func__, err);
+		return err;
+	}
+
+	err = i2cwrite(
+		client, chip->regmap, IDT24x_REG_Q_DIS, chip->reg_qx_dis);
+	if (err) {
+		dev_err(&client->dev,
+			"%s: error setting IDT24x_REG_Q_DIS: %i",
+			__func__, err);
+		return err;
+	}
+
+	return 0;
+}
+
+/**
+ * idt24x_update_device - write registers to the chip
+ * @chip:	Device data structure
+ *
+ * Write all values to hardware that we	have calculated.
+ *
+ * Return: passes on regmap_bulk_write return value.
+ */
+static int idt24x_update_device(struct clk_idt24x_chip *chip)
+{
+	int err;
+	struct i2c_client *client = chip->i2c_client;
+	int x = -1;
+
+	dev_dbg(&client->dev,
+		"%s: setting DSM_INT_8 (val %u @ %u)",
+		__func__, chip->divs.dsmint >> 8,
+		IDT24x_REG_DSM_INT_8);
+	err = i2cwritewithmask(
+		client, chip->regmap, IDT24x_REG_DSM_INT_8,
+		(chip->divs.dsmint >> 8) & IDT24x_REG_DSM_INT_8_MASK,
+		chip->reg_dsm_int_8, IDT24x_REG_DSM_INT_8_MASK);
+	if (err) {
+		dev_err(&client->dev,
+			"%s: error setting IDT24x_REG_DSM_INT_8: %i",
+			__func__, err);
+		return err;
+	}
+
+	dev_dbg(&client->dev,
+		"%s: setting DSM_INT_7_0 (val %u @ 0x%x)",
+		__func__, chip->divs.dsmint & 0xFF,
+		IDT24x_REG_DSM_INT_7_0);
+	err = i2cwrite(
+		client, chip->regmap, IDT24x_REG_DSM_INT_7_0,
+		chip->divs.dsmint & 0xFF);
+	if (err) {
+		dev_err(&client->dev,
+			"%s: error setting IDT24x_REG_DSM_INT_7_0: %i",
+			__func__, err);
+		return err;
+	}
+
+	dev_dbg(&client->dev,
+		"%s: setting IDT24x_REG_DSMFRAC_20_16 (val %u @ 0x%x)",
+		__func__, chip->divs.dsmfrac >> 16,
+		IDT24x_REG_DSMFRAC_20_16);
+	err = i2cwritewithmask(
+		client, chip->regmap, IDT24x_REG_DSMFRAC_20_16,
+		(chip->divs.dsmfrac >> 16) & IDT24x_REG_DSMFRAC_20_16_MASK,
+		chip->reg_dsm_int_8, IDT24x_REG_DSMFRAC_20_16_MASK);
+	if (err) {
+		dev_err(&client->dev,
+			"%s: error setting IDT24x_REG_DSMFRAC_20_16: %i",
+			__func__, err);
+		return err;
+	}
+
+	dev_dbg(&client->dev,
+		"%s: setting IDT24x_REG_DSMFRAC_15_8 (val %u @ 0x%x)",
+		__func__, (chip->divs.dsmfrac >> 8) & 0xFF,
+		IDT24x_REG_DSMFRAC_15_8);
+	err = i2cwrite(
+		client, chip->regmap, IDT24x_REG_DSMFRAC_15_8,
+		(chip->divs.dsmfrac >> 8) & 0xFF);
+	if (err) {
+		dev_err(&client->dev,
+			"%s: error setting IDT24x_REG_DSMFRAC_15_8: %i",
+			__func__, err);
+		return err;
+	}
+
+	dev_dbg(&client->dev,
+		"%s: setting IDT24x_REG_DSMFRAC_7_0 (val %u @ 0x%x)",
+		__func__, chip->divs.dsmfrac & 0xFF,
+		IDT24x_REG_DSMFRAC_7_0);
+	err = i2cwrite(
+		client, chip->regmap, IDT24x_REG_DSMFRAC_7_0,
+		chip->divs.dsmfrac & 0xFF);
+	if (err) {
+		dev_err(&client->dev,
+			"%s: error setting IDT24x_REG_DSMFRAC_7_0: %i",
+			__func__, err);
+		return err;
+	}
+
+	dev_dbg(&client->dev,
+		"%s: setting IDT24x_REG_NS1_Q0 (val %u @ 0x%x)",
+		__func__, chip->divs.ns1_q0, IDT24x_REG_NS1_Q0);
+	err = i2cwritewithmask(
+		client, chip->regmap, IDT24x_REG_NS1_Q0,
+		chip->divs.ns1_q0 & IDT24x_REG_NS1_Q0_MASK,
+		chip->reg_ns1_q0, IDT24x_REG_NS1_Q0_MASK);
+	if (err) {
+		dev_err(&client->dev,
+			"%s: error setting IDT24x_REG_NS1_Q0: %i",
+			__func__, err);
+		return err;
+	}
+
+	dev_dbg(&client->dev,
+		"%s: setting IDT24x_REG_NS2_Q0_15_8 (val %u @ 0x%x)",
+		__func__, (chip->divs.ns2_q0 >> 8) & 0xFF,
+		IDT24x_REG_NS2_Q0_15_8);
+	err = i2cwrite(
+		client, chip->regmap, IDT24x_REG_NS2_Q0_15_8,
+		(chip->divs.ns2_q0 >> 8) & 0xFF);
+	if (err) {
+		dev_err(&client->dev,
+			"%s: error setting IDT24x_REG_NS2_Q0_15_8: %i",
+			__func__, err);
+		return err;
+	}
+
+	dev_dbg(&client->dev,
+		"%s: setting IDT24x_REG_NS2_Q0_7_0 (val %u @ 0x%x)",
+		__func__, chip->divs.ns2_q0 & 0xFF,
+		IDT24x_REG_NS2_Q0_7_0);
+	err = i2cwrite(
+		client, chip->regmap, IDT24x_REG_NS2_Q0_7_0,
+		chip->divs.ns2_q0 & 0xFF);
+	if (err) {
+		dev_err(&client->dev,
+			"%s: error setting IDT24x_REG_NS2_Q0_7_0: %i",
+			__func__, err);
+		return err;
+	}
+
+	dev_dbg(&client->dev,
+		"%s: calling idt24x_enable_output for Q0. requestedFreq: %u",
+		__func__, chip->clk[0].requested);
+	idt24x_enable_output(chip, 0, chip->clk[0].requested != 0);
+
+	dev_dbg(&client->dev,
+		"%s: writing values for q1-q3", __func__);
+	for (x = 1; x < NUM_OUTPUTS; x++) {
+		struct clk_register_offsets offsets;
+
+		if (chip->clk[x].requested != 0) {
+			dev_dbg(&client->dev,
+				"%s: calling idt24x_get_offsets for %u",
+				__func__, x);
+			err = idt24x_get_offsets(x, &offsets);
+			if (err) {
+				dev_err(&client->dev,
+					"%s: error calling idt24x_get_offsets: %i",
+					__func__, err);
+				return err;
+			}
+
+			dev_dbg(&client->dev,
+				"%s: (q%u, nint: %u, nfrac: %u)",
+				__func__, x, chip->divs.nint[x - 1],
+				chip->divs.nfrac[x - 1]);
+
+			dev_dbg(&client->dev,
+				"%s: setting n_17_16_offset (q%u, val %u @ 0x%x)",
+				__func__, x,
+				chip->divs.nint[x - 1] >> 16,
+				offsets.n_17_16_offset);
+			err = i2cwritewithmask(
+				client, chip->regmap, offsets.n_17_16_offset,
+				(chip->divs.nint[x - 1] >> 16) &
+					offsets.n_17_16_mask,
+				chip->reg_n_qx_17_16[x - 1],
+				offsets.n_17_16_mask);
+			if (err) {
+				dev_err(&client->dev,
+					"%s: error setting n_17_16_offset: %i",
+					__func__, err);
+				return err;
+			}
+
+			dev_dbg(&client->dev,
+				"%s: setting n_15_8_offset (q%u, val %u @ 0x%x)",
+				__func__, x,
+				(chip->divs.nint[x - 1] >> 8) & 0xFF,
+				offsets.n_15_8_offset);
+			err = i2cwrite(
+				client, chip->regmap, offsets.n_15_8_offset,
+				(chip->divs.nint[x - 1] >> 8) & 0xFF);
+			if (err) {
+				dev_err(&client->dev,
+					"%s: error setting n_15_8_offset: %i",
+					__func__, err);
+				return err;
+			}
+
+			dev_dbg(&client->dev,
+				"%s: setting n_7_0_offset (q%u, val %u @ 0x%x)",
+				__func__, x,
+				chip->divs.nint[x - 1] & 0xFF,
+				offsets.n_7_0_offset);
+			err = i2cwrite(
+				client, chip->regmap, offsets.n_7_0_offset,
+				chip->divs.nint[x - 1] & 0xFF);
+			if (err) {
+				dev_err(&client->dev,
+					"%s: error setting n_7_0_offset: %i",
+					__func__, err);
+				return err;
+			}
+
+			dev_dbg(&client->dev,
+				"%s: setting nfrac_27_24_offset (q%u, val %u @ 0x%x)",
+				__func__, x,
+				(chip->divs.nfrac[x - 1] >> 24),
+				offsets.nfrac_27_24_offset);
+			err = i2cwritewithmask(
+				client, chip->regmap,
+				offsets.nfrac_27_24_offset,
+				(chip->divs.nfrac[x - 1] >> 24) &
+					offsets.nfrac_27_24_mask,
+				chip->reg_nfrac_qx_27_24[x - 1],
+				offsets.nfrac_27_24_mask);
+			if (err) {
+				dev_err(&client->dev,
+					"%s: error setting nfrac_27_24_offset: %i",
+					__func__, err);
+				return err;
+			}
+
+			dev_dbg(&client->dev,
+				"%s: setting nfrac_23_16_offset (q%u, val %u @ 0x%x)",
+				__func__, x,
+				(chip->divs.nfrac[x - 1] >> 16) & 0xFF,
+				offsets.nfrac_23_16_offset);
+			err = i2cwrite(
+				client, chip->regmap,
+				offsets.nfrac_23_16_offset,
+				(chip->divs.nfrac[x - 1] >> 16) & 0xFF);
+			if (err) {
+				dev_err(&client->dev,
+					"%s: error setting nfrac_23_16_offset: %i",
+					__func__, err);
+				return err;
+			}
+
+			dev_dbg(&client->dev,
+				"%s: setting nfrac_15_8_offset (q%u, val %u @ 0x%x)",
+				__func__, x,
+				(chip->divs.nfrac[x - 1] >> 8) & 0xFF,
+				offsets.nfrac_15_8_offset);
+			err = i2cwrite(
+				client, chip->regmap,
+				offsets.nfrac_15_8_offset,
+				(chip->divs.nfrac[x - 1] >> 8) & 0xFF);
+			if (err) {
+				dev_err(&client->dev,
+					"%s: error setting nfrac_15_8_offset: %i",
+					__func__, err);
+				return err;
+			}
+
+			dev_dbg(&client->dev,
+				"%s: setting nfrac_7_0_offset (q%u, val %u @ 0x%x)",
+				__func__, x,
+				chip->divs.nfrac[x - 1] & 0xFF,
+				offsets.nfrac_7_0_offset);
+			err = i2cwrite(
+				client, chip->regmap, offsets.nfrac_7_0_offset,
+				chip->divs.nfrac[x - 1] & 0xFF);
+			if (err) {
+				dev_err(&client->dev,
+					"%s: error setting nfrac_7_0_offset: %i",
+					__func__, err);
+				return err;
+			}
+		}
+		idt24x_enable_output(chip, x,
+				     chip->clk[x].requested != 0);
+		chip->clk[x].actual = chip->clk[x].requested;
+	}
+	return 0;
+}
+
+/**
+ * idt24x_set_frequency - Adjust output frequency on the attached chip.
+ * @chip:	Device data structure, including all requested frequencies.
+ *
+ * Return: 0 on success.
+ */
+int idt24x_set_frequency(struct clk_idt24x_chip *chip)
+{
+	int err;
+	struct i2c_client *client = chip->i2c_client;
+	int x;
+	bool all_disabled = true;
+
+	for (x = 0; x < NUM_OUTPUTS; x++) {
+		if (chip->clk[x].requested == 0) {
+			idt24x_enable_output(chip, x, false);
+			chip->clk[x].actual = 0;
+		} else {
+			all_disabled = false;
+		}
+	}
+
+	if (all_disabled)
+		/*
+		 * no requested frequencies, so nothing else to calculate
+		 * or write to the chip. If the consumer wants to disable
+		 * all outputs, they can request 0 for all frequencies.
+		 */
+		return 0;
+
+	if (chip->input_clk_freq == 0) {
+		dev_err(&client->dev,
+			"%s: no input frequency; can't continue.", __func__);
+		return -EINVAL;
+	}
+
+	err = idt24x_calc_divs(chip);
+	if (err) {
+		dev_err(&client->dev,
+			"%s: error calling idt24x_calc_divs: %i",
+			__func__, err);
+		return err;
+	}
+
+	err = idt24x_update_device(chip);
+	if (err) {
+		dev_err(&client->dev,
+			"%s: error updating the device: %i",
+			__func__, err);
+		return err;
+	}
+
+	return 0;
+}
diff --git a/drivers/clk/idt/clk-idt8t49n24x-core.h b/drivers/clk/idt/clk-idt8t49n24x-core.h
new file mode 100644
index 000000000..247ec070c
--- /dev/null
+++ b/drivers/clk/idt/clk-idt8t49n24x-core.h
@@ -0,0 +1,272 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* clk-idt8t49n24x-core.h - Program 8T49N24x settings via I2C (common code)
+ *
+ * Copyright (C) 2018, Integrated Device Technology, Inc. <david.cater@idt.com>
+ *
+ * See https://www.gnu.org/licenses/old-licenses/gpl-2.0.en.html
+ * This program is distributed "AS IS" and  WITHOUT ANY WARRANTY;
+ * including the implied warranties of MERCHANTABILITY, FITNESS FOR
+ * A PARTICULAR PURPOSE, or NON-INFRINGEMENT.
+ */
+
+#ifndef __IDT_CLK_IDT8T49N24X_CORE_H_
+#define __IDT_CLK_IDT8T49N24X_CORE_H_
+
+#include <linux/clk.h>
+#include <linux/clk-provider.h>
+#include <linux/regmap.h>
+
+/*
+ * The configurations in the settings file have 0x317 registers (last offset
+ * is 0x316).
+ */
+#define NUM_CONFIG_REGISTERS	0x317
+#define NUM_INPUTS		2
+#define NUM_OUTPUTS		4
+#define DEBUGFS_BUFFER_LENGTH	200
+#define WRITE_BLOCK_SIZE	32
+
+/* Non output-specific registers */
+#define IDT24x_REG_DBL_DIS		0x6C
+#define IDT24x_REG_DBL_DIS_MASK		0x01
+#define IDT24x_REG_DSM_INT_8		0x25
+#define IDT24x_REG_DSM_INT_8_MASK	0x01
+#define IDT24x_REG_DSM_INT_7_0		0x26
+#define IDT24x_REG_DSMFRAC_20_16	0x28
+#define IDT24x_REG_DSMFRAC_20_16_MASK	0x1F
+#define IDT24x_REG_DSMFRAC_15_8		0x29
+#define IDT24x_REG_DSMFRAC_7_0		0x2A
+#define IDT24x_REG_OUTEN		0x39
+#define IDT24x_REG_OUTMODE0_1		0x3E
+#define IDT24x_REG_OUTMODE2_3		0x3D
+#define IDT24x_REG_Q_DIS		0x6F
+
+/* Q0 */
+#define IDT24x_REG_OUTEN0_MASK		0x01
+#define IDT24x_REG_OUTMODE0_MASK	0x0E
+#define IDT24x_REG_Q0_DIS_MASK		0x01
+#define IDT24x_REG_NS1_Q0		0x3F
+#define IDT24x_REG_NS1_Q0_MASK		0x03
+#define IDT24x_REG_NS2_Q0_15_8		0x40
+#define IDT24x_REG_NS2_Q0_7_0		0x41
+
+/* Q1 */
+#define IDT24x_REG_OUTEN1_MASK		0x02
+#define IDT24x_REG_OUTMODE1_MASK	0xE0
+#define IDT24x_REG_Q1_DIS_MASK		0x02
+#define IDT24x_REG_N_Q1_17_16		0x42
+#define IDT24x_REG_N_Q1_17_16_MASK	0x03
+#define IDT24x_REG_N_Q1_15_8		0x43
+#define IDT24x_REG_N_Q1_7_0		0x44
+#define IDT24x_REG_NFRAC_Q1_27_24	0x57
+#define IDT24x_REG_NFRAC_Q1_27_24_MASK	0x0F
+#define IDT24x_REG_NFRAC_Q1_23_16	0x58
+#define IDT24x_REG_NFRAC_Q1_15_8	0x59
+#define IDT24x_REG_NFRAC_Q1_7_0		0x5A
+
+/* Q2 */
+#define IDT24x_REG_OUTEN2_MASK		0x04
+#define IDT24x_REG_OUTMODE2_MASK	0x0E
+#define IDT24x_REG_Q2_DIS_MASK		0x04
+#define IDT24x_REG_N_Q2_17_16		0x45
+#define IDT24x_REG_N_Q2_17_16_MASK	0x03
+#define IDT24x_REG_N_Q2_15_8		0x46
+#define IDT24x_REG_N_Q2_7_0		0x47
+#define IDT24x_REG_NFRAC_Q2_27_24	0x5B
+#define IDT24x_REG_NFRAC_Q2_27_24_MASK	0x0F
+#define IDT24x_REG_NFRAC_Q2_23_16	0x5C
+#define IDT24x_REG_NFRAC_Q2_15_8	0x5D
+#define IDT24x_REG_NFRAC_Q2_7_0		0x5E
+
+/* Q3 */
+#define IDT24x_REG_OUTEN3_MASK		0x08
+#define IDT24x_REG_OUTMODE3_MASK	0xE0
+#define IDT24x_REG_Q3_DIS_MASK		0x08
+#define IDT24x_REG_N_Q3_17_16		0x48
+#define IDT24x_REG_N_Q3_17_16_MASK	0x03
+#define IDT24x_REG_N_Q3_15_8		0x49
+#define IDT24x_REG_N_Q3_7_0		0x4A
+#define IDT24x_REG_NFRAC_Q3_27_24	0x5F
+#define IDT24x_REG_NFRAC_Q3_27_24_MASK	0x0F
+#define IDT24x_REG_NFRAC_Q3_23_16	0x60
+#define IDT24x_REG_NFRAC_Q3_15_8	0x61
+#define IDT24x_REG_NFRAC_Q3_7_0		0x62
+
+/**
+ * struct idt24x_output - device output information
+ * @hw:		hw registration info for this specific output clcok. This gets
+ *		passed as an argument to CCF api calls (e.g., set_rate).
+ *		container_of can then be used to get the reference to this
+ *		struct.
+ * @chip:	store a reference to the parent device structure. container_of
+ *		cannot be used to get to the parent device structure from
+ *		idt24x_output, because clk_idt24x_chip contains an array of
+ *		output structs (for future enhancements to support devices
+ *		with different numbers of output clocks).
+ * @index:	identifies output on the chip; used in debug statements
+ * @requested:	requested output clock frequency (in Hz)
+ * @actual:	actual output clock frequency (in Hz). Will only be set after
+ *		successful update of the device.
+ * @debug_freq:	stores value for debugfs file. Use this instead of requested
+ *		struct var because debugfs expects u64, not u32.
+ */
+struct idt24x_output {
+	struct clk_hw hw;
+	struct clk_idt24x_chip *chip;
+	u8 index;
+	u32 requested;
+	u32 actual;
+	u64 debug_freq;
+};
+
+/**
+ * struct idt24x_dividers - output dividers
+ * @dsmint:	int component of feedback divider for VCO (2-stage divider)
+ * @dsmfrac:	fractional component of feedback divider for VCO
+ * @ns1_q0:	ns1 divider component for Q0
+ * @ns2_q0:	ns2 divider component for Q0
+ * @nint:	int divider component for Q1-3
+ * @nfrac:	fractional divider component for Q1-3
+ */
+struct idt24x_dividers {
+	u16 dsmint;
+	u32 dsmfrac;
+
+	u8 ns1_q0;
+	u16 ns2_q0;
+
+	u32 nint[3];
+	u32 nfrac[3];
+};
+
+/**
+ * struct clk_idt24x_chip - device info for chip
+ * @regmap:		register map used to perform i2c writes to the chip
+ * @i2c_client:		i2c_client struct passed to probe
+ * @min_freq:		min frequency for this chip
+ * @max_freq:		max frequency for this chip
+ * @settings:		filled in if full register map is specified in the DT
+ * @has_settings:	true if settings array is valid
+ * @input_clk:		ptr to input clock specified in DT
+ * @input_clk_num:	which input clock was specified. 0-based. A value of
+ *			NUM_INPUTS indicates that a XTAL is used as the input.
+ * @input_clk_nb:	notification support (if input clk changes)
+ * @input_clk_freq:	current freq of input_clk
+ * @doubler_disabled:	whether input doubler is enabled. This value is read
+ *			from the hw on probe (in case it is set in @settings).
+ * @clk:		array of outputs. One entry per output supported by the
+ *			chip. Frequencies requested via the ccf api will be
+ *			recorded in this array.
+ * @reg_dsm_int_8:	record current value from hw to avoid modifying
+ *			when writing register values
+ * @reg_dsm_frac_20_16:	record current value
+ * @reg_out_en_x:	record current value
+ * @reg_out_mode_0_1:	record current value
+ * @reg_out_mode_2_3:	record current value
+ * @reg_qx_dis:		record current value
+ * @reg_ns1_q0:		record current value
+ * @reg_n_qx_17_16:	record current value
+ * @reg_nfrac_qx_27_24:	record current value
+ * @divs:		output divider values for all outputs
+ * @debugfs_dirroot:	debugfs support
+ * @debugfs_fileaction:	debugfs support
+ * @debugfs_filei2c:	debugfs support
+ * @debugfs_map:	debugfs support
+ * @dbg_cache:		debugfs support
+ * @debugfs_fileqfreq:	debugfs support
+ */
+struct clk_idt24x_chip {
+	struct regmap *regmap;
+	struct i2c_client *i2c_client;
+
+	u32 min_freq;
+	u32 max_freq;
+
+	u8 settings[NUM_CONFIG_REGISTERS];
+
+	bool has_settings;
+
+	struct clk *input_clk;
+	int input_clk_num;
+	struct notifier_block input_clk_nb;
+	u32 input_clk_freq;
+
+	bool doubler_disabled;
+
+	struct idt24x_output clk[NUM_OUTPUTS];
+
+	unsigned int reg_dsm_int_8;
+	unsigned int reg_dsm_frac_20_16;
+	unsigned int reg_out_en_x;
+	unsigned int reg_out_mode_0_1;
+	unsigned int reg_out_mode_2_3;
+	unsigned int reg_qx_dis;
+	unsigned int reg_ns1_q0;
+	unsigned int reg_n_qx_17_16[3];
+	unsigned int reg_nfrac_qx_27_24[3];
+
+	struct idt24x_dividers divs;
+
+	struct dentry *debugfs_dirroot, *debugfs_fileaction, *debugfs_filei2c,
+		*debugfs_map;
+	char dbg_cache[DEBUGFS_BUFFER_LENGTH];
+	struct dentry *debugfs_fileqfreq[4];
+};
+
+#define to_idt24x_output(_hw) \
+	container_of(_hw, struct idt24x_output, hw)
+#define to_clk_idt24x_from_client(_client) \
+	container_of(_client, struct clk_idt24x_chip, i2c_client)
+#define to_clk_idt24x_from_nb(_nb) \
+	container_of(_nb, struct clk_idt24x_chip, input_clk_nb)
+
+/**
+ * struct clk_register_offsets - register offsets for current context
+ * @oe_offset:		offset for current output enable and mode
+ * @oe_mask:		mask for current output enable
+ * @dis_mask:		mask for current output disable
+ * @n_17_16_offset:	offset for current output int divider (bits 17:16)
+ * @n_17_16_mask:	mask for current output int divider (bits 17:16)
+ * @n_15_8_offset:	offset for current output int divider (bits 15:8)
+ * @n_7_0_offset:	offset for current output int divider (bits 7:0)
+ * @nfrac_27_24_offset:	offset for current output frac divider (bits 27:24)
+ * @nfrac_27_24_mask:	mask for current output frac divider (bits 27:24)
+ * @nfrac_23_16_offset:	offset for current output frac divider (bits 23:16)
+ * @nfrac_15_8_offset:	offset for current output frac divider (bits 15:8)
+ * @nfrac_7_0_offset:	offset for current output frac divider (bits 7:0)
+ * @ns1_offset:		offset for stage 1 div for output Q0
+ * @ns1_offset_mask:	mask for stage 1 div for output Q0
+ * @ns2_15_8_offset:	offset for stage 2 div for output Q0 (bits 15:8)
+ * @ns2_7_0_offset:	offset for stage 2 div for output Q0 (bits 7:0)
+ */
+struct clk_register_offsets {
+	u16 oe_offset;
+	u8 oe_mask;
+	u8 dis_mask;
+
+	u16 n_17_16_offset;
+	u8 n_17_16_mask;
+	u16 n_15_8_offset;
+	u16 n_7_0_offset;
+	u16 nfrac_27_24_offset;
+	u8 nfrac_27_24_mask;
+	u16 nfrac_23_16_offset;
+	u16 nfrac_15_8_offset;
+	u16 nfrac_7_0_offset;
+
+	u16 ns1_offset;
+	u8 ns1_offset_mask;
+	u16 ns2_15_8_offset;
+	u16 ns2_7_0_offset;
+};
+
+int bits_to_shift(unsigned int mask);
+int i2cwritebulk(
+	struct i2c_client *client, struct regmap *map,
+	unsigned int reg, u8 val[], size_t val_count);
+int idt24x_get_offsets(
+	u8 output_num,
+	struct clk_register_offsets *offsets);
+int idt24x_set_frequency(struct clk_idt24x_chip *chip);
+
+#endif /* __IDT_CLK_IDT8T49N24X_CORE_H_ */
diff --git a/drivers/clk/idt/clk-idt8t49n24x-debugfs.c b/drivers/clk/idt/clk-idt8t49n24x-debugfs.c
new file mode 100644
index 000000000..5767ffa12
--- /dev/null
+++ b/drivers/clk/idt/clk-idt8t49n24x-debugfs.c
@@ -0,0 +1,375 @@
+// SPDX-License-Identifier: GPL-2.0
+/* clk-idt8t49n24x-debugfs.c - Debugfs support for 8T49N24x
+ *
+ * Copyright (C) 2018, Integrated Device Technology, Inc. <david.cater@idt.com>
+ *
+ * See https://www.gnu.org/licenses/old-licenses/gpl-2.0.en.html
+ * This program is distributed "AS IS" and  WITHOUT ANY WARRANTY;
+ * including the implied warranties of MERCHANTABILITY, FITNESS FOR
+ * A PARTICULAR PURPOSE, or NON-INFRINGEMENT.
+ */
+
+#include <linux/debugfs.h>
+#include <linux/i2c.h>
+#include <linux/regmap.h>
+#include <linux/slab.h>
+
+#include "clk-idt8t49n24x-debugfs.h"
+
+static struct clk_idt24x_chip *idt24x_chip_fordebugfs;
+
+static int idt24x_read_all_settings(
+	struct clk_idt24x_chip *chip, char *output_buffer, int count)
+{
+	u8 settings[NUM_CONFIG_REGISTERS];
+	int err = 0;
+	int x;
+
+	err = regmap_bulk_read(
+		chip->regmap, 0x0, settings, NUM_CONFIG_REGISTERS);
+	if (!err) {
+		output_buffer[0] = '\0';
+		for (x = 0; x < ARRAY_SIZE(settings); x++) {
+			char dbg[4];
+
+			if ((strlen(output_buffer) + 4) > count)
+				return -EINVAL;
+			sprintf(dbg, "%02x ", settings[x]);
+			strcat(output_buffer, dbg);
+		}
+	}
+	return err;
+}
+
+/**
+ * idt24x_debugfs_writer_action - Write handler for the "action" debugfs file.
+ * @fp:			file pointer
+ * @user_buffer:	buffer of text written to file
+ * @count:		size of text in buffer
+ * @position:		pass in current position, return new position
+ *
+ * Return: result of call to simple_write_to_buffer
+ *
+ * Use the "action" file as a trigger for setting all requested
+ * rates. The driver doesn't get any notification when the files
+ * representing the Qx outputs are written to, so something else is
+ * needed to notify the driver that the device should be udpated.
+ *
+ * It doesn't matter what you write to the action debugs file. When the
+ * handler is called, the device will be updated.
+ */
+static ssize_t idt24x_debugfs_writer_action(
+	struct file *fp, const char __user *user_buffer,
+	size_t count, loff_t *position)
+{
+	int err = 0;
+	int x;
+	u32 freq;
+	bool needs_update = true;
+	struct i2c_client *client = idt24x_chip_fordebugfs->i2c_client;
+
+	if (count > DEBUGFS_BUFFER_LENGTH)
+		return -EINVAL;
+
+	for (x = 0; x < NUM_OUTPUTS; x++) {
+		freq = idt24x_chip_fordebugfs->clk[x].debug_freq;
+		if (freq) {
+			needs_update = false;
+			dev_dbg(&client->dev,
+				"%s: calling clk_set_rate with debug frequency for Q%i",
+				__func__, x);
+			err = clk_set_rate(
+				idt24x_chip_fordebugfs->clk[x].hw.clk, freq);
+			if (err) {
+				dev_err(&client->dev,
+					"error calling clk_set_rate for Q%i (%i)\n",
+					x, err);
+			}
+		} else {
+			needs_update = true;
+			idt24x_chip_fordebugfs->clk[x].requested = 0;
+			dev_dbg(&client->dev,
+				"%s: debug frequency for Q%i not set; make sure clock is disabled",
+				__func__, x);
+		}
+	}
+
+	if (needs_update) {
+		dev_dbg(&client->dev,
+			"%s: calling idt24x_set_frequency to ensure any clocks that should be disabled are turned off.",
+			__func__);
+		err = idt24x_set_frequency(idt24x_chip_fordebugfs);
+		if (err) {
+			dev_err(&idt24x_chip_fordebugfs->i2c_client->dev,
+				"%s: error calling idt24x_set_frequency (%i)\n",
+				__func__, err);
+			return err;
+		}
+	}
+
+	return simple_write_to_buffer(
+		idt24x_chip_fordebugfs->dbg_cache, DEBUGFS_BUFFER_LENGTH,
+		position, user_buffer, count);
+}
+
+/**
+ * idt24x_debugfs_reader_action - Read the "action" debugfs file.
+ * @fp:			file pointer
+ * @user_buffer:	buffer of text written to file
+ * @count:		size of text in buffer
+ * @position:		pass in current position, return new position
+ *
+ * Return: whatever was last written to the "action" debugfs file.
+ */
+static ssize_t idt24x_debugfs_reader_action(
+	struct file *fp, char __user *user_buffer, size_t count,
+	loff_t *position)
+{
+	return simple_read_from_buffer(
+		user_buffer, count, position, idt24x_chip_fordebugfs->dbg_cache,
+		DEBUGFS_BUFFER_LENGTH);
+}
+
+/**
+ * idt24x_debugfs_reader_map - display the current registers on the device
+ * @fp:			file pointer
+ * @user_buffer:	buffer of text written to file
+ * @count:		size of text in buffer
+ * @position:		pass in current position, return new position
+ *
+ * Reads the current register map from the attached chip via I2C and
+ * returns it.
+ *
+ * Return: result of call to simple_read_from_buffer
+ */
+static ssize_t idt24x_debugfs_reader_map(
+	struct file *fp, char __user *user_buffer, size_t count,
+	loff_t *position)
+{
+	int err = 0;
+	char *buf = kzalloc(5000, GFP_KERNEL);
+
+	dev_dbg(&idt24x_chip_fordebugfs->i2c_client->dev,
+		"calling idt24x_read_all_settings (count: %zu)\n", count);
+	err = idt24x_read_all_settings(idt24x_chip_fordebugfs, buf, 5000);
+	if (err) {
+		dev_err(&idt24x_chip_fordebugfs->i2c_client->dev,
+			"error calling idt24x_read_all_settings (%i)\n", err);
+		return 0;
+	}
+	/* TMGCDR-1456. We're returning 1 byte too few. */
+	err = simple_read_from_buffer(
+		user_buffer, count, position, buf, strlen(buf));
+	kfree(buf);
+	return err;
+}
+
+/**
+ * idt24x_handle_i2c_debug_token - process "token" written to the i2c file
+ * @dev:	pointer to device structure
+ * @token:	pointer to current char being examined
+ * @reg:	pass in current register, or return register from token.
+ * @val:	resulting array of bytes being parsed
+ * @nextbyte:	position in val array to store next byte
+ *
+ * Utility function to operate on the current "token" (from within a
+ * space-delimited string) written to the i2c debugfs file. It will
+ * either be a register offset or a byte to be added to the val array.
+ * If it is added to the val array, auto-increment nextbyte.
+ *
+ * Return:	0 for success
+ */
+static int idt24x_handle_i2c_debug_token(
+	const struct device *dev, char *token, unsigned int *reg,
+	u8 val[], u16 *nextbyte)
+{
+	int err = 0;
+
+	dev_dbg(dev, "got token (%s)\n", token);
+	if (*reg == -1) {
+		err = kstrtouint(token, 16, reg);
+		if (!err)
+			dev_dbg(dev, "hex register address == 0x%x\n", *reg);
+	} else {
+		u8 temp;
+
+		err = kstrtou8(token, 16, &temp);
+		if (!err) {
+			dev_dbg(dev, "data byte == 0x%x\n", temp);
+			val[*nextbyte] = temp;
+			*nextbyte += 1;
+		}
+	}
+	if (err == -ERANGE)
+		dev_err(dev, "ERANGE error when parsing data\n");
+	else if (err == -EINVAL)
+		dev_err(dev, "EINVAL error when parsing data\n");
+	else if (err)
+		dev_err(dev, "error when parsing data: %i\n", err);
+	return err;
+}
+
+/**
+ * idt24x_debugfs_writer_i2c - debugfs handler for i2c file
+ * @fp:			file pointer
+ * @user_buffer:	buffer of text written to file
+ * @count:		size of text in buffer
+ * @position:		pass in current position, return new position
+ *
+ * Handler for the "i2c" debugfs file. Write to this file to write bytes
+ * via I2C to a particular offset.
+ *
+ * Usage: echo 006c 01 02 0D FF > i2c
+ *
+ * First 4 chars are the 2-byte i2c register offset. Then follow that
+ * with a sequence of 2-char bytes in hex format that you want to write
+ * starting at that offset.
+ *
+ * Return: result of simple_write_to_buffer
+ */
+static ssize_t idt24x_debugfs_writer_i2c(struct file *fp,
+					 const char __user *user_buffer,
+					 size_t count, loff_t *position)
+{
+	int err = 0;
+	int x = 0;
+	int start = 0;
+	ssize_t written;
+	unsigned int reg = -1;
+	u8 val[WRITE_BLOCK_SIZE];
+	u16 nextbyte = 0;
+	char token[16];
+
+	if (count > DEBUGFS_BUFFER_LENGTH)
+		return -EINVAL;
+
+	written = simple_write_to_buffer(
+		idt24x_chip_fordebugfs->dbg_cache, DEBUGFS_BUFFER_LENGTH,
+		position, user_buffer, count);
+	if (written != count) {
+		dev_dbg(&idt24x_chip_fordebugfs->i2c_client->dev,
+			"write count != expected count");
+		return written;
+	}
+
+	for (x = 0; x < count; x++) {
+		token[x - start] = idt24x_chip_fordebugfs->dbg_cache[x];
+		if (idt24x_chip_fordebugfs->dbg_cache[x] == ' ') {
+			token[x - start] = '\0';
+			err = idt24x_handle_i2c_debug_token(
+				&idt24x_chip_fordebugfs->i2c_client->dev,
+				token, &reg, val, &nextbyte);
+			if (err)
+				break;
+			start = x + 1;
+		}
+	}
+
+	/* handle the last token */
+	if (!err) {
+		token[count - start] = '\0';
+		err = idt24x_handle_i2c_debug_token(
+			&idt24x_chip_fordebugfs->i2c_client->dev, token, &reg,
+			val, &nextbyte);
+	}
+
+	if (!err && reg != -1 && nextbyte > 0) {
+		err = i2cwritebulk(
+			idt24x_chip_fordebugfs->i2c_client,
+			idt24x_chip_fordebugfs->regmap,
+			reg, val, nextbyte);
+		if (err) {
+			dev_err(&idt24x_chip_fordebugfs->i2c_client->dev,
+				"error writing data chip (%i)\n", err);
+			return err;
+		}
+		dev_dbg(&idt24x_chip_fordebugfs->i2c_client->dev,
+			"successfully wrote i2c data to chip");
+	}
+
+	return written;
+}
+
+static const struct file_operations idt24x_fops_debug_action = {
+	.read = idt24x_debugfs_reader_action,
+	.write = idt24x_debugfs_writer_action,
+};
+
+static const struct file_operations idt24x_fops_debug_map = {
+	.read = idt24x_debugfs_reader_map
+};
+
+static const struct file_operations idt24x_fops_debug_i2c = {
+	.write = idt24x_debugfs_writer_i2c,
+};
+
+/**
+ * idt24x_expose_via_debugfs - Set up all debugfs files
+ * @client:	pointer to i2c_client structure
+ * @chip:	Device data structure
+ *
+ * Sets up all debugfs files to use for debugging the driver.
+ * Return: error code. 0 if success or debugfs doesn't appear to be enabled.
+ */
+int idt24x_expose_via_debugfs(struct i2c_client *client,
+			      struct clk_idt24x_chip *chip)
+{
+	int output_num;
+
+	/*
+	 * create root directory in /sys/kernel/debugfs
+	 */
+	chip->debugfs_dirroot = debugfs_create_dir("idt24x", NULL);
+	if (!chip->debugfs_dirroot) {
+		/* debugfs probably not enabled. Don't fail the probe. */
+		return 0;
+	}
+
+	/*
+	 * create files in the root directory. This requires read and
+	 * write file operations
+	 */
+	chip->debugfs_fileaction = debugfs_create_file(
+		"action", 0644, chip->debugfs_dirroot, NULL,
+		&idt24x_fops_debug_action);
+	if (!chip->debugfs_fileaction) {
+		dev_err(&client->dev,
+			"%s: error creating action file", __func__);
+		return (-ENODEV);
+	}
+
+	chip->debugfs_map = debugfs_create_file(
+		"map", 0444, chip->debugfs_dirroot, NULL,
+		&idt24x_fops_debug_map);
+	if (!chip->debugfs_map) {
+		dev_err(&client->dev,
+			"%s: error creating map file", __func__);
+		return (-ENODEV);
+	}
+
+	for (output_num = 0; output_num < NUM_OUTPUTS; output_num++) {
+		char name[5];
+
+		sprintf(name, "q%d", output_num);
+		debugfs_create_u64(name, 0644, chip->debugfs_dirroot,
+				   &chip->clk[output_num].debug_freq);
+	}
+
+	chip->debugfs_filei2c = debugfs_create_file(
+		"i2c", 0644, chip->debugfs_dirroot, NULL,
+		&idt24x_fops_debug_i2c);
+	if (!chip->debugfs_filei2c) {
+		dev_err(&client->dev,
+			"%s: error creating i2c file", __func__);
+		return (-ENODEV);
+	}
+
+	dev_dbg(&client->dev, "%s: success", __func__);
+	idt24x_chip_fordebugfs = chip;
+	return 0;
+}
+
+void idt24x_cleanup_debugfs(struct clk_idt24x_chip *chip)
+{
+	debugfs_remove_recursive(chip->debugfs_dirroot);
+}
diff --git a/drivers/clk/idt/clk-idt8t49n24x-debugfs.h b/drivers/clk/idt/clk-idt8t49n24x-debugfs.h
new file mode 100644
index 000000000..673016c8e
--- /dev/null
+++ b/drivers/clk/idt/clk-idt8t49n24x-debugfs.h
@@ -0,0 +1,21 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* clk-idt8t49n24x-debugfs.h - Debugfs support for 8T49N24x
+ *
+ * Copyright (C) 2018, Integrated Device Technology, Inc. <david.cater@idt.com>
+ *
+ * See https://www.gnu.org/licenses/old-licenses/gpl-2.0.en.html
+ * This program is distributed "AS IS" and  WITHOUT ANY WARRANTY;
+ * including the implied warranties of MERCHANTABILITY, FITNESS FOR
+ * A PARTICULAR PURPOSE, or NON-INFRINGEMENT.
+ */
+
+#ifndef __IDT_CLK_IDT8T49N24X_DEBUGFS_H_
+#define __IDT_CLK_IDT8T49N24X_DEBUGFS_H_
+
+#include "clk-idt8t49n24x-core.h"
+
+int idt24x_expose_via_debugfs(struct i2c_client *client,
+			      struct clk_idt24x_chip *chip);
+void idt24x_cleanup_debugfs(struct clk_idt24x_chip *chip);
+
+#endif /* __IDT_CLK_IDT8T49N24X_DEBUGFS_H_*/
diff --git a/drivers/clk/idt/clk-idt8t49n24x.c b/drivers/clk/idt/clk-idt8t49n24x.c
new file mode 100644
index 000000000..878637986
--- /dev/null
+++ b/drivers/clk/idt/clk-idt8t49n24x.c
@@ -0,0 +1,641 @@
+// SPDX-License-Identifier: GPL-2.0
+/* clk-idt8t49n24x.c - Program 8T49N24x settings via I2C.
+ *
+ * Copyright (C) 2018, Integrated Device Technology, Inc. <david.cater@idt.com>
+ *
+ * See https://www.gnu.org/licenses/old-licenses/gpl-2.0.en.html
+ * This program is distributed "AS IS" and  WITHOUT ANY WARRANTY;
+ * including the implied warranties of MERCHANTABILITY, FITNESS FOR
+ * A PARTICULAR PURPOSE, or NON-INFRINGEMENT.
+ */
+
+#include <linux/i2c.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+
+#include "clk-idt8t49n24x-core.h"
+#include "clk-idt8t49n24x-debugfs.h"
+
+#define OUTPUTMODE_HIGHZ	0
+#define OUTPUTMODE_LVDS		2
+#define IDT24x_MIN_FREQ		1000000L
+#define IDT24x_MAX_FREQ		300000000L
+#define DRV_NAME		"idt8t49n24x"
+
+enum clk_idt24x_variant {
+	idt24x
+};
+
+static u32 mask_and_shift(u32 value, u8 mask)
+{
+	value &= mask;
+	return value >> bits_to_shift(mask);
+}
+
+/**
+ * idt24x_set_output_mode - Set the mode for a particular clock
+ * output in the register.
+ * @reg:	The current register value before setting the mode.
+ * @mask:	The bitmask identifying where in the register the
+ *		output mode is stored.
+ * @mode:	The mode to set.
+ *
+ * Return: the new register value with the specified mode bits set.
+ */
+static int idt24x_set_output_mode(u32 reg, u8 mask, u8 mode)
+{
+	if (((reg & mask) >> bits_to_shift(mask)) == OUTPUTMODE_HIGHZ) {
+		reg = reg & ~mask;
+		reg |= (OUTPUTMODE_LVDS << bits_to_shift(mask));
+	}
+	return reg;
+}
+
+/**
+ * idt24x_read_from_hw - Get the current values on the hw
+ * @chip:	Device data structure
+ *
+ * Return: 0 on success, negative errno otherwise.
+ */
+static int idt24x_read_from_hw(struct clk_idt24x_chip *chip)
+{
+	int err;
+	struct i2c_client *client = chip->i2c_client;
+	u32 tmp, tmp2;
+	u8 output;
+
+	err = regmap_read(chip->regmap, IDT24x_REG_DSM_INT_8,
+			  &chip->reg_dsm_int_8);
+	if (err) {
+		dev_err(&client->dev,
+			"%s: error reading IDT24x_REG_DSM_INT_8: %i",
+			__func__, err);
+		return err;
+	}
+	dev_dbg(&client->dev, "%s: reg_dsm_int_8: 0x%x",
+		__func__, chip->reg_dsm_int_8);
+
+	err = regmap_read(chip->regmap, IDT24x_REG_DSMFRAC_20_16_MASK,
+			  &chip->reg_dsm_frac_20_16);
+	if (err) {
+		dev_err(&client->dev,
+			"%s: error reading IDT24x_REG_DSMFRAC_20_16_MASK: %i",
+			__func__, err);
+		return err;
+	}
+	dev_dbg(&client->dev, "%s: reg_dsm_frac_20_16: 0x%x",
+		__func__, chip->reg_dsm_frac_20_16);
+
+	err = regmap_read(chip->regmap, IDT24x_REG_OUTEN, &chip->reg_out_en_x);
+	if (err) {
+		dev_err(&client->dev,
+			"%s: error reading IDT24x_REG_OUTEN: %i",
+			__func__, err);
+		return err;
+	}
+	dev_dbg(&client->dev, "%s: reg_out_en_x: 0x%x",
+		__func__, chip->reg_out_en_x);
+
+	err = regmap_read(chip->regmap, IDT24x_REG_OUTMODE0_1, &tmp);
+	if (err) {
+		dev_err(&client->dev,
+			"%s: error reading IDT24x_REG_OUTMODE0_1: %i",
+			__func__, err);
+		return err;
+	}
+
+	tmp2 = idt24x_set_output_mode(
+		tmp, IDT24x_REG_OUTMODE0_MASK, OUTPUTMODE_LVDS);
+	tmp2 = idt24x_set_output_mode(
+		tmp2, IDT24x_REG_OUTMODE1_MASK, OUTPUTMODE_LVDS);
+	dev_dbg(&client->dev,
+		"%s: reg_out_mode_0_1 original: 0x%x. After setting OUT0/1 to LVDS if necessary: 0x%x",
+		__func__, tmp, tmp2);
+	chip->reg_out_mode_0_1 = tmp2;
+
+	err = regmap_read(chip->regmap, IDT24x_REG_OUTMODE2_3, &tmp);
+	if (err) {
+		dev_err(&client->dev,
+			"%s: error reading IDT24x_REG_OUTMODE2_3: %i",
+			__func__, err);
+		return err;
+	}
+
+	tmp2 = idt24x_set_output_mode(
+		tmp, IDT24x_REG_OUTMODE2_MASK, OUTPUTMODE_LVDS);
+	tmp2 = idt24x_set_output_mode(
+		tmp2, IDT24x_REG_OUTMODE3_MASK, OUTPUTMODE_LVDS);
+	dev_dbg(&client->dev,
+		"%s: reg_out_mode_2_3 original: 0x%x. After setting OUT2/3 to LVDS if necessary: 0x%x",
+		__func__, tmp, tmp2);
+	chip->reg_out_mode_2_3 = tmp2;
+
+	err = regmap_read(chip->regmap, IDT24x_REG_Q_DIS, &chip->reg_qx_dis);
+	if (err) {
+		dev_err(&client->dev,
+			"%s: error reading IDT24x_REG_Q_DIS: %i",
+			__func__, err);
+		return err;
+	}
+	dev_dbg(&client->dev, "%s: reg_qx_dis: 0x%x",
+		__func__, chip->reg_qx_dis);
+
+	err = regmap_read(chip->regmap, IDT24x_REG_NS1_Q0, &chip->reg_ns1_q0);
+	if (err) {
+		dev_err(&client->dev,
+			"%s: error reading IDT24x_REG_NS1_Q0: %i",
+			__func__, err);
+		return err;
+	}
+	dev_dbg(&client->dev, "%s: reg_ns1_q0: 0x%x",
+		__func__, chip->reg_ns1_q0);
+
+	for (output = 1; output <= 3; output++) {
+		struct clk_register_offsets offsets;
+
+		err = idt24x_get_offsets(output, &offsets);
+		if (err) {
+			dev_err(&client->dev,
+				"%s: error calling idt24x_get_offsets: %i",
+				__func__, err);
+			return err;
+		}
+
+		err = regmap_read(chip->regmap, offsets.n_17_16_offset,
+				  &chip->reg_n_qx_17_16[output - 1]);
+		if (err) {
+			dev_err(&client->dev,
+				"%s: error reading n_17_16_offset for output %d (offset: 0x%x): %i",
+				__func__, output, offsets.n_17_16_offset, err);
+			return err;
+		}
+		dev_dbg(&client->dev,
+			"%s: reg_n_qx_17_16[Q%u]: 0x%x",
+			__func__, output, chip->reg_n_qx_17_16[output - 1]);
+
+		err = regmap_read(chip->regmap, offsets.nfrac_27_24_offset,
+				  &chip->reg_nfrac_qx_27_24[output - 1]);
+		if (err) {
+			dev_err(&client->dev,
+				"%s: error reading nfrac_27_24_offset for output %d (offset: 0x%x): %i",
+				__func__, output,
+				offsets.nfrac_27_24_offset, err);
+			return err;
+		}
+		dev_dbg(&client->dev,
+			"%s: reg_nfrac_qx_27_24[Q%u]: 0x%x",
+			__func__, output,
+			chip->reg_nfrac_qx_27_24[output - 1]);
+	}
+
+	dev_info(&client->dev,
+		 "%s: initial values read from chip successfully",
+		 __func__);
+
+	/* Also read DBL_DIS to determine whether the doubler is disabled. */
+	err = regmap_read(chip->regmap, IDT24x_REG_DBL_DIS, &tmp);
+	if (err) {
+		dev_err(&client->dev,
+			"%s: error reading IDT24x_REG_DBL_DIS: %i",
+			__func__, err);
+		return err;
+	}
+	chip->doubler_disabled = mask_and_shift(tmp, IDT24x_REG_DBL_DIS_MASK);
+	dev_dbg(&client->dev, "%s: doubler_disabled: %d",
+		__func__, chip->doubler_disabled);
+
+	return 0;
+}
+
+/**
+ * idt24x_set_rate - Sets the specified output clock to the specified rate.
+ * @hw:		clk_hw struct that identifies the specific output clock.
+ * @rate:	the rate (in Hz) for the specified clock.
+ * @parent_rate:(not sure) the rate for a parent signal (e.g.,
+ *		the VCO feeding the output)
+ *
+ * This function will call idt24_set_frequency, which means it will
+ * calculate divider for all requested outputs and update the attached
+ * device (issue I2C commands to update the registers).
+ *
+ * Return: 0 on success.
+ */
+static int idt24x_set_rate(struct clk_hw *hw, unsigned long rate,
+			   unsigned long parent_rate)
+{
+	int err = 0;
+
+	/*
+	 * hw->clk is the pointer to the specific output clock the user is
+	 * requesting. We use hw to get back to the output structure for
+	 * the output clock. Set the requested rate in the output structure.
+	 * Note that container_of cannot be used to find the device structure
+	 * (clk_idt24x_chip) from clk_hw, because clk_idt24x_chip has an array
+	 * of idt24x_output structs. That is why it is necessary to use
+	 * output->chip to access the device structure.
+	 */
+	struct idt24x_output *output = to_idt24x_output(hw);
+	struct i2c_client *client = output->chip->i2c_client;
+
+	if (rate < output->chip->min_freq || rate > output->chip->max_freq) {
+		dev_err(&client->dev,
+			"requested frequency (%luHz) is out of range\n", rate);
+		return -EINVAL;
+	}
+
+	/*
+	 * Set the requested frequency in the output data structure, and then
+	 * call idt24x_set_frequency. idt24x_set_frequency considers all
+	 * requested frequencies when deciding on a vco frequency and
+	 * calculating dividers.
+	 */
+	output->requested = rate;
+
+	/*
+	 * Also set in the memory location used by the debugfs file
+	 * that exposes the output clock frequency. That allows querying
+	 * the current rate via debugfs.
+	 */
+	output->debug_freq = rate;
+
+	dev_info(&client->dev,
+		 "%s. calling idt24x_set_frequency for Q%u. rate: %lu",
+		 __func__, output->index, rate);
+	err = idt24x_set_frequency(output->chip);
+
+	if (err != 0)
+		dev_err(&client->dev, "error calling set_frequency: %d", err);
+
+	return err;
+}
+
+/**
+ * idt24x_round_rate - get valid rate that is closest to the requested rate
+ * @hw:		clk_hw struct that identifies the specific output clock.
+ * @rate:	the rate (in Hz) for the specified clock.
+ * @parent_rate:(not sure) the rate for a parent signal (e.g., the VCO
+ *		feeding the output). This is an i/o param.
+ *		If the driver supports a parent clock for the output (e.g.,
+ *		the VCO(?), then set this param to indicate what the rate of
+ *		the parent would be (e.g., the VCO frequency) if the rounded
+ *		rate is used.
+ *
+ * Returns the closest rate to the requested rate actually supported by the
+ * chip.
+ *
+ * Return: adjusted rate
+ */
+static long idt24x_round_rate(struct clk_hw *hw, unsigned long rate,
+			      unsigned long *parent_rate)
+{
+	/*
+	 * The chip has fractional output dividers, so assume it
+	 * can provide the requested rate.
+	 *
+	 * TODO: figure out the closest rate that chip can support
+	 * within a low error threshold and return that rate.
+	 */
+	return rate;
+}
+
+/**
+ * idt24x_recalc_rate - return the frequency being provided by the clock.
+ * @hw:			clk_hw struct that identifies the specific output clock.
+ * @parent_rate:	(not sure) the rate for a parent signal (e.g., the
+ *			VCO feeding the output)
+ *
+ * This API appears to be used to read the current values from the hardware
+ * and report the frequency being provided by the clock. Without this function,
+ * the clock will be initialized to 0 by default. The OS appears to be
+ * calling this to find out what the current value of the clock is at
+ * startup, so it can determine when .set_rate is actually changing the
+ * frequency.
+ *
+ * Return: the frequency of the specified clock.
+ */
+static unsigned long idt24x_recalc_rate(struct clk_hw *hw,
+					unsigned long parent_rate)
+{
+	struct idt24x_output *output = to_idt24x_output(hw);
+
+	return output->requested;
+}
+
+/*
+ * Note that .prepare and .unprepare appear to be used more in Gates.
+ * They do not appear to be necessary for this device.
+ * Instead, update the device when .set_rate is called.
+ */
+static const struct clk_ops idt24x_clk_ops = {
+	.recalc_rate = idt24x_recalc_rate,
+	.round_rate = idt24x_round_rate,
+	.set_rate = idt24x_set_rate,
+};
+
+static bool idt24x_regmap_is_volatile(struct device *dev, unsigned int reg)
+{
+	return false;
+}
+
+static bool idt24x_regmap_is_writeable(struct device *dev, unsigned int reg)
+{
+	return true;
+}
+
+static const struct regmap_config idt24x_regmap_config = {
+	.reg_bits = 16,
+	.val_bits = 8,
+	.cache_type = REGCACHE_RBTREE,
+	.max_register = 0xffff,
+	.writeable_reg = idt24x_regmap_is_writeable,
+	.volatile_reg = idt24x_regmap_is_volatile,
+};
+
+/**
+ * idt24x_clk_notifier_cb - Clock rate change callback
+ * @nb:		Pointer to notifier block
+ * @event:	Notification reason
+ * @data:	Pointer to notification data object
+ *
+ * This function is called when the input clock frequency changes.
+ * The callback checks whether a valid bus frequency can be generated after the
+ * change. If so, the change is acknowledged, otherwise the change is aborted.
+ * New dividers are written to the HW in the pre- or post change notification
+ * depending on the scaling direction.
+ *
+ * Return:	NOTIFY_STOP if the rate change should be aborted, NOTIFY_OK
+ *		to acknowledge the change, NOTIFY_DONE if the notification is
+ *		considered irrelevant.
+ */
+static int idt24x_clk_notifier_cb(struct notifier_block *nb,
+				  unsigned long event, void *data)
+{
+	struct clk_notifier_data *ndata = data;
+	struct clk_idt24x_chip *chip = to_clk_idt24x_from_nb(nb);
+	int err = 0;
+
+	dev_info(&chip->i2c_client->dev,
+		 "%s: input frequency changed: %lu Hz. event: %lu",
+		 __func__, ndata->new_rate, event);
+
+	switch (event) {
+	case PRE_RATE_CHANGE: {
+		dev_dbg(&chip->i2c_client->dev, "PRE_RATE_CHANGE\n");
+		return NOTIFY_OK;
+	}
+	case POST_RATE_CHANGE:
+		chip->input_clk_freq = ndata->new_rate;
+		/*
+		 * Can't call clock API clk_set_rate here; I believe
+		 * it will be ignored if the rate is the same as we
+		 * set previously. Need to call our internal function.
+		 */
+		dev_dbg(&chip->i2c_client->dev,
+			"POST_RATE_CHANGE. Calling idt24x_set_frequency\n");
+		err = idt24x_set_frequency(chip);
+		if (err)
+			dev_err(&chip->i2c_client->dev,
+				"error calling idt24x_set_frequency (%i)\n",
+				err);
+		return NOTIFY_OK;
+	case ABORT_RATE_CHANGE:
+		return NOTIFY_OK;
+	default:
+		return NOTIFY_DONE;
+	}
+}
+
+static struct clk_hw *of_clk_idt24x_get(
+	struct of_phandle_args *clkspec, void *_data)
+{
+	struct clk_idt24x_chip *chip = _data;
+	unsigned int idx = clkspec->args[0];
+
+	if (idx >= ARRAY_SIZE(chip->clk)) {
+		pr_err("%s: invalid index %u\n", __func__, idx);
+		return ERR_PTR(-EINVAL);
+	}
+
+	return &chip->clk[idx].hw;
+}
+
+/**
+ * idt24x_probe - main entry point for ccf driver
+ * @client:	pointer to i2c_client structure
+ * @id:		pointer to i2c_device_id structure
+ *
+ * Main entry point function that gets called to initialize the driver.
+ *
+ * Return: 0 for success.
+ */
+static int idt24x_probe(struct i2c_client *client,
+			const struct i2c_device_id *id)
+{
+	struct clk_idt24x_chip *chip;
+	struct clk_init_data init;
+
+	int err = 0;
+	int x;
+	char buf[6];
+
+	dev_info(&client->dev, "%s", __func__);
+	chip = devm_kzalloc(&client->dev, sizeof(*chip), GFP_KERNEL);
+	if (!chip)
+		return -ENOMEM;
+
+	init.ops = &idt24x_clk_ops;
+	init.flags = 0;
+	init.num_parents = 0;
+	chip->i2c_client = client;
+
+	chip->min_freq = IDT24x_MIN_FREQ;
+	chip->max_freq = IDT24x_MAX_FREQ;
+
+	for (x = 0; x < NUM_INPUTS + 1; x++) {
+		char name[12];
+
+		sprintf(name, x == NUM_INPUTS ? "input-xtal" : "input-clk%i",
+			x);
+		dev_dbg(&client->dev, "attempting to get %s", name);
+		chip->input_clk = devm_clk_get(&client->dev, name);
+		if (IS_ERR(chip->input_clk)) {
+			err = PTR_ERR(chip->input_clk);
+			/*
+			 * TODO: Handle EPROBE_DEFER error, which indicates
+			 * that the input_clk isn't available now but may be
+			 * later when the appropriate module is loaded.
+			 */
+		} else {
+			err = 0;
+			chip->input_clk_num = x;
+			break;
+		}
+	}
+
+	if (err) {
+		dev_err(&client->dev, "Unable to get input clock (%u).", err);
+		chip->input_clk = NULL;
+		return err;
+	}
+
+	chip->input_clk_freq = clk_get_rate(chip->input_clk);
+	dev_dbg(&client->dev, "Got input-freq from input-clk in device tree: %uHz",
+		chip->input_clk_freq);
+
+	chip->input_clk_nb.notifier_call = idt24x_clk_notifier_cb;
+	if (clk_notifier_register(chip->input_clk, &chip->input_clk_nb))
+		dev_warn(&client->dev,
+			 "Unable to register clock notifier for input_clk.");
+
+	dev_dbg(&client->dev, "%s: about to read settings: %zu",
+		__func__, ARRAY_SIZE(chip->settings));
+
+	err = of_property_read_u8_array(
+		client->dev.of_node, "settings", chip->settings,
+		ARRAY_SIZE(chip->settings));
+	if (!err) {
+		dev_dbg(&client->dev, "settings property specified in DT");
+		chip->has_settings = true;
+	} else {
+		if (err == -EOVERFLOW) {
+			dev_alert(&client->dev,
+				  "EOVERFLOW error trying to read the settings. ARRAY_SIZE: %zu",
+				  ARRAY_SIZE(chip->settings));
+			return err;
+		}
+		dev_dbg(&client->dev,
+			"settings property not specified in DT (or there was an error that can be ignored: %i). The settings property is optional.",
+			err);
+	}
+
+	/*
+	 * Requested output frequencies cannot be specified in the DT.
+	 * Either a consumer needs to use the clock API to request the rate,
+	 * or use debugfs to set the rate from user space. Use clock-names in
+	 * DT to specify the output clock.
+	 */
+
+	chip->regmap = devm_regmap_init_i2c(client, &idt24x_regmap_config);
+	if (IS_ERR(chip->regmap)) {
+		dev_err(&client->dev, "failed to allocate register map\n");
+		return PTR_ERR(chip->regmap);
+	}
+
+	dev_dbg(&client->dev, "%s: call i2c_set_clientdata", __func__);
+	i2c_set_clientdata(client, chip);
+
+	if (chip->has_settings) {
+		/*
+		 * A raw settings array was specified in the DT. Write the
+		 * settings to the device immediately.
+		 */
+		err = i2cwritebulk(
+			chip->i2c_client, chip->regmap, 0, chip->settings,
+			ARRAY_SIZE(chip->settings));
+		if (err) {
+			dev_err(&client->dev,
+				"error writing all settings to chip (%i)\n",
+				err);
+			return err;
+		}
+		dev_dbg(&client->dev, "successfully wrote full settings array");
+	}
+
+	/*
+	 * Whether or not settings were written to the device, read all
+	 * current values from the hw.
+	 */
+	dev_dbg(&client->dev, "read from HW");
+	err = idt24x_read_from_hw(chip);
+	if (err) {
+		dev_err(&client->dev,
+			"failed calling idt24x_read_from_hw (%i)\n", err);
+		return err;
+	}
+
+	/* Create all 4 clocks */
+	for (x = 0; x < NUM_OUTPUTS; x++) {
+		init.name = kasprintf(
+			GFP_KERNEL, "%s.Q%i", client->dev.of_node->name, x);
+		chip->clk[x].chip = chip;
+		chip->clk[x].hw.init = &init;
+		chip->clk[x].index = x;
+		err = devm_clk_hw_register(&client->dev, &chip->clk[x].hw);
+		kfree(init.name); /* clock framework made a copy of the name */
+		if (err) {
+			dev_err(&client->dev, "clock registration failed\n");
+			return err;
+		}
+		dev_dbg(&client->dev, "successfully registered Q%i", x);
+	}
+
+	if (err) {
+		dev_err(&client->dev, "clock registration failed\n");
+		return err;
+	}
+
+	err = of_clk_add_hw_provider(
+		client->dev.of_node, of_clk_idt24x_get, chip);
+	if (err) {
+		dev_err(&client->dev, "unable to add clk provider\n");
+		return err;
+	}
+
+	err = idt24x_expose_via_debugfs(client, chip);
+	if (err) {
+		dev_err(&client->dev,
+			"error calling idt24x_expose_via_debugfs: %i\n", err);
+		return err;
+	}
+
+	if (chip->input_clk_num == NUM_INPUTS)
+		sprintf(buf, "XTAL");
+	else
+		sprintf(buf, "CLK%i", chip->input_clk_num);
+	dev_info(&client->dev, "probe success. input freq: %uHz (%s), settings string? %s\n",
+		 chip->input_clk_freq, buf,
+		 chip->has_settings ? "true" : "false");
+	return 0;
+}
+
+static int idt24x_remove(struct i2c_client *client)
+{
+	struct clk_idt24x_chip *chip = to_clk_idt24x_from_client(&client);
+
+	dev_info(&client->dev, "%s", __func__);
+	of_clk_del_provider(client->dev.of_node);
+	idt24x_cleanup_debugfs(chip);
+
+	if (!chip->input_clk)
+		clk_notifier_unregister(
+			chip->input_clk, &chip->input_clk_nb);
+	return 0;
+}
+
+static const struct i2c_device_id idt24x_id[] = {
+	{ "idt8t49n24x", idt24x },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, idt24x_id);
+
+static const struct of_device_id idt24x_of_match[] = {
+	{ .compatible = "idt,idt8t49n241" },
+	{},
+};
+MODULE_DEVICE_TABLE(of, idt24x_of_match);
+
+static struct i2c_driver idt24x_driver = {
+	.driver = {
+		.name = DRV_NAME,
+		.of_match_table = idt24x_of_match,
+	},
+	.probe = idt24x_probe,
+	.remove = idt24x_remove,
+	.id_table = idt24x_id,
+};
+
+module_i2c_driver(idt24x_driver);
+
+MODULE_DESCRIPTION("8T49N24x ccf driver");
+MODULE_AUTHOR("David Cater <david.cater@idt.com>");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/clk/si5324.h b/drivers/clk/si5324.h
new file mode 100644
index 000000000..b3826e7b2
--- /dev/null
+++ b/drivers/clk/si5324.h
@@ -0,0 +1,68 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Si5324 clock generator platform data
+ *
+ * Copyright (C) 2017-2018 Xilinx, Inc.
+ */
+
+#ifndef __LINUX_PLATFORM_DATA_SI5324_H__
+#define __LINUX_PLATFORM_DATA_SI5324_H__
+
+/**
+ * enum si5324_pll_src - Si5324 pll clock source
+ *
+ * @SI5324_PLL_SRC_DEFAULT:	Default, do not change eeprom config
+ * @SI5324_PLL_SRC_XTAL:	Pll source clock is XTAL input
+ * @SI5324_PLL_SRC_CLKIN1:	Pll source clock is CLKIN1 input
+ * @SI5324_PLL_SRC_CLKIN2:	Pll source clock is CLKIN2 input
+ *
+ * Defines enums for clock sources.
+ */
+enum si5324_pll_src {
+	SI5324_PLL_SRC_XTAL = 0,
+	SI5324_PLL_SRC_CLKIN1 = 1,
+	SI5324_PLL_SRC_CLKIN2 = 2,
+};
+
+/**
+ * enum si5324_drive_strength - Si5324 clock output drive strength
+ *
+ * @SI5324_DRIVE_DEFAULT:	Default, do not change eeprom config
+ * @SI5324_DRIVE_2MA:		2mA clock output drive strength
+ * @SI5324_DRIVE_4MA:		4mA clock output drive strength
+ * @SI5324_DRIVE_6MA:		6mA clock output drive strength
+ * @SI5324_DRIVE_8MA:		8mA clock output drive strength
+ *
+ * Defines enums for drive strength
+ */
+enum si5324_drive_strength {
+	SI5324_DRIVE_DEFAULT = 0,
+	SI5324_DRIVE_2MA = 2,
+	SI5324_DRIVE_4MA = 4,
+	SI5324_DRIVE_6MA = 6,
+	SI5324_DRIVE_8MA = 8,
+};
+
+/**
+ * struct si5324_clkout_config - Si5324 clock output configuration
+ *
+ * @drive:	output drive strength
+ * @rate:	clkout rate
+ */
+struct si5324_clkout_config {
+	enum si5324_drive_strength drive;
+	unsigned long rate;
+};
+
+/**
+ * struct si5324_platform_data - Platform data for the Si5324 clock driver
+ *
+ * @pll_src:	Pll source clock setting
+ * @clkout:	Array of clkout configuration
+ */
+struct si5324_platform_data {
+	enum si5324_pll_src pll_src;
+	struct si5324_clkout_config clkout[2];
+};
+
+#endif
diff --git a/drivers/clk/si5324drv.c b/drivers/clk/si5324drv.c
new file mode 100644
index 000000000..622ec6efd
--- /dev/null
+++ b/drivers/clk/si5324drv.c
@@ -0,0 +1,383 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Si5324 clock driver
+ *
+ * Copyright (C) 2017-2018 Xilinx, Inc.
+ *
+ * Author:	Venkateshwar Rao G <vgannava.xilinx.com>
+ *		Leon Woestenberg <leon@sidebranch.com>
+ */
+
+#include <linux/module.h>
+#include <linux/types.h>
+#include "si5324drv.h"
+
+/**
+ * si5324_rate_approx - Find closest rational approximation N2_LS/N3 fraction.
+ *
+ * @f:		Holds the N2_LS/N3 fraction in 36.28 fixed point notation.
+ * @md:		Holds the maximum denominator (N3) value allowed.
+ * @num:	Store the numinator (N2_LS) found.
+ * @denom:	Store the denominator (N3) found.
+ *
+ * This function finds the closest rational approximation.
+ * It allows only n/1 solution and as a part of the calculation
+ * multiply fraction until no digits after the decimal point and
+ * continued fraction and check denominator at each step.
+ */
+void si5324_rate_approx(u64 f, u64 md, u32 *num, u32 *denom)
+{
+	u64 a, h[3] = { 0, 1, 0 }, k[3] = { 1, 0, 0 };
+	u64 x, d, m, n = 1;
+	int i = 0;
+
+	if (md <= 1) {
+		*denom = 1;
+		*num = (u32)(f >> 28);
+		return;
+	}
+
+	n <<= 28;
+	for (i = 0; i < 28; i++) {
+		if ((f & 0x1) == 0) {
+			n >>= 1;
+			f >>= 1;
+		} else {
+			break;
+		}
+	}
+	d = f;
+
+	for (i = 0; i < 64; i++) {
+		a = n ? (div64_u64(d, n)) : 0;
+		if (i && !a)
+			break;
+		x = d;
+		d = n;
+		div64_u64_rem(x, n, &m);
+		n = m;
+		x = a;
+		if (k[1] * a + k[0] >= md) {
+			x = div64_u64((md - k[0]), k[1]);
+			if (x * 2 >= a || k[1] >= md)
+				i = 65;
+			else
+				break;
+		}
+		h[2] = x * h[1] + h[0];
+		h[0] = h[1];
+		h[1] = h[2];
+		k[2] = x * k[1] + k[0];
+		k[0] = k[1];
+		k[1] = k[2];
+	}
+
+	*denom = (u32)k[1];
+	*num = (u32)h[1];
+}
+
+/**
+ * si5324_find_n2ls - Search through the possible settings for the N2_LS.
+ *
+ * @settings:	Holds the settings up till now.
+ *
+ * This function finds the best setting for N2_LS and N3n with the values
+ * for N1_HS, NCn_LS, and N2_HS.
+ *
+ * Return:	1 when the best possible result has been found, 0 on failure.
+ */
+static int si5324_find_n2ls(struct si5324_settingst *settings)
+{
+	u32 result = 0;
+	u64 f3_actual;
+	u64 fosc_actual;
+	u64 fout_actual;
+	u64 delta_fout;
+	u64 n2_ls_div_n3, mult_res;
+	u32 mult;
+
+	n2_ls_div_n3 = div64_u64(div64_u64(div64_u64(settings->fosc,
+			(settings->fin >> SI5324_FIN_FOUT_SHIFT)),
+			(u64)settings->n2_hs), (u64)2);
+
+	si5324_rate_approx(n2_ls_div_n3, settings->n31_max, &settings->n2_ls,
+				&settings->n31);
+	settings->n2_ls *= 2;
+
+	if (settings->n2_ls < settings->n2_ls_min) {
+		mult = div64_u64(settings->n2_ls_min, settings->n2_ls);
+		div64_u64_rem(settings->n2_ls_min, settings->n2_ls, &mult_res);
+		mult = mult_res ? mult + 1 : mult;
+		settings->n2_ls *= mult;
+		settings->n31 *= mult;
+	}
+
+	if (settings->n31 < settings->n31_min) {
+		mult = div64_u64(settings->n31_min, settings->n31);
+		div64_u64_rem(settings->n31_min, settings->n31, &mult_res);
+		mult = mult_res ? mult + 1 : mult;
+		settings->n2_ls *= mult;
+		settings->n31 *= mult;
+	}
+	pr_debug("Trying N2_LS = %d N3 = %d.\n", settings->n2_ls,
+		 settings->n31);
+
+	if (settings->n2_ls < settings->n2_ls_min ||
+	    settings->n2_ls > settings->n2_ls_max) {
+		pr_info("N2_LS out of range.\n");
+	} else if ((settings->n31 < settings->n31_min) ||
+		   (settings->n31 > settings->n31_max)) {
+		pr_info("N3 out of range.\n");
+	} else {
+		f3_actual = div64_u64(settings->fin, settings->n31);
+		fosc_actual = f3_actual * settings->n2_hs * settings->n2_ls;
+		fout_actual = div64_u64(fosc_actual,
+					(settings->n1_hs * settings->nc1_ls));
+		delta_fout = fout_actual - settings->fout;
+
+		if ((f3_actual < ((u64)SI5324_F3_MIN) <<
+			SI5324_FIN_FOUT_SHIFT) ||
+			(f3_actual > ((u64)SI5324_F3_MAX) <<
+			SI5324_FIN_FOUT_SHIFT)) {
+			pr_debug("F3 frequency out of range.\n");
+		} else if ((fosc_actual < ((u64)SI5324_FOSC_MIN) <<
+				SI5324_FIN_FOUT_SHIFT) ||
+				(fosc_actual > ((u64)SI5324_FOSC_MAX) <<
+				SI5324_FIN_FOUT_SHIFT)) {
+			pr_debug("Fosc frequency out of range.\n");
+		} else if ((fout_actual < ((u64)SI5324_FOUT_MIN) <<
+				SI5324_FIN_FOUT_SHIFT) ||
+				(fout_actual > ((u64)SI5324_FOUT_MAX) <<
+				SI5324_FIN_FOUT_SHIFT)) {
+			pr_debug("Fout frequency out of range.\n");
+		} else {
+			u64 divident = fosc_actual >> SI5324_FIN_FOUT_SHIFT;
+
+			pr_debug("Found solution: fout = %dHz delta = %dHz.\n",
+				 (u32)(fout_actual >> SI5324_FIN_FOUT_SHIFT),
+				 (u32)(delta_fout >> SI5324_FIN_FOUT_SHIFT));
+			pr_debug("fosc = %dkHz f3 = %dHz.\n",
+				 (u32)(do_div(divident, 1000)),
+				 (u32)(f3_actual >> SI5324_FIN_FOUT_SHIFT));
+
+			if (((u64)abs(delta_fout)) <
+				settings->best_delta_fout) {
+				settings->best_n1_hs = settings->n1_hs;
+				settings->best_nc1_ls = settings->nc1_ls;
+				settings->best_n2_hs = settings->n2_hs;
+				settings->best_n2_ls = settings->n2_ls;
+				settings->best_n3 = settings->n31;
+				settings->best_fout = fout_actual;
+				settings->best_delta_fout = abs(delta_fout);
+				if (delta_fout == 0)
+					result = 1;
+			}
+		}
+	}
+	return result;
+}
+
+/**
+ * si5324_find_n2 - Find a valid setting for N2_HS and N2_LS.
+ *
+ * @settings:	Holds the settings up till now.
+ *
+ * This function finds a valid settings for N2_HS and N2_LS. Iterates over
+ * all possibilities of N2_HS and then performs a binary search over the
+ * N2_LS values.
+ *
+ * Return:	1 when the best possible result has been found.
+ */
+static int si5324_find_n2(struct si5324_settingst *settings)
+{
+	u32 result = 0;
+
+	for (settings->n2_hs = SI5324_N2_HS_MAX; settings->n2_hs >=
+		SI5324_N2_HS_MIN; settings->n2_hs--) {
+		pr_debug("Trying N2_HS = %d.\n", settings->n2_hs);
+		settings->n2_ls_min = (u32)(div64_u64(settings->fosc,
+					((u64)(SI5324_F3_MAX * settings->n2_hs)
+						<< SI5324_FIN_FOUT_SHIFT)));
+
+		if (settings->n2_ls_min < SI5324_N2_LS_MIN)
+			settings->n2_ls_min = SI5324_N2_LS_MIN;
+
+		settings->n2_ls_max = (u32)(div64_u64(settings->fosc,
+					((u64)(SI5324_F3_MIN *
+					settings->n2_hs) <<
+					SI5324_FIN_FOUT_SHIFT)));
+		if (settings->n2_ls_max > SI5324_N2_LS_MAX)
+			settings->n2_ls_max = SI5324_N2_LS_MAX;
+
+		result = si5324_find_n2ls(settings);
+		if (result)
+			break;
+	}
+	return result;
+}
+
+/**
+ * si5324_calc_ncls_limits - Calculates the valid range for NCn_LS.
+ *
+ * @settings:	Holds the input and output frequencies and the setting
+ * for N1_HS.
+ *
+ * This function calculates the valid range for NCn_LS with the value
+ * for the output frequency and N1_HS already set in settings.
+ *
+ * Return:	-1 when there are no valid settings, 0 otherwise.
+ */
+int si5324_calc_ncls_limits(struct si5324_settingst *settings)
+{
+	settings->nc1_ls_min = div64_u64(settings->n1_hs_min,
+					 settings->n1_hs);
+
+	if (settings->nc1_ls_min < SI5324_NC_LS_MIN)
+		settings->nc1_ls_min = SI5324_NC_LS_MIN;
+	if (settings->nc1_ls_min > 1 &&	(settings->nc1_ls_min & 0x1) == 1)
+		settings->nc1_ls_min++;
+	settings->nc1_ls_max = div64_u64(settings->n1_hs_max, settings->n1_hs);
+
+	if (settings->nc1_ls_max > SI5324_NC_LS_MAX)
+		settings->nc1_ls_max = SI5324_NC_LS_MAX;
+
+	if ((settings->nc1_ls_max & 0x1) == 1)
+		settings->nc1_ls_max--;
+	if ((settings->nc1_ls_max * settings->n1_hs < settings->n1_hs_min) ||
+	    (settings->nc1_ls_min * settings->n1_hs > settings->n1_hs_max))
+		return -1;
+
+	return 0;
+}
+
+/**
+ * si5324_find_ncls - Find a valid setting for NCn_LS
+ *
+ * @settings:	Holds the input and output frequencies, the setting for
+ * N1_HS, and the limits for NCn_LS.
+ *
+ * This function find a valid setting for NCn_LS that can deliver the correct
+ * output frequency. Assumes that the valid range is relatively small
+ * so a full search can be done (should be true for video clock frequencies).
+ *
+ * Return:	1 when the best possible result has been found.
+ */
+static int si5324_find_ncls(struct si5324_settingst *settings)
+{
+	u64 fosc_1;
+	u32 result;
+
+	fosc_1 = settings->fout * settings->n1_hs;
+	for (settings->nc1_ls = settings->nc1_ls_min;
+		settings->nc1_ls <= settings->nc1_ls_max;) {
+		settings->fosc = fosc_1 * settings->nc1_ls;
+		pr_debug("Trying NCn_LS = %d: fosc = %dkHz.\n",
+			 settings->nc1_ls,
+			 (u32)(div64_u64((settings->fosc >>
+				SI5324_FIN_FOUT_SHIFT), 1000)));
+
+		result = si5324_find_n2(settings);
+		if (result)
+			break;
+		if (settings->nc1_ls == 1)
+			settings->nc1_ls++;
+		else
+			settings->nc1_ls += 2;
+	}
+	return result;
+}
+
+/**
+ * si5324_calcfreqsettings - Calculate the frequency settings
+ *
+ * @clkinfreq:	Frequency of the input clock.
+ * @clkoutfreq:	Desired output clock frequency.
+ * @clkactual:	Actual clock frequency.
+ * @n1_hs:	Set to the value for the N1_HS register.
+ * @ncn_ls:	Set to the value for the NCn_LS register.
+ * @n2_hs:	Set to the value for the N2_HS register.
+ * @n2_ls:	Set to the value for the N2_LS register.
+ * @n3n:	Set to the value for the N3n register.
+ * @bwsel:	Set to the value for the BW_SEL register.
+ *
+ * This funciton calculates the frequency settings for the desired output
+ * frequency.
+ *
+ * Return:	SI5324_SUCCESS for success, SI5324_ERR_FREQ when the
+ * requested frequency cannot be generated.
+ */
+int si5324_calcfreqsettings(u32 clkinfreq, u32 clkoutfreq, u32 *clkactual,
+			    u8 *n1_hs, u32 *ncn_ls, u8 *n2_hs, u32 *n2_ls,
+			    u32 *n3n, u8 *bwsel)
+{
+	struct si5324_settingst settings;
+	int result;
+
+	settings.fin = (u64)clkinfreq << SI5324_FIN_FOUT_SHIFT;
+	settings.fout = (u64)clkoutfreq << SI5324_FIN_FOUT_SHIFT;
+	settings.best_delta_fout = settings.fout;
+
+	settings.n1_hs_min = (int)(div64_u64(SI5324_FOSC_MIN, clkoutfreq));
+	if (settings.n1_hs_min < SI5324_N1_HS_MIN * SI5324_NC_LS_MIN)
+		settings.n1_hs_min = SI5324_N1_HS_MIN * SI5324_NC_LS_MIN;
+
+	settings.n1_hs_max = (int)(div64_u64(SI5324_FOSC_MAX, clkoutfreq));
+	if (settings.n1_hs_max > SI5324_N1_HS_MAX * SI5324_NC_LS_MAX)
+		settings.n1_hs_max = SI5324_N1_HS_MAX * SI5324_NC_LS_MAX;
+
+	settings.n31_min = div64_u64(clkinfreq, SI5324_F3_MAX);
+	if (settings.n31_min < SI5324_N3_MIN)
+		settings.n31_min = SI5324_N3_MIN;
+
+	settings.n31_max = div64_u64(clkinfreq, SI5324_F3_MIN);
+	if (settings.n31_max > SI5324_N3_MAX)
+		settings.n31_max = SI5324_N3_MAX;
+
+	/* Find a valid oscillator frequency with the highest setting of N1_HS
+	 * possible (reduces power)
+	 */
+	for (settings.n1_hs = SI5324_N1_HS_MAX;
+		settings.n1_hs >= SI5324_N1_HS_MIN; settings.n1_hs--) {
+		pr_debug("Trying N1_HS = %d.\n", settings.n1_hs);
+
+		result = si5324_calc_ncls_limits(&settings);
+		if (result) {
+			pr_debug("No valid settings\n");
+			continue;
+		}
+		result = si5324_find_ncls(&settings);
+		if (result)
+			break;
+	}
+
+		pr_debug("Si5324: settings.best_delta_fout = %llu\n",
+			 (unsigned long long)settings.best_delta_fout);
+		pr_debug("Si5324: settings.fout = %llu\n",
+			 (unsigned long long)settings.fout);
+
+	if (settings.best_delta_fout == settings.fout) {
+		pr_debug("Si5324: No valid settings found.");
+		return SI5324_ERR_FREQ;
+	}
+		pr_debug("Si5324: Found solution: fout = %dHz.\n",
+			 (u32)(settings.best_fout >> 28));
+
+	/* Post processing: convert temporary values to actual registers */
+	*n1_hs = (u8)settings.best_n1_hs - 4;
+	*ncn_ls = settings.best_nc1_ls - 1;
+	*n2_hs = (u8)settings.best_n2_hs - 4;
+	*n2_ls = settings.best_n2_ls - 1;
+	*n3n = settings.best_n3 - 1;
+	/*
+	 * How must the bandwidth selection be determined?
+	 * Not all settings will be valid.
+	 * refclk 2, 0xA2, BWSEL_REG=1010 (?)
+	 * free running 2, 0x42, BWSEL_REG=0100 (?)
+	 */
+	*bwsel = 6;
+
+	if (clkactual)
+		*clkactual = (settings.best_fout >> SI5324_FIN_FOUT_SHIFT);
+
+	return SI5324_SUCCESS;
+}
diff --git a/drivers/clk/si5324drv.h b/drivers/clk/si5324drv.h
new file mode 100644
index 000000000..28ea3050d
--- /dev/null
+++ b/drivers/clk/si5324drv.h
@@ -0,0 +1,100 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Si5324 clock driver
+ *
+ * Copyright (C) 2017-2018 Xilinx, Inc.
+ */
+
+#ifndef SI5324DRV_H_
+#define SI5324DRV_H_
+
+#include <linux/types.h>
+
+/******************************************************************************
+ * User settable defines that depend on the specific board design.
+ * The defaults are for the Xilinx KC705 board.
+ *****************************************************************************/
+
+#define SI5324_XTAL_FREQ 114285000UL
+
+/******************************************************************************
+ * Defines independent on the specific board design. Should not be changed.
+ *****************************************************************************/
+
+#define SI5324_SUCCESS		0 /*< Operation was successful */
+#define SI5324_ERR_IIC		-1 /*< IIC error occurred */
+#define SI5324_ERR_FREQ		-2 /*< Could not calculate frequency setting */
+#define SI5324_ERR_PARM		-3 /*< Invalid parameter */
+
+#define SI5324_CLKSRC_CLK1	1 /*< Use clock input 1 */
+#define SI5324_CLKSRC_CLK2	2 /*< Use clock input 2 */
+#define SI5324_CLKSRC_XTAL	3 /*< Use crystal (free running mode) */
+
+#define SI5324_FOSC_MIN		4850000000UL /*< Min oscillator frequency */
+#define SI5324_FOSC_MAX		5670000000UL /*< Max oscillator frequency */
+#define SI5324_F3_MIN		10000 /*< Min phase detector frequency */
+#define SI5324_F3_MAX		2000000 /*< Max phase detector frequency */
+#define SI5324_FIN_MIN		2000 /*< Min input frequency */
+#define SI5324_FIN_MAX		710000000UL /*< Max input frequency */
+#define SI5324_FOUT_MIN		2000 /*< Min output frequency */
+#define SI5324_FOUT_MAX		945000000UL /*< Max output frequency */
+
+#define SI5324_N1_HS_MIN	6
+#define SI5324_N1_HS_MAX	11
+#define SI5324_NC_LS_MIN	1
+#define SI5324_NC_LS_MAX	0x100000
+#define SI5324_N2_HS_MIN	4
+#define SI5324_N2_HS_MAX	11
+#define SI5324_N2_LS_MIN	2 /* even values only */
+#define SI5324_N2_LS_MAX	0x100000
+#define SI5324_N3_MIN		1
+#define SI5324_N3_MAX		0x080000
+#define SI5324_FIN_FOUT_SHIFT	28
+
+struct si5324_settingst {
+	/* high-speed output divider */
+	u32 n1_hs_min;
+	u32 n1_hs_max;
+	u32 n1_hs;
+
+	/* low-speed output divider for clkout1 */
+	u32 nc1_ls_min;
+	u32 nc1_ls_max;
+	u32 nc1_ls;
+
+	/* low-speed output divider for clkout2 */
+	u32 nc2_ls_min;
+	u32 nc2_ls_max;
+	u32 nc2_ls;
+
+	/* high-speed feedback divider (PLL multiplier) */
+	u32 n2_hs;
+	/* low-speed feedback divider (PLL multiplier) */
+	u32 n2_ls_min;
+	u32 n2_ls_max;
+	u32 n2_ls;
+
+	/* input divider for clk1 */
+	u32 n31_min;
+	u32 n31_max;
+	u32 n31;
+
+	u64 fin;
+	u64 fout;
+	u64 fosc;
+	u64 best_delta_fout;
+	u64 best_fout;
+	u32 best_n1_hs;
+	u32 best_nc1_ls;
+	u32 best_n2_hs;
+	u32 best_n2_ls;
+	u32 best_n3;
+};
+
+int si5324_calcfreqsettings(u32 clkinfreq, u32 clkoutfreq, u32 *clkactual,
+			    u8 *n1_hs, u32 *ncn_ls, u8 *n2_hs,
+			    u32 *n2_ls, u32 *n3n, u8 *bwsel);
+void si5324_rate_approx(u64 f, u64 md, u32 *num, u32 *denom);
+int si5324_calc_ncls_limits(struct si5324_settingst *settings);
+
+#endif /* SI5324DRV_H_ */
diff --git a/drivers/clk/zynq/clkc.c b/drivers/clk/zynq/clkc.c
index ffbb9008c..895d9b408 100644
--- a/drivers/clk/zynq/clkc.c
+++ b/drivers/clk/zynq/clkc.c
@@ -37,6 +37,7 @@ static void __iomem *zynq_clkc_base;
 #define SLCR_CAN_MIOCLK_CTRL		(zynq_clkc_base + 0x60)
 #define SLCR_DBG_CLK_CTRL		(zynq_clkc_base + 0x64)
 #define SLCR_PCAP_CLK_CTRL		(zynq_clkc_base + 0x68)
+#define SLCR_TOPSW_CLK_CTRL		(zynq_clkc_base + 0x6c)
 #define SLCR_FPGA0_CLK_CTRL		(zynq_clkc_base + 0x70)
 #define SLCR_621_TRUE			(zynq_clkc_base + 0xc4)
 #define SLCR_SWDT_CLK_SEL		(zynq_clkc_base + 0x204)
@@ -99,6 +100,48 @@ static const char *const gem1_emio_input_names[] __initconst = {
 static const char *const swdt_ext_clk_input_names[] __initconst = {
 	"swdt_ext_clk"};
 
+#ifdef CONFIG_SUSPEND
+static struct clk *iopll_save_parent;
+
+#define TOPSW_CLK_CTRL_DIS_MASK	BIT(0)
+
+int zynq_clk_suspend_early(void)
+{
+	int ret;
+
+	iopll_save_parent = clk_get_parent(clks[iopll]);
+
+	ret = clk_set_parent(clks[iopll], ps_clk);
+	if (ret)
+		pr_info("%s: reparent iopll failed %d\n", __func__, ret);
+
+	return 0;
+}
+
+void zynq_clk_resume_late(void)
+{
+	clk_set_parent(clks[iopll], iopll_save_parent);
+}
+
+void zynq_clk_topswitch_enable(void)
+{
+	u32 reg;
+
+	reg = readl(SLCR_TOPSW_CLK_CTRL);
+	reg &= ~TOPSW_CLK_CTRL_DIS_MASK;
+	writel(reg, SLCR_TOPSW_CLK_CTRL);
+}
+
+void zynq_clk_topswitch_disable(void)
+{
+	u32 reg;
+
+	reg = readl(SLCR_TOPSW_CLK_CTRL);
+	reg |= TOPSW_CLK_CTRL_DIS_MASK;
+	writel(reg, SLCR_TOPSW_CLK_CTRL);
+}
+#endif
+
 static void __init zynq_clk_register_fclk(enum zynq_clk fclk,
 		const char *clk_name, void __iomem *fclk_ctrl_reg,
 		const char **parents, int enable)
@@ -357,14 +400,14 @@ static void __init zynq_clk_setup(struct device_node *np)
 				periph_parents, enable);
 	}
 
-	zynq_clk_register_periph_clk(lqspi, 0, clk_output_name[lqspi], NULL,
-			SLCR_LQSPI_CLK_CTRL, periph_parents, 0);
+	zynq_clk_register_periph_clk(lqspi, clk_max, clk_output_name[lqspi], NULL,
+				     SLCR_LQSPI_CLK_CTRL, periph_parents, 0);
 
-	zynq_clk_register_periph_clk(smc, 0, clk_output_name[smc], NULL,
-			SLCR_SMC_CLK_CTRL, periph_parents, 0);
+	zynq_clk_register_periph_clk(smc, clk_max, clk_output_name[smc], NULL,
+				     SLCR_SMC_CLK_CTRL, periph_parents, 0);
 
-	zynq_clk_register_periph_clk(pcap, 0, clk_output_name[pcap], NULL,
-			SLCR_PCAP_CLK_CTRL, periph_parents, 0);
+	zynq_clk_register_periph_clk(pcap, clk_max, clk_output_name[pcap], NULL,
+				     SLCR_PCAP_CLK_CTRL, periph_parents, 0);
 
 	zynq_clk_register_periph_clk(sdio0, sdio1, clk_output_name[sdio0],
 			clk_output_name[sdio1], SLCR_SDIO_CLK_CTRL,
diff --git a/drivers/clk/zynq/pll.c b/drivers/clk/zynq/pll.c
index dcb2037a9..54f4184de 100644
--- a/drivers/clk/zynq/pll.c
+++ b/drivers/clk/zynq/pll.c
@@ -173,12 +173,12 @@ static const struct clk_ops zynq_pll_ops = {
 
 /**
  * clk_register_zynq_pll() - Register PLL with the clock framework
- * @name	PLL name
- * @parent	Parent clock name
- * @pll_ctrl	Pointer to PLL control register
- * @pll_status	Pointer to PLL status register
- * @lock_index	Bit index to this PLL's lock status bit in @pll_status
- * @lock	Register lock
+ * @name:	PLL name
+ * @parent:	Parent clock name
+ * @pll_ctrl:	Pointer to PLL control register
+ * @pll_status:	Pointer to PLL status register
+ * @lock_index:	Bit index to this PLL's lock status bit in @pll_status
+ * @lock:	Register lock
  * Returns handle to the registered clock.
  */
 struct clk *clk_register_zynq_pll(const char *name, const char *parent,
diff --git a/drivers/clk/zynqmp/Kconfig b/drivers/clk/zynqmp/Kconfig
index 17086059b..00df6be25 100644
--- a/drivers/clk/zynqmp/Kconfig
+++ b/drivers/clk/zynqmp/Kconfig
@@ -2,8 +2,8 @@
 
 config COMMON_CLK_ZYNQMP
 	bool "Support for Xilinx ZynqMP Ultrascale+ clock controllers"
-	depends on ARCH_ZYNQMP || COMPILE_TEST
-	depends on ZYNQMP_FIRMWARE
+	depends on ZYNQMP_FIRMWARE || COMPILE_TEST
+	default ZYNQMP_FIRMWARE
 	help
 	  Support for the Zynqmp Ultrascale clock controller.
 	  It has a dependency on the PMU firmware.
diff --git a/drivers/clk/zynqmp/clk-gate-zynqmp.c b/drivers/clk/zynqmp/clk-gate-zynqmp.c
index 10c9b8893..695feaa82 100644
--- a/drivers/clk/zynqmp/clk-gate-zynqmp.c
+++ b/drivers/clk/zynqmp/clk-gate-zynqmp.c
@@ -121,7 +121,9 @@ struct clk_hw *zynqmp_clk_register_gate(const char *name, u32 clk_id,
 
 	init.name = name;
 	init.ops = &zynqmp_clk_gate_ops;
-	init.flags = nodes->flag;
+
+	init.flags = zynqmp_clk_map_common_ccf_flags(nodes->flag);
+
 	init.parent_names = parents;
 	init.num_parents = 1;
 
diff --git a/drivers/clk/zynqmp/clk-mux-zynqmp.c b/drivers/clk/zynqmp/clk-mux-zynqmp.c
index 06194149b..17afce594 100644
--- a/drivers/clk/zynqmp/clk-mux-zynqmp.c
+++ b/drivers/clk/zynqmp/clk-mux-zynqmp.c
@@ -38,7 +38,7 @@ struct zynqmp_clk_mux {
  * zynqmp_clk_mux_get_parent() - Get parent of clock
  * @hw:		handle between common and hardware-specific interfaces
  *
- * Return: Parent index
+ * Return: Parent index on success or number of parents in case of error
  */
 static u8 zynqmp_clk_mux_get_parent(struct clk_hw *hw)
 {
@@ -50,9 +50,15 @@ static u8 zynqmp_clk_mux_get_parent(struct clk_hw *hw)
 
 	ret = zynqmp_pm_clock_getparent(clk_id, &val);
 
-	if (ret)
+	if (ret) {
 		pr_warn_once("%s() getparent failed for clock: %s, ret = %d\n",
 			     __func__, clk_name, ret);
+		/*
+		 * clk_core_get_parent_by_index() takes num_parents as incorrect
+		 * index which is exactly what I want to return here
+		 */
+		return clk_hw_get_num_parents(hw);
+	}
 
 	return val;
 }
@@ -90,6 +96,27 @@ static const struct clk_ops zynqmp_clk_mux_ro_ops = {
 	.get_parent = zynqmp_clk_mux_get_parent,
 };
 
+static inline unsigned long zynqmp_clk_map_mux_ccf_flags(
+				       const u32 zynqmp_type_flag)
+{
+	unsigned long ccf_flag = 0;
+
+	if (zynqmp_type_flag & ZYNQMP_CLK_MUX_INDEX_ONE)
+		ccf_flag |= CLK_MUX_INDEX_ONE;
+	if (zynqmp_type_flag & ZYNQMP_CLK_MUX_INDEX_BIT)
+		ccf_flag |= CLK_MUX_INDEX_BIT;
+	if (zynqmp_type_flag & ZYNQMP_CLK_MUX_HIWORD_MASK)
+		ccf_flag |= CLK_MUX_HIWORD_MASK;
+	if (zynqmp_type_flag & ZYNQMP_CLK_MUX_READ_ONLY)
+		ccf_flag |= CLK_MUX_READ_ONLY;
+	if (zynqmp_type_flag & ZYNQMP_CLK_MUX_ROUND_CLOSEST)
+		ccf_flag |= CLK_MUX_ROUND_CLOSEST;
+	if (zynqmp_type_flag & ZYNQMP_CLK_MUX_BIG_ENDIAN)
+		ccf_flag |= CLK_MUX_BIG_ENDIAN;
+
+	return ccf_flag;
+}
+
 /**
  * zynqmp_clk_register_mux() - Register a mux table with the clock
  *			       framework
@@ -120,17 +147,19 @@ struct clk_hw *zynqmp_clk_register_mux(const char *name, u32 clk_id,
 		init.ops = &zynqmp_clk_mux_ro_ops;
 	else
 		init.ops = &zynqmp_clk_mux_ops;
-	init.flags = nodes->flag;
+
+	init.flags = zynqmp_clk_map_common_ccf_flags(nodes->flag);
+
 	init.parent_names = parents;
 	init.num_parents = num_parents;
-	mux->flags = nodes->type_flag;
+	mux->flags = zynqmp_clk_map_mux_ccf_flags(nodes->type_flag);
 	mux->hw.init = &init;
 	mux->clk_id = clk_id;
 
 	hw = &mux->hw;
 	ret = clk_hw_register(NULL, hw);
 	if (ret) {
-		kfree(hw);
+		kfree(mux);
 		hw = ERR_PTR(ret);
 	}
 
diff --git a/drivers/clk/zynqmp/clk-zynqmp.h b/drivers/clk/zynqmp/clk-zynqmp.h
index 5beeb41b2..a3cd2f8e8 100644
--- a/drivers/clk/zynqmp/clk-zynqmp.h
+++ b/drivers/clk/zynqmp/clk-zynqmp.h
@@ -10,6 +10,37 @@
 
 #include <linux/firmware/xlnx-zynqmp.h>
 
+/* Common Flags */
+/* must be gated across rate change */
+#define ZYNQMP_CLK_SET_RATE_GATE	BIT(0)
+/* must be gated across re-parent */
+#define ZYNQMP_CLK_SET_PARENT_GATE	BIT(1)
+/* propagate rate change up one level */
+#define ZYNQMP_CLK_SET_RATE_PARENT	BIT(2)
+/* do not gate even if unused */
+#define ZYNQMP_CLK_IGNORE_UNUSED	BIT(3)
+/* don't re-parent on rate change */
+#define ZYNQMP_CLK_SET_RATE_NO_REPARENT	BIT(7)
+/* do not gate, ever */
+#define ZYNQMP_CLK_IS_CRITICAL		BIT(11)
+
+/* Type Flags for divider clock */
+#define ZYNQMP_CLK_DIVIDER_ONE_BASED		BIT(0)
+#define ZYNQMP_CLK_DIVIDER_POWER_OF_TWO		BIT(1)
+#define ZYNQMP_CLK_DIVIDER_ALLOW_ZERO		BIT(2)
+#define ZYNQMP_CLK_DIVIDER_HIWORD_MASK		BIT(3)
+#define ZYNQMP_CLK_DIVIDER_ROUND_CLOSEST	BIT(4)
+#define ZYNQMP_CLK_DIVIDER_READ_ONLY		BIT(5)
+#define ZYNQMP_CLK_DIVIDER_MAX_AT_ZERO		BIT(6)
+
+/* Type Flags for mux clock */
+#define ZYNQMP_CLK_MUX_INDEX_ONE		BIT(0)
+#define ZYNQMP_CLK_MUX_INDEX_BIT		BIT(1)
+#define ZYNQMP_CLK_MUX_HIWORD_MASK		BIT(2)
+#define ZYNQMP_CLK_MUX_READ_ONLY		BIT(3)
+#define ZYNQMP_CLK_MUX_ROUND_CLOSEST		BIT(4)
+#define ZYNQMP_CLK_MUX_BIG_ENDIAN		BIT(5)
+
 enum topology_type {
 	TYPE_INVALID,
 	TYPE_MUX,
@@ -25,6 +56,7 @@ enum topology_type {
  * @type:	Type of topology
  * @flag:	Topology flags
  * @type_flag:	Topology type specific flag
+ * @custom_type_flag: Topology type specific custome flag
  */
 struct clock_topology {
 	u32 type;
@@ -33,6 +65,8 @@ struct clock_topology {
 	u8 custom_type_flag;
 };
 
+unsigned long zynqmp_clk_map_common_ccf_flags(const u32 zynqmp_flag);
+
 struct clk_hw *zynqmp_clk_register_pll(const char *name, u32 clk_id,
 				       const char * const *parents,
 				       u8 num_parents,
diff --git a/drivers/clk/zynqmp/clkc.c b/drivers/clk/zynqmp/clkc.c
index db8d0d716..2c9da6623 100644
--- a/drivers/clk/zynqmp/clkc.c
+++ b/drivers/clk/zynqmp/clkc.c
@@ -271,6 +271,26 @@ static int zynqmp_pm_clock_get_topology(u32 clock_id, u32 index,
 	return ret;
 }
 
+unsigned long zynqmp_clk_map_common_ccf_flags(const u32 zynqmp_flag)
+{
+	unsigned long ccf_flag = 0;
+
+	if (zynqmp_flag & ZYNQMP_CLK_SET_RATE_GATE)
+		ccf_flag |= CLK_SET_RATE_GATE;
+	if (zynqmp_flag & ZYNQMP_CLK_SET_PARENT_GATE)
+		ccf_flag |= CLK_SET_PARENT_GATE;
+	if (zynqmp_flag & ZYNQMP_CLK_SET_RATE_PARENT)
+		ccf_flag |= CLK_SET_RATE_PARENT;
+	if (zynqmp_flag & ZYNQMP_CLK_IGNORE_UNUSED)
+		ccf_flag |= CLK_IGNORE_UNUSED;
+	if (zynqmp_flag & ZYNQMP_CLK_SET_RATE_NO_REPARENT)
+		ccf_flag |= CLK_SET_RATE_NO_REPARENT;
+	if (zynqmp_flag & ZYNQMP_CLK_IS_CRITICAL)
+		ccf_flag |= CLK_IS_CRITICAL;
+
+	return ccf_flag;
+}
+
 /**
  * zynqmp_clk_register_fixed_factor() - Register fixed factor with the
  *					clock framework
@@ -292,6 +312,7 @@ struct clk_hw *zynqmp_clk_register_fixed_factor(const char *name, u32 clk_id,
 	struct zynqmp_pm_query_data qdata = {0};
 	u32 ret_payload[PAYLOAD_ARG_CNT];
 	int ret;
+	unsigned long flag;
 
 	qdata.qid = PM_QID_CLOCK_GET_FIXEDFACTOR_PARAMS;
 	qdata.arg1 = clk_id;
@@ -303,9 +324,11 @@ struct clk_hw *zynqmp_clk_register_fixed_factor(const char *name, u32 clk_id,
 	mult = ret_payload[1];
 	div = ret_payload[2];
 
+	flag = zynqmp_clk_map_common_ccf_flags(nodes->flag);
+
 	hw = clk_hw_register_fixed_factor(NULL, name,
 					  parents[0],
-					  nodes->flag, mult,
+					  flag, mult,
 					  div);
 
 	return hw;
@@ -687,6 +710,13 @@ static void zynqmp_get_clock_info(void)
 				  FIELD_PREP(CLK_ATTR_NODE_INDEX, i);
 
 		zynqmp_pm_clock_get_name(clock[i].clk_id, &name);
+
+		/*
+		 * Terminate with NULL character in case name provided by firmware
+		 * is longer and truncated due to size limit.
+		 */
+		name.name[sizeof(name.name) - 1] = '\0';
+
 		if (!strcmp(name.name, RESERVED_CLK_NAME))
 			continue;
 		strncpy(clock[i].clk_name, name.name, MAX_NAME_LEN);
@@ -739,9 +769,7 @@ static int zynqmp_clk_setup(struct device_node *np)
 	zynqmp_register_clocks(np);
 
 	zynqmp_data->num = clock_max_idx;
-	of_clk_add_hw_provider(np, of_clk_hw_onecell_get, zynqmp_data);
-
-	return 0;
+	return of_clk_add_hw_provider(np, of_clk_hw_onecell_get, zynqmp_data);
 }
 
 static int zynqmp_clock_probe(struct platform_device *pdev)
diff --git a/drivers/clk/zynqmp/divider.c b/drivers/clk/zynqmp/divider.c
index 66da02b83..47a199346 100644
--- a/drivers/clk/zynqmp/divider.c
+++ b/drivers/clk/zynqmp/divider.c
@@ -35,6 +35,7 @@
  * @is_frac:	The divider is a fractional divider
  * @clk_id:	Id of clock
  * @div_type:	divisor type (TYPE_DIV1 or TYPE_DIV2)
+ * @max_div:	maximum supported divisor (fetched from firmware)
  */
 struct zynqmp_clk_divider {
 	struct clk_hw hw;
@@ -112,17 +113,20 @@ static unsigned long zynqmp_clk_divider_recalc_rate(struct clk_hw *hw,
 static void zynqmp_get_divider2_val(struct clk_hw *hw,
 				    unsigned long rate,
 				    struct zynqmp_clk_divider *divider,
-				    int *bestdiv)
+				    u32 *bestdiv)
 {
 	int div1;
 	int div2;
 	long error = LONG_MAX;
 	unsigned long div1_prate;
 	struct clk_hw *div1_parent_hw;
+	struct zynqmp_clk_divider *pdivider;
 	struct clk_hw *div2_parent_hw = clk_hw_get_parent(hw);
-	struct zynqmp_clk_divider *pdivider =
-				to_zynqmp_clk_divider(div2_parent_hw);
 
+	if (!div2_parent_hw)
+		return;
+
+	pdivider = to_zynqmp_clk_divider(div2_parent_hw);
 	if (!pdivider)
 		return;
 
@@ -255,6 +259,11 @@ static const struct clk_ops zynqmp_clk_divider_ops = {
 	.set_rate = zynqmp_clk_divider_set_rate,
 };
 
+static const struct clk_ops zynqmp_clk_divider_ro_ops = {
+	.recalc_rate = zynqmp_clk_divider_recalc_rate,
+	.round_rate = zynqmp_clk_divider_round_rate,
+};
+
 /**
  * zynqmp_clk_get_max_divisor() - Get maximum supported divisor from firmware.
  * @clk_id:		Id of clock
@@ -283,6 +292,29 @@ static u32 zynqmp_clk_get_max_divisor(u32 clk_id, u32 type)
 	return ret_payload[1];
 }
 
+static inline unsigned long zynqmp_clk_map_divider_ccf_flags(
+					       const u32 zynqmp_type_flag)
+{
+	unsigned long ccf_flag = 0;
+
+	if (zynqmp_type_flag & ZYNQMP_CLK_DIVIDER_ONE_BASED)
+		ccf_flag |= CLK_DIVIDER_ONE_BASED;
+	if (zynqmp_type_flag & ZYNQMP_CLK_DIVIDER_POWER_OF_TWO)
+		ccf_flag |= CLK_DIVIDER_POWER_OF_TWO;
+	if (zynqmp_type_flag & ZYNQMP_CLK_DIVIDER_ALLOW_ZERO)
+		ccf_flag |= CLK_DIVIDER_ALLOW_ZERO;
+	if (zynqmp_type_flag & ZYNQMP_CLK_DIVIDER_POWER_OF_TWO)
+		ccf_flag |= CLK_DIVIDER_HIWORD_MASK;
+	if (zynqmp_type_flag & ZYNQMP_CLK_DIVIDER_ROUND_CLOSEST)
+		ccf_flag |= CLK_DIVIDER_ROUND_CLOSEST;
+	if (zynqmp_type_flag & ZYNQMP_CLK_DIVIDER_READ_ONLY)
+		ccf_flag |= CLK_DIVIDER_READ_ONLY;
+	if (zynqmp_type_flag & ZYNQMP_CLK_DIVIDER_MAX_AT_ZERO)
+		ccf_flag |= CLK_DIVIDER_MAX_AT_ZERO;
+
+	return ccf_flag;
+}
+
 /**
  * zynqmp_clk_register_divider() - Register a divider clock
  * @name:		Name of this clock
@@ -310,16 +342,20 @@ struct clk_hw *zynqmp_clk_register_divider(const char *name,
 		return ERR_PTR(-ENOMEM);
 
 	init.name = name;
-	init.ops = &zynqmp_clk_divider_ops;
-	/* CLK_FRAC is not defined in the common clk framework */
-	init.flags = nodes->flag & ~CLK_FRAC;
+	if (nodes->type_flag & CLK_DIVIDER_READ_ONLY)
+		init.ops = &zynqmp_clk_divider_ro_ops;
+	else
+		init.ops = &zynqmp_clk_divider_ops;
+
+	init.flags = zynqmp_clk_map_common_ccf_flags(nodes->flag);
+
 	init.parent_names = parents;
 	init.num_parents = 1;
 
 	/* struct clk_divider assignments */
 	div->is_frac = !!((nodes->flag & CLK_FRAC) |
 			  (nodes->custom_type_flag & CUSTOM_FLAG_CLK_FRAC));
-	div->flags = nodes->type_flag;
+	div->flags = zynqmp_clk_map_divider_ccf_flags(nodes->type_flag);
 	div->hw.init = &init;
 	div->clk_id = clk_id;
 	div->div_type = nodes->type;
diff --git a/drivers/clk/zynqmp/pll.c b/drivers/clk/zynqmp/pll.c
index abe6afbf3..036e4ff64 100644
--- a/drivers/clk/zynqmp/pll.c
+++ b/drivers/clk/zynqmp/pll.c
@@ -31,8 +31,9 @@ struct zynqmp_pll {
 #define PS_PLL_VCO_MAX 3000000000UL
 
 enum pll_mode {
-	PLL_MODE_INT,
-	PLL_MODE_FRAC,
+	PLL_MODE_INT = 0,
+	PLL_MODE_FRAC = 1,
+	PLL_MODE_ERROR = 2,
 };
 
 #define FRAC_OFFSET 0x8
@@ -54,9 +55,11 @@ static inline enum pll_mode zynqmp_pll_get_mode(struct clk_hw *hw)
 	int ret;
 
 	ret = zynqmp_pm_get_pll_frac_mode(clk_id, ret_payload);
-	if (ret)
+	if (ret) {
 		pr_warn_once("%s() PLL get frac mode failed for %s, ret = %d\n",
 			     __func__, clk_name, ret);
+		return PLL_MODE_ERROR;
+	}
 
 	return ret_payload[1];
 }
@@ -126,7 +129,7 @@ static long zynqmp_pll_round_rate(struct clk_hw *hw, unsigned long rate,
  * @hw:			Handle between common and hardware-specific interfaces
  * @parent_rate:	Clock frequency of parent clock
  *
- * Return: Current clock frequency
+ * Return: Current clock frequency or 0 in case of error
  */
 static unsigned long zynqmp_pll_recalc_rate(struct clk_hw *hw,
 					    unsigned long parent_rate)
@@ -138,14 +141,21 @@ static unsigned long zynqmp_pll_recalc_rate(struct clk_hw *hw,
 	unsigned long rate, frac;
 	u32 ret_payload[PAYLOAD_ARG_CNT];
 	int ret;
+	enum pll_mode mode;
 
 	ret = zynqmp_pm_clock_getdivider(clk_id, &fbdiv);
-	if (ret)
+	if (ret) {
 		pr_warn_once("%s() get divider failed for %s, ret = %d\n",
 			     __func__, clk_name, ret);
+		return 0ul;
+	}
+
+	mode = zynqmp_pll_get_mode(hw);
+	if (mode == PLL_MODE_ERROR)
+		return 0ul;
 
 	rate =  parent_rate * fbdiv;
-	if (zynqmp_pll_get_mode(hw) == PLL_MODE_FRAC) {
+	if (mode == PLL_MODE_FRAC) {
 		zynqmp_pm_get_pll_frac_data(clk_id, ret_payload);
 		data = ret_payload[1];
 		frac = (parent_rate * data) / FRAC_DIV;
@@ -312,7 +322,9 @@ struct clk_hw *zynqmp_clk_register_pll(const char *name, u32 clk_id,
 
 	init.name = name;
 	init.ops = &zynqmp_pll_ops;
-	init.flags = nodes->flag;
+
+	init.flags = zynqmp_clk_map_common_ccf_flags(nodes->flag);
+
 	init.parent_names = parents;
 	init.num_parents = 1;
 
@@ -331,8 +343,6 @@ struct clk_hw *zynqmp_clk_register_pll(const char *name, u32 clk_id,
 	}
 
 	clk_hw_set_rate_range(hw, PS_PLL_VCO_MIN, PS_PLL_VCO_MAX);
-	if (ret < 0)
-		pr_err("%s:ERROR clk_set_rate_range failed %d\n", name, ret);
 
 	return hw;
 }
diff --git a/include/linux/clk/zynq.h b/include/linux/clk/zynq.h
index a198dd925..d1135756a 100644
--- a/include/linux/clk/zynq.h
+++ b/include/linux/clk/zynq.h
@@ -9,6 +9,10 @@
 
 #include <linux/spinlock.h>
 
+int zynq_clk_suspend_early(void);
+void zynq_clk_resume_late(void);
+void zynq_clk_topswitch_enable(void);
+void zynq_clk_topswitch_disable(void);
 void zynq_clock_init(void);
 
 struct clk *clk_register_zynq_pll(const char *name, const char *parent,
