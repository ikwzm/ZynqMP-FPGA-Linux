diff --git a/Documentation/devicetree/bindings/iio/adc/ti,ina260.yaml b/Documentation/devicetree/bindings/iio/adc/ti,ina260.yaml
new file mode 100644
index 000000000..c9f1a659c
--- /dev/null
+++ b/Documentation/devicetree/bindings/iio/adc/ti,ina260.yaml
@@ -0,0 +1,57 @@
+# SPDX-License-Identifier: GPL-2.0-or-later
+%YAML 1.2
+---
+$id: http://devicetree.org/schemas/iio/adc/ti,ina260.yaml#
+$schema: http://devicetree.org/meta-schemas/core.yaml#
+
+title: Texas Instruments INA260 power monitor
+
+maintainers:
+  - Shubhrajyoti Datta <shubhrajyoti.datta@xilinx.com>
+
+description: |
+  The INA260 is a digital-output, current, power and voltage monitor
+  with an I2C and SMBUS compatible interface with an integrated shunt
+  resistor. It features up to 16 programmable addresses on I2C compatible
+  interface. Datasheet - https://www.ti.com/lit/ds/symlink/ina260.pdf?ts=1608607288391
+
+properties:
+  compatible:
+    enum:
+      - ti,ina260
+
+  reg:
+    description: |
+      The 7-bits long I2c address of the device
+
+  "#io-channel-cells":
+    const: 1
+
+  interrupts:
+    description: |
+      IRQ line for the device
+
+  label:
+    description: |
+      A symbolic name for the device
+
+required:
+  - compatible
+  - reg
+  - "#io-channel-cells"
+
+additionalProperties: false
+
+examples:
+  - |
+    i2c {
+      #address-cells = <1>;
+      #size-cells = <0>;
+
+      ina260@40 {
+        compatible = "ti,ina260";
+        reg = <0x40>;
+        #io-channel-cells = <1>;
+      };
+    };
+...
diff --git a/Documentation/devicetree/bindings/iio/adc/xilinx-ams.txt b/Documentation/devicetree/bindings/iio/adc/xilinx-ams.txt
new file mode 100644
index 000000000..3d1e77014
--- /dev/null
+++ b/Documentation/devicetree/bindings/iio/adc/xilinx-ams.txt
@@ -0,0 +1,159 @@
+Xilinx AMS device driver
+
+The AMS includes an ADC as well as on-chip sensors that can be used to
+sample external voltages and monitor on-die operating conditions, such as
+temperature and supply voltage levels. The AMS has two SYSMON blocks.
+PL-SYSMON block is capable of monitoring off chip voltage and temperature.
+PL-SYSMON block has DRP, JTAG and I2C interface to enable monitoring from
+external master. Out of this interface currenlty only DRP is supported.
+Other block PS-SYSMON is memory mapped to PS. Both of block has built-in
+alarm generation logic that is used to interrupt the processor based on
+condition set.
+
+All designs should have AMS register, but PS and PL are optional depending on
+the design. The driver can work with only PS, only PL and both PS and PL
+configurations. Please specify registers according to your design. DTS file
+should always have AMS module property. Providing PS & PL module is optional.
+
+Required properties:
+	- compatible: Should be "xlnx,zynqmp-ams"
+	- reg:  Should specify AMS register space
+	- interrupts: Interrupt number for the AMS control interface
+	- interrupt-names: Interrupt name, must be "ams-irq"
+	- clocks: Should contain a clock specifier for the device
+	- ranges: keep the property empty to map child address space
+	          (for PS and/or PL) nodes 1:1 onto the parent address
+	          space
+
+AMS device tree subnode:
+	- compatible: Should be "xlnx,zynqmp-ams-ps" or "xlnx,zynqmp-ams-pl"
+	- reg:  Register space for PS or PL
+
+Optional properties:
+
+Following optional property only valid for PL.
+	- xlnx,ext-channels: List of external channels that are connected to the
+	                     AMS PL module.
+
+	  The child nodes of this node represent the external channels which are
+	  connected to the AMS Module. If the property is not present
+	  no external channels will be assumed to be connected.
+
+	  Each child node represents one channel and has the following
+	  properties:
+		Required properties:
+			* reg: Pair of pins the channel is connected to.
+				0: VP/VN
+				1: VUSER0
+				2: VUSER1
+				3: VUSER3
+				4: VUSER4
+				5: VAUXP[0]/VAUXN[0]
+				6: VAUXP[1]/VAUXN[1]
+				...
+				20: VAUXP[15]/VAUXN[15]
+			  Note each channel number should only be used at most
+			  once.
+		Optional properties:
+			* xlnx,bipolar: If set the channel is used in bipolar
+			  mode.
+
+
+Example:
+	xilinx_ams: ams@ffa50000 {
+		compatible = "xlnx,zynqmp-ams";
+		interrupt-parent = <&gic>;
+		interrupts = <0 56 4>;
+		interrupt-names = "ams-irq";
+		clocks = <&clkc 70>;
+		reg = <0x0 0xffa50000 0x0 0x800>;
+		reg-names = "ams-base";
+		#address-cells = <2>;
+		#size-cells = <2>;
+		ranges;
+
+		ams_ps: ams_ps@ffa50800 {
+			compatible = "xlnx,zynqmp-ams-ps";
+			reg = <0x0 0xffa50800 0x0 0x400>;
+		};
+
+		ams_pl: ams_pl@ffa50c00 {
+			compatible = "xlnx,zynqmp-ams-pl";
+			reg = <0x0 0xffa50c00 0x0 0x400>;
+			xlnx,ext-channels {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				channel@0 {
+					reg = <0>;
+					xlnx,bipolar;
+				};
+				channel@1 {
+					reg = <1>;
+				};
+				channel@8 {
+					reg = <8>;
+					xlnx,bipolar;
+				};
+			};
+		};
+	};
+
+AMS Channels Details:
+
+Sysmon Block	|Channel|			Details					|Measurement
+		 Number									 Type
+---------------------------------------------------------------------------------------------------------
+AMS CTRL	|0	|System PLLs voltage measurement, VCC_PSPLL.			|Voltage
+		|1	|Battery voltage measurement, VCC_PSBATT.			|Voltage
+		|2	|PL Internal voltage measurement, VCCINT.			|Voltage
+		|3	|Block RAM voltage measurement, VCCBRAM.			|Voltage
+		|4	|PL Aux voltage measurement, VCCAUX.				|Voltage
+		|5	|Voltage measurement for six DDR I/O PLLs, VCC_PSDDR_PLL.	|Voltage
+		|6	|VCC_PSINTFP_DDR voltage measurement.				|Voltage
+---------------------------------------------------------------------------------------------------------
+PS Sysmon	|7	|LPD temperature measurement.					|Temperature
+		|8	|FPD Temperature Measurment (REMOTE).				|Temperature
+		|9	|VCC PS LPD voltage measurement (supply1).			|Voltage
+		|10	|VCC PS FPD voltage measurement (supply2).			|Voltage
+		|11	|PS Aux voltage reference (supply3).				|Voltage
+		|12	|DDR I/O VCC voltage measurement.				|Voltage
+		|13	|PS IO Bank 503 voltage measurement (supply5).			|Voltage
+		|14	|PS IO Bank 500 voltage measurement (supply6).			|Voltage
+		|15	|VCCO_PSIO1 voltage measurement.				|Voltage
+		|16	|VCCO_PSIO2 voltage measurement.				|Voltage
+		|17	|VCC_PS_GTR voltage measurement (VPS_MGTRAVCC).			|Voltage
+		|18	|VTT_PS_GTR voltage measurement (VPS_MGTRAVTT).			|Voltage
+		|19	|VCC_PSADC voltage measurement.					|Voltage
+---------------------------------------------------------------------------------------------------------
+PL Sysmon	|20	|PL Temperature measurement.					|Temperature
+		|21	|PL Internal Voltage Voltage measurement, VCCINT.		|Voltage
+		|22	|PL Auxiliary Voltage measurement, VCCAUX.			|Voltage
+		|23	|ADC Reference P+ Voltage measurement.				|Voltage
+		|24	|ADC Reference N- Voltage measurement.				|Voltage
+		|25	|PL Block RAM Voltage measurement, VCCBRAM.			|Voltage
+		|26	|LPD Internal Voltage measurement, VCC_PSINTLP (supply4).	|Voltage
+		|27	|FPD Internal Voltage measurement, VCC_PSINTFP (supply5).	|Voltage
+		|28	|PS Auxiliary Voltage measurement (supply6).			|Voltage
+		|29	|PL VCCADC Voltage measurement (vccams).			|Voltage
+		|30	|Differencial analog input signal Voltage measurment.		|Voltage
+		|31	|VUser0 Voltage measurement (supply7).				|Voltage
+		|32	|VUser1 Voltage measurement (supply8).				|Voltage
+		|33	|VUser2 Voltage measurement (supply9).				|Voltage
+		|34	|VUser3 Voltage measurement (supply10).				|Voltage
+		|35	|Auxiliary ch 0 Voltage measurement (VAux0).			|Voltage
+		|36	|Auxiliary ch 1 Voltage measurement (VAux1).			|Voltage
+		|37	|Auxiliary ch 2 Voltage measurement (VAux2).			|Voltage
+		|38	|Auxiliary ch 3 Voltage measurement (VAux3).			|Voltage
+		|39	|Auxiliary ch 4 Voltage measurement (VAux4).			|Voltage
+		|40	|Auxiliary ch 5 Voltage measurement (VAux5).			|Voltage
+		|41	|Auxiliary ch 6 Voltage measurement (VAux6).			|Voltage
+		|42	|Auxiliary ch 7 Voltage measurement (VAux7).			|Voltage
+		|43	|Auxiliary ch 8 Voltage measurement (VAux8).			|Voltage
+		|44	|Auxiliary ch 9 Voltage measurement (VAux9).			|Voltage
+		|45	|Auxiliary ch 10 Voltage measurement (VAux10).			|Voltage
+		|46	|Auxiliary ch 11 Voltage measurement (VAux11).			|Voltage
+		|47	|Auxiliary ch 12 Voltage measurement (VAux12).			|Voltage
+		|48	|Auxiliary ch 13 Voltage measurement (VAux13).			|Voltage
+		|49	|Auxiliary ch 14 Voltage measurement (VAux14).			|Voltage
+		|50	|Auxiliary ch 15 Voltage measurement (VAux15).			|Voltage
+---------------------------------------------------------------------------------------------------------
diff --git a/Documentation/devicetree/bindings/iio/adc/xilinx-xadc.txt b/Documentation/devicetree/bindings/iio/adc/xilinx-xadc.txt
index e0e0755ca..fecb1afdd 100644
--- a/Documentation/devicetree/bindings/iio/adc/xilinx-xadc.txt
+++ b/Documentation/devicetree/bindings/iio/adc/xilinx-xadc.txt
@@ -15,6 +15,8 @@ Required properties:
 		  configuration interface to interface to the XADC hardmacro.
 		* "xlnx,axi-xadc-1.00.a": When using the axi-xadc pcore to
 		  interface to the XADC hardmacro.
+		* "xlnx,axi-sysmon-1.3": When using the axi-sysmon pcore to
+		  interface to the sysmon hardmacro.
 	- reg: Address and length of the register set for the device
 	- interrupts: Interrupt for the XADC control interface.
 	- clocks: When using the ZYNQ this must be the ZYNQ PCAP clock,
@@ -110,3 +112,20 @@ Examples:
 			};
 		};
 	};
+
+	xadc@44a00000 {
+		compatible = "xlnx,axi-sysmon-1.3";
+		interrupt-parent = <&axi_intc_0>;
+		interrupts = <2 2>;
+		clocks = <&clk_bus_0>;
+		reg = <0x44a00000 0x10000>;
+
+		xlnx,channels {
+			#address-cells = <1>;
+			#size-cells = <0>;
+			channel@0 {
+				reg = <0>;
+				xlnx,bipolar;
+			};
+		};
+	};
diff --git a/Documentation/devicetree/bindings/iio/adc/xlnx,versal-sysmon.yaml b/Documentation/devicetree/bindings/iio/adc/xlnx,versal-sysmon.yaml
new file mode 100644
index 000000000..1da672bf7
--- /dev/null
+++ b/Documentation/devicetree/bindings/iio/adc/xlnx,versal-sysmon.yaml
@@ -0,0 +1,143 @@
+# SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)
+# Copyright 2019 - 2020 Xilinx Inc.
+%YAML 1.2
+---
+$id: http://devicetree.org/schemas/iio/adc/xlnx,versal-sysmon.yaml#
+$schema: http://devicetree.org/meta-schemas/core.yaml#
+
+title: Xilinx Versal Sysmon Linux Driver
+
+maintainers:
+  - Anand Ashok Dumbre <anand.ashok.dumbre@xilinx.com>
+
+description: |
+  Sysmon Driver uses Linux IIO framework which was used to abstract the supply
+  voltages and temperatures across the chip as Voltage and Temperature
+  Channels in the framework. Since there are only 160 supply voltage registers
+  and 184 measurement points, there is no constant mapping of supply voltage
+  registers and the measurement points. User has to select the voltages to
+  monitor in design tool. Depending on the selection, a voltage supply gets
+  mapped to one of the supply registers. So, this mapping information is
+  provided to the driver via a device tree. Depending on the number of supplies
+  enabled in the design, the device tree will contain the information of name
+  of the supply enabled and the supply register it maps to.
+
+properties:
+  compatible:
+    items:
+      - enum:
+          - xlnx,versal-sysmon
+
+  reg:
+    description: Sysmon Registers
+    maxItems: 1
+
+  interrupts:
+    description: interrupt line for Sysmon
+    maxItems: 1
+
+  '#address-cells':
+    const: 1
+
+  '#size-cells':
+    const: 0
+
+  xlnx,numchannels:
+    $ref: /schemas/types.yaml#/definitions/uint8
+    maxItems: 1
+    description: |
+      Number of supply channels enabled in the design.
+      Possible values 0 - 160. Based on this value, child supply nodes will
+      be created
+
+patternProperties:
+  "^supply@([0-9]{1,2}|1[0-5][0-9])$":
+    type: object
+    description: |
+      Represents the supplies configured in the design.
+
+    properties:
+      reg:
+        $ref: /schemas/types.yaml#/definitions/uint32
+        minimum: 0
+        maximum: 159
+        description:
+          The supply number associated with the voltage.
+
+      xlnx,name:
+        $ref: /schemas/types.yaml#/definitions/string
+        description:
+          Name of the supply enabled
+
+      xlnx,bipolar:
+        $ref: /schemas/types.yaml#/definitions/flag
+        description:
+          If the supply has a bipolar type and the output will be signed
+
+    required:
+      - reg
+      - xlnx,name
+
+required:
+  - compatible
+  - reg
+  - xlnx,numchannels
+
+additionalProperties: false
+
+examples:
+  - |
+    bus {
+        #address-cells = <2>;
+        #size-cells = <2>;
+
+        sysmon@f1270000 {
+            compatible = "xlnx,versal-sysmon";
+            reg = <0 0xf1270000 0 0x4000>;
+            interrupts = <0 0x90 0x4>;
+            xlnx,numchannels = /bits/8 <8>;
+            #address-cells = <1>;
+            #size-cells = <0>;
+            supply@0 {
+                    reg = <0>;
+                    xlnx,name = "vccint";
+            };
+
+            supply@31 {
+                    reg = <31>;
+                    xlnx,name = "vccsoc";
+            };
+
+            supply@32 {
+                    reg = <32>;
+                    xlnx,bipolar;
+                    xlnx,name = "vccram";
+            };
+
+            supply@63 {
+                    reg = <63>;
+                    xlnx,bipolar;
+                    xlnx,name = "vccaux";
+            };
+
+            supply@64 {
+                    reg = <64>;
+                    xlnx,name = "vccbram";
+            };
+
+            supply@95 {
+                    reg = <95>;
+                    xlnx,name = "gt_avaux";
+            };
+
+            supply@96 {
+                    reg = <96>;
+                    xlnx,name = "gt_vccaux";
+            };
+
+            supply@159 {
+                    reg = <159>;
+                    xlnx,name = "vccint_ir";
+            };
+        };
+    };
diff --git a/drivers/iio/adc/Kconfig b/drivers/iio/adc/Kconfig
index e39b67912..c188b57d6 100644
--- a/drivers/iio/adc/Kconfig
+++ b/drivers/iio/adc/Kconfig
@@ -499,6 +499,18 @@ config INA2XX_ADC
 	  Say yes here to build support for TI INA2xx family of Power Monitors.
 	  This driver is mutually exclusive with the HWMON version.
 
+config INA260_ADC
+	tristate "Texas Instruments INA260 Power Monitors IIO driver"
+	depends on I2C && !SENSORS_INA2XX
+	select REGMAP_I2C
+	select IIO_BUFFER
+	select IIO_KFIFO_BUF
+	help
+	  Say yes here to build support for TI INA260 power monitor.
+	  This driver can also be built as a module. It supports software buffer
+	  mode and raw reads of ina260 iio channels. Up to 4 channels are
+	  supported including timestamp.
+
 config INGENIC_ADC
 	tristate "Ingenic JZ47xx SoCs ADC driver"
 	depends on MIPS || COMPILE_TEST
@@ -1226,4 +1238,25 @@ config XILINX_XADC
 	  The driver can also be build as a module. If so, the module will be called
 	  xilinx-xadc.
 
+config XILINX_AMS
+       tristate "Xilinx AMS driver"
+       depends on ARCH_ZYNQMP || COMPILE_TEST
+       depends on HAS_IOMEM
+       help
+         Say yes here to have support for the Xilinx AMS.
+
+         The driver can also be build as a module. If so, the module will be called
+         xilinx-ams.
+
+config VERSAL_SYSMON
+	tristate "Xilinx Sysmon driver for Versal"
+	depends on HAS_IOMEM
+	help
+	  Say yes here to have support for the Xilinx Sysmon.
+	  The driver will enable users to monitor temperature and voltage on the
+	  Xilinx Versal platform.
+	  The HW also supports I2C access but it is not supported by the driver.
+
+	  The driver can also be build as a module. If so, the module will be called
+	  versal-sysmon.
 endmenu
diff --git a/drivers/iio/adc/Makefile b/drivers/iio/adc/Makefile
index 90f94ada7..a98bb67a9 100644
--- a/drivers/iio/adc/Makefile
+++ b/drivers/iio/adc/Makefile
@@ -47,6 +47,7 @@ obj-$(CONFIG_HI8435) += hi8435.o
 obj-$(CONFIG_HX711) += hx711.o
 obj-$(CONFIG_IMX7D_ADC) += imx7d_adc.o
 obj-$(CONFIG_INA2XX_ADC) += ina2xx-adc.o
+obj-$(CONFIG_INA260_ADC) += ina260-adc.o
 obj-$(CONFIG_INGENIC_ADC) += ingenic-adc.o
 obj-$(CONFIG_INTEL_MRFLD_ADC) += intel_mrfld_adc.o
 obj-$(CONFIG_LP8788_ADC) += lp8788_adc.o
@@ -110,4 +111,6 @@ obj-$(CONFIG_VF610_ADC) += vf610_adc.o
 obj-$(CONFIG_VIPERBOARD_ADC) += viperboard_adc.o
 xilinx-xadc-y := xilinx-xadc-core.o xilinx-xadc-events.o
 obj-$(CONFIG_XILINX_XADC) += xilinx-xadc.o
+obj-$(CONFIG_XILINX_AMS) += xilinx-ams.o
 obj-$(CONFIG_SD_ADC_MODULATOR) += sd_adc_modulator.o
+obj-$(CONFIG_VERSAL_SYSMON) += versal-sysmon.o
diff --git a/drivers/iio/adc/ina260-adc.c b/drivers/iio/adc/ina260-adc.c
new file mode 100644
index 000000000..91786a685
--- /dev/null
+++ b/drivers/iio/adc/ina260-adc.c
@@ -0,0 +1,556 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * INA260 power monitor driver
+ * Based on drivers/iio/adc/ina2xx-adc.c
+ *
+ * Copyright (C) 2021 Xilinx, Inc.
+ */
+
+#include <linux/i2c.h>
+#include <linux/iio/iio.h>
+#include <linux/iio/buffer.h>
+#include <linux/iio/kfifo_buf.h>
+#include <linux/iio/sysfs.h>
+#include <linux/kthread.h>
+#include <linux/module.h>
+#include <linux/of_device.h>
+#include <linux/regmap.h>
+#include <linux/sched/task.h>
+#include <linux/util_macros.h>
+
+/* INA260 registers definition */
+#define INA260_CONFIG		0x00
+#define INA260_CURRENT		0x01
+#define INA260_VOLTAGE		0x02
+#define INA260_POWER		0x03
+#define INA260_MASK_ENABLE	0x06
+#define INA260_ALERT_LIMIT	0x07
+#define INA260_MANF_ID		0xFE
+#define INA260_DIE_ID		0xFF
+
+#define INA260_CONFIG_DEFAULT	0x6327
+
+#define INA260_CURRENT_LSB	1250
+#define INA260_VOLTAGE_LSB	1250
+#define INA260_POWER_LSB	10
+
+/* Bits */
+#define INA260_CVRF		BIT(3)
+
+#define INA260_MODE_MASK	GENMASK(2, 0)
+#define INA260_VOLT_MASK	GENMASK(8, 6)
+#define INA260_SHIFT_VOLT(val)	((val) << 6)
+#define INA260_CURR_MASK	GENMASK(5, 3)
+#define INA260_SHIFT_CURR(val)	((val) << 3)
+#define INA260_AVG_MASK		GENMASK(11, 9)
+#define INA260_SHIFT_AVG(val)	((val) << 9)
+
+#define SAMPLING_PERIOD(x) ({		\
+	typeof(x) _x = (x);		\
+	(_x->config->volt_conv_time	\
+	+ _x->config->curr_conv_time)	\
+	* _x->config->avgs; })
+
+static bool ina260_is_writeable_reg(struct device *dev, unsigned int reg)
+{
+	return (reg == INA260_CONFIG) || (reg == INA260_MASK_ENABLE) ||
+		(reg == INA260_ALERT_LIMIT);
+}
+
+static bool ina260_is_volatile_reg(struct device *dev, unsigned int reg)
+{
+	return (reg != INA260_CONFIG);
+}
+
+static inline bool is_signed_reg(unsigned int reg)
+{
+	return (reg == INA260_CURRENT);
+}
+
+static const struct regmap_config ina260_regmap_config = {
+	.reg_bits = 8,
+	.val_bits = 16,
+	.max_register = 8,
+	.writeable_reg = ina260_is_writeable_reg,
+	.volatile_reg = ina260_is_volatile_reg,
+};
+
+enum ina260_ids {ina260 = 0};
+
+/**
+ * struct ina260_config - For configurable parameters
+ * @config_default: Default configuration
+ * @volt_conv_time: Bus voltage conversion time
+ * @curr_conv_time: Shunt current conversion time
+ * @avgs: Number of samples collected and averaged
+ */
+struct ina260_config {
+	u16 config_default;
+	int volt_conv_time;
+	int curr_conv_time;
+	int avgs;
+};
+
+/**
+ * struct ina260_chip - For device specific data
+ * @regmap: Regmap pointer to device registers
+ * @task: Pointer to task created by buffer mode
+ * @lock: Mutex to enable use of multiple user apps
+ * @chip_id: Id to determine chip
+ * @config: Pointer to config structure
+ */
+struct ina260_chip {
+	struct regmap *regmap;
+	struct task_struct *task;
+	struct mutex lock; /* Lock for device writes */
+	enum ina260_ids chip_id;
+	struct ina260_config *config;
+};
+
+static struct ina260_config ina260_config[] = {
+	[ina260] = {
+		.config_default = INA260_CONFIG_DEFAULT,
+		.volt_conv_time = 1100,
+		.curr_conv_time = 1100,
+		.avgs = 4,
+	},
+};
+
+static int ina260_read_raw(struct iio_dev *indio_dev,
+			   struct iio_chan_spec const *chan,
+			   int *val, int *val2, long mask)
+{
+	struct ina260_chip *chip = iio_priv(indio_dev);
+	unsigned int regval;
+	int ret;
+
+	switch (mask) {
+	case IIO_CHAN_INFO_RAW:
+		if (iio_buffer_enabled(indio_dev))
+			return -EBUSY;
+
+		ret = regmap_read(chip->regmap, chan->address, &regval);
+		if (ret)
+			return ret;
+
+		if (is_signed_reg(chan->address))
+			*val = (s16)regval;
+		else
+			*val = regval;
+		return IIO_VAL_INT;
+
+	case IIO_CHAN_INFO_SCALE:
+		switch (chan->address) {
+		case INA260_CURRENT:
+			*val = INA260_CURRENT_LSB;
+			*val2 = 1000;
+			return IIO_VAL_FRACTIONAL;
+
+		case INA260_VOLTAGE:
+			*val = INA260_VOLTAGE_LSB;
+			*val2 = 1000;
+			return IIO_VAL_FRACTIONAL;
+
+		case INA260_POWER:
+			*val = INA260_POWER_LSB;
+			return IIO_VAL_INT;
+		}
+		return -EINVAL;
+
+	case IIO_CHAN_INFO_INT_TIME:
+		*val = 0;
+		if (chan->address == INA260_VOLTAGE)
+			*val2 = chip->config->volt_conv_time;
+		else
+			*val2 = chip->config->curr_conv_time;
+
+		return IIO_VAL_INT_PLUS_MICRO;
+
+	case IIO_CHAN_INFO_SAMP_FREQ:
+		*val = DIV_ROUND_CLOSEST(1000000, SAMPLING_PERIOD(chip));
+		return IIO_VAL_INT;
+
+	case IIO_CHAN_INFO_OVERSAMPLING_RATIO:
+		*val = chip->config->avgs;
+		return IIO_VAL_INT;
+	}
+
+	return -EINVAL;
+}
+
+static const int ina260_avg_tab[] = { 1, 4, 16, 64, 128, 256, 512, 1024 };
+
+/* Conversion times in uS */
+static const int ina260_conv_time_tab[] = { 140, 204, 332, 588, 1100, 2116, 4156, 8244 };
+
+static int ina260_write_raw(struct iio_dev *indio_dev,
+			    struct iio_chan_spec const *chan,
+			    int val, int val2, long mask)
+{
+	struct ina260_chip *chip = iio_priv(indio_dev);
+	unsigned int config;
+	int ret, bits;
+
+	if (iio_buffer_enabled(indio_dev))
+		return -EBUSY;
+
+	mutex_lock(&chip->lock);
+
+	ret = regmap_read(chip->regmap, INA260_CONFIG, &config);
+	if (ret)
+		goto err;
+
+	switch (mask) {
+	case IIO_CHAN_INFO_INT_TIME:
+		if (val2 > 8244 || val2 < 140) {
+			ret = -EINVAL;
+			goto err;
+		}
+
+		bits = find_closest(val2, ina260_conv_time_tab,
+				    ARRAY_SIZE(ina260_conv_time_tab));
+
+		if (chan->address == INA260_VOLTAGE) {
+			chip->config->volt_conv_time = ina260_conv_time_tab[bits];
+			config &= ~INA260_VOLT_MASK;
+			config |= INA260_SHIFT_VOLT(bits) & INA260_VOLT_MASK;
+		} else {
+			chip->config->curr_conv_time = ina260_conv_time_tab[bits];
+			config &= ~INA260_CURR_MASK;
+			config |= INA260_SHIFT_CURR(bits) & INA260_CURR_MASK;
+		}
+		break;
+
+	case IIO_CHAN_INFO_OVERSAMPLING_RATIO:
+		bits = find_closest(val, ina260_avg_tab, ARRAY_SIZE(ina260_avg_tab));
+		chip->config->avgs = ina260_avg_tab[bits];
+		config &= ~INA260_AVG_MASK;
+		config |= INA260_SHIFT_AVG(bits) & INA260_AVG_MASK;
+		break;
+
+	default:
+		ret = -EINVAL;
+	}
+	if (!ret)
+		ret = regmap_write(chip->regmap, INA260_CONFIG, config);
+err:
+	mutex_unlock(&chip->lock);
+
+	return ret;
+}
+
+static int ina260_debug_reg(struct iio_dev *indio_dev,
+			    unsigned int reg, unsigned int writeval, unsigned int *readval)
+{
+	struct ina260_chip *chip = iio_priv(indio_dev);
+
+	if (!readval)
+		return regmap_write(chip->regmap, reg, writeval);
+
+	return regmap_read(chip->regmap, reg, readval);
+}
+
+#define INA260_CHAN_VOLTAGE(_index, _address) { \
+	.type = IIO_VOLTAGE, \
+	.address = (_address), \
+	.indexed = 1, \
+	.channel = (_index), \
+	.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) | \
+	BIT(IIO_CHAN_INFO_SCALE) | \
+	BIT(IIO_CHAN_INFO_INT_TIME), \
+	.info_mask_shared_by_dir = BIT(IIO_CHAN_INFO_SAMP_FREQ) | \
+	BIT(IIO_CHAN_INFO_OVERSAMPLING_RATIO), \
+	.scan_index = (_index), \
+	.scan_type = { \
+		.sign = 'u', \
+		.realbits = 16, \
+		.storagebits = 16, \
+		.endianness = IIO_CPU, \
+	} \
+}
+
+#define INA260_CHAN_CURRENT(_index, _address) { \
+	.type = IIO_CURRENT, \
+	.address = (_address), \
+	.indexed = 1, \
+	.channel = (_index), \
+	.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) | \
+	BIT(IIO_CHAN_INFO_SCALE) | \
+	BIT(IIO_CHAN_INFO_INT_TIME), \
+	.info_mask_shared_by_dir = BIT(IIO_CHAN_INFO_SAMP_FREQ) | \
+	BIT(IIO_CHAN_INFO_OVERSAMPLING_RATIO), \
+	.scan_index = (_index), \
+	.scan_type = { \
+		.sign = 's', \
+		.realbits = 16, \
+		.storagebits = 16, \
+		.endianness = IIO_CPU, \
+	} \
+}
+
+#define INA260_CHAN_POWER(_index, _address) { \
+	.type = IIO_POWER, \
+	.address = (_address), \
+	.indexed = 1, \
+	.channel = (_index), \
+	.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) | \
+	BIT(IIO_CHAN_INFO_SCALE), \
+	.info_mask_shared_by_dir = BIT(IIO_CHAN_INFO_SAMP_FREQ) | \
+	BIT(IIO_CHAN_INFO_OVERSAMPLING_RATIO), \
+	.scan_index = (_index), \
+	.scan_type = { \
+		.sign = 'u', \
+		.realbits = 16, \
+		.storagebits = 16, \
+		.endianness = IIO_CPU, \
+	} \
+}
+
+static const struct iio_chan_spec ina260_channels[] = {
+	INA260_CHAN_CURRENT(0, INA260_CURRENT),
+	INA260_CHAN_VOLTAGE(1, INA260_VOLTAGE),
+	INA260_CHAN_POWER(2, INA260_POWER),
+	IIO_CHAN_SOFT_TIMESTAMP(3),
+};
+
+/* Possible integration times for current and voltage */
+static IIO_CONST_ATTR_NAMED(ina260_integration_time_available,
+			    integration_time_available,
+			    "0.000140 0.000204 0.000332 0.000588 0.001100 0.002116 0.004156 0.008244");
+
+static struct attribute *ina260_attributes[] = {
+	&iio_const_attr_ina260_integration_time_available.dev_attr.attr,
+	NULL,
+};
+
+static const struct attribute_group ina260_attribute_group = {
+	.attrs = ina260_attributes,
+};
+
+static const struct iio_info ina260_info = {
+	.attrs = &ina260_attribute_group,
+	.read_raw = ina260_read_raw,
+	.write_raw = ina260_write_raw,
+	.debugfs_reg_access = ina260_debug_reg,
+};
+
+static int ina260_conversion_ready(struct iio_dev *indio_dev)
+{
+	struct ina260_chip *chip = iio_priv(indio_dev);
+	unsigned int alert;
+	int ret;
+
+	ret = regmap_read(chip->regmap, INA260_MASK_ENABLE, &alert);
+	if (ret < 0)
+		return ret;
+
+	return (alert & INA260_CVRF);
+}
+
+static int ina260_work_buffer(struct iio_dev *indio_dev)
+{
+	/* data buffer needs space for channel data and timestap */
+	unsigned short data[3 + sizeof(s64) / sizeof(short)];
+	struct ina260_chip *chip = iio_priv(indio_dev);
+	int bit, ret, i = 0;
+	s64 time;
+
+	time = iio_get_time_ns(indio_dev);
+
+	/*
+	 * Read current, voltage and power from device
+	 */
+	for_each_set_bit(bit, indio_dev->active_scan_mask,
+			 indio_dev->masklength) {
+		unsigned int val;
+
+		ret = regmap_read(chip->regmap, INA260_CURRENT + bit, &val);
+		if (ret < 0)
+			return ret;
+
+		data[i++] = val;
+	}
+
+	iio_push_to_buffers_with_timestamp(indio_dev, data, time);
+
+	return 0;
+}
+
+static int ina260_capture_thread(void *data)
+{
+	struct iio_dev *indio_dev = data;
+	struct ina260_chip *chip = iio_priv(indio_dev);
+	int sampling_us = SAMPLING_PERIOD(chip);
+	struct timespec64 next, now, delta;
+	s64 delay_us;
+	int ret;
+
+	ktime_get_ts64(&next);
+
+	do {
+		while (1) {
+			/* Check if conversion is ready */
+			ret = ina260_conversion_ready(indio_dev);
+			if (ret < 0)
+				return ret;
+
+			/*
+			 * If the conversion was not yet finished,
+			 * reset the reference timestamp.
+			 */
+			if (ret == 0)
+				ktime_get_ts64(&next);
+			else
+				break;
+		}
+		/* Read the data from sensor and push it to buffers */
+		ret = ina260_work_buffer(indio_dev);
+		if (ret < 0)
+			return ret;
+
+		ktime_get_ts64(&now);
+		/*
+		 * Advance the timestamp for the next poll by one sampling
+		 * interval, and sleep for the remainder (next - now)
+		 * In case "next" has already passed, the interval is added
+		 * multiple times, i.e. samples are dropped.
+		 */
+		do {
+			timespec64_add_ns(&next, 1000 * sampling_us);
+			delta = timespec64_sub(next, now);
+			delay_us = div_s64(timespec64_to_ns(&delta), 1000);
+		} while (delay_us <= 0);
+
+		usleep_range(delay_us, (delay_us * 3) >> 1);
+
+	} while (!kthread_should_stop());
+
+	return 0;
+}
+
+static int ina260_buffer_enable(struct iio_dev *indio_dev)
+{
+	struct ina260_chip *chip = iio_priv(indio_dev);
+	unsigned int sampling_us = SAMPLING_PERIOD(chip);
+	struct task_struct *task;
+
+	task = kthread_create(ina260_capture_thread, (void *)indio_dev,
+			      "%s:%d-%uus", indio_dev->name, indio_dev->id,
+			      sampling_us);
+
+	if (IS_ERR(task))
+		return PTR_ERR(task);
+
+	get_task_struct(task);
+	wake_up_process(task);
+	chip->task = task;
+
+	return 0;
+}
+
+static int ina260_buffer_disable(struct iio_dev *indio_dev)
+{
+	struct ina260_chip *chip = iio_priv(indio_dev);
+
+	if (chip->task) {
+		kthread_stop(chip->task);
+		put_task_struct(chip->task);
+		chip->task = NULL;
+	}
+
+	return 0;
+}
+
+static const struct iio_buffer_setup_ops ina260_setup_ops = {
+	.postenable = &ina260_buffer_enable,
+	.predisable = &ina260_buffer_disable,
+};
+
+static int ina260_probe(struct i2c_client *client, const struct i2c_device_id *id)
+{
+	struct iio_dev *indio_dev;
+	struct iio_buffer *buffer;
+	struct ina260_chip *chip;
+	enum ina260_ids type = 0;
+	int ret;
+
+	indio_dev = devm_iio_device_alloc(&client->dev, sizeof(*chip));
+	if (!indio_dev)
+		return -ENOMEM;
+
+	chip = iio_priv(indio_dev);
+	i2c_set_clientdata(client, indio_dev);
+
+	chip->regmap = devm_regmap_init_i2c(client, &ina260_regmap_config);
+	if (IS_ERR(chip->regmap)) {
+		dev_err(&client->dev, "failed to allocate register map\n");
+		return PTR_ERR(chip->regmap);
+	}
+
+	mutex_init(&chip->lock);
+
+	indio_dev->modes = INDIO_DIRECT_MODE | INDIO_BUFFER_SOFTWARE;
+	indio_dev->dev.parent = &client->dev;
+	indio_dev->dev.of_node = client->dev.of_node;
+
+	chip->config = &ina260_config[type];
+	ret = regmap_write(chip->regmap, INA260_CONFIG,
+			   chip->config->config_default);
+	if (ret) {
+		dev_err(&client->dev, "Error configuring the device\n");
+		return ret;
+	}
+	indio_dev->channels = ina260_channels;
+	indio_dev->num_channels = ARRAY_SIZE(ina260_channels);
+	indio_dev->info = &ina260_info;
+	indio_dev->name = id->name;
+	indio_dev->setup_ops = &ina260_setup_ops;
+
+	buffer = devm_iio_kfifo_allocate(&indio_dev->dev);
+	if (!buffer)
+		return -ENOMEM;
+
+	iio_device_attach_buffer(indio_dev, buffer);
+
+	return iio_device_register(indio_dev);
+}
+
+static int ina260_remove(struct i2c_client *client)
+{
+	struct iio_dev *indio_dev = i2c_get_clientdata(client);
+	struct ina260_chip *chip = iio_priv(indio_dev);
+
+	iio_device_unregister(indio_dev);
+	/* Power down */
+	return regmap_update_bits(chip->regmap, INA260_CONFIG, INA260_MODE_MASK, 0);
+}
+
+static const struct i2c_device_id ina260_id[] = {
+	{"ina260", ina260},
+	{}
+};
+MODULE_DEVICE_TABLE(i2c, ina260_id);
+
+static const struct of_device_id ina260_of_match[] = {
+	{
+		.compatible = "ti,ina260",
+		.data = (void *)ina260
+	},
+	{},
+};
+MODULE_DEVICE_TABLE(of, ina260_of_match);
+
+static struct i2c_driver ina260_driver = {
+	.driver = {
+		.name = "ina260-adc",
+		.of_match_table = ina260_of_match,
+	},
+	.probe = ina260_probe,
+	.remove = ina260_remove,
+	.id_table = ina260_id,
+};
+module_i2c_driver(ina260_driver);
+
+MODULE_AUTHOR("Raviteja Narayanam <raviteja.narayanam@xilinx.com>");
+MODULE_DESCRIPTION("Texas Instruments INA 260 ADC driver");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/iio/adc/versal-sysmon.c b/drivers/iio/adc/versal-sysmon.c
new file mode 100644
index 000000000..103011a36
--- /dev/null
+++ b/drivers/iio/adc/versal-sysmon.c
@@ -0,0 +1,1037 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Xilinx SYSMON for Versal
+ *
+ * Copyright (C) 2019 - 2021 Xilinx, Inc.
+ *
+ * Description:
+ * This driver is developed for SYSMON on Versal. The driver supports INDIO Mode
+ * and supports voltage and temperature monitoring via IIO sysfs interface and
+ * in kernel event monitoring for some modules.
+ */
+
+#include "versal-sysmon.h"
+
+/* This structure describes temperature events */
+static const struct iio_event_spec sysmon_temp_events[] = {
+	{
+		.type = IIO_EV_TYPE_THRESH,
+		.dir = IIO_EV_DIR_RISING,
+		.mask_separate = BIT(IIO_EV_INFO_VALUE),
+	},
+	{
+		.type = IIO_EV_TYPE_THRESH,
+		.dir = IIO_EV_DIR_FALLING,
+		.mask_separate = BIT(IIO_EV_INFO_VALUE),
+	},
+	{
+		.type = IIO_EV_TYPE_THRESH,
+		.dir = IIO_EV_DIR_EITHER,
+		.mask_separate =
+			BIT(IIO_EV_INFO_ENABLE) | BIT(IIO_EV_INFO_HYSTERESIS),
+	},
+};
+
+/* This structure describes voltage events */
+static const struct iio_event_spec sysmon_supply_events[] = {
+	{
+		.type = IIO_EV_TYPE_THRESH,
+		.dir = IIO_EV_DIR_RISING,
+		.mask_separate = BIT(IIO_EV_INFO_VALUE),
+	},
+	{
+		.type = IIO_EV_TYPE_THRESH,
+		.dir = IIO_EV_DIR_FALLING,
+		.mask_separate = BIT(IIO_EV_INFO_VALUE),
+	},
+	{
+		.type = IIO_EV_TYPE_THRESH,
+		.dir = IIO_EV_DIR_EITHER,
+		.mask_separate = BIT(IIO_EV_INFO_ENABLE),
+	},
+};
+
+/* Temperature channel attributes */
+static const struct iio_chan_spec temp_channels[] = {
+	SYSMON_CHAN_TEMP(TEMP_MAX, "temp"),
+	SYSMON_CHAN_TEMP(TEMP_MIN, "min"),
+	SYSMON_CHAN_TEMP(TEMP_MAX_MAX, "max_max"),
+	SYSMON_CHAN_TEMP(TEMP_MIN_MIN, "min_min"),
+};
+
+/* Temperature event attributes */
+static const struct iio_chan_spec temp_events[] = {
+	SYSMON_CHAN_TEMP_EVENT(TEMP_EVENT, "temp", sysmon_temp_events),
+	SYSMON_CHAN_TEMP_EVENT(OT_EVENT, "ot", sysmon_temp_events),
+};
+
+static inline void sysmon_read_reg(struct sysmon *sysmon, u32 offset, u32 *data)
+{
+	*data = readl(sysmon->base + offset);
+}
+
+static inline void sysmon_write_reg(struct sysmon *sysmon, u32 offset, u32 data)
+{
+	writel(data, sysmon->base + offset);
+}
+
+static inline void sysmon_update_reg(struct sysmon *sysmon, u32 offset,
+				     u32 mask, u32 data)
+{
+	u32 val;
+
+	sysmon_read_reg(sysmon, offset, &val);
+	sysmon_write_reg(sysmon, offset, (val & ~mask) | (mask & data));
+}
+
+static u32 sysmon_temp_offset(int address)
+{
+	switch (address) {
+	case TEMP_MAX:
+		return SYSMON_TEMP_MAX;
+	case TEMP_MIN:
+		return SYSMON_TEMP_MIN;
+	case TEMP_MAX_MAX:
+		return SYSMON_TEMP_MAX_MAX;
+	case TEMP_MIN_MIN:
+		return SYSMON_TEMP_MIN_MIN;
+	default:
+		return -EINVAL;
+	}
+	return -EINVAL;
+}
+
+static u32 sysmon_temp_thresh_offset(int address, enum iio_event_direction dir)
+{
+	switch (address) {
+	case TEMP_EVENT:
+		return (dir == IIO_EV_DIR_RISING) ? SYSMON_TEMP_TH_UP :
+						    SYSMON_TEMP_TH_LOW;
+	case OT_EVENT:
+		return (dir == IIO_EV_DIR_RISING) ? SYSMON_OT_TH_UP :
+						    SYSMON_OT_TH_LOW;
+	default:
+		return -EINVAL;
+	}
+	return -EINVAL;
+}
+
+static u32 sysmon_supply_offset(int address)
+{
+	return (address * 4) + SYSMON_SUPPLY_BASE;
+}
+
+static u32 sysmon_supply_thresh_offset(int address,
+				       enum iio_event_direction dir)
+{
+	if (dir == IIO_EV_DIR_RISING)
+		return (address * 4) + SYSMON_SUPPLY_TH_UP;
+	else if (dir == IIO_EV_DIR_FALLING)
+		return (address * 4) + SYSMON_SUPPLY_TH_LOW;
+
+	return -EINVAL;
+}
+
+/**
+ * sysmon_q8p7_to_celsius() - converts fixed point Q8.7 format to a fraction.
+ * @raw_data: Raw ADC value
+ * @val: The numerator of the fraction needed by IIO_VAL_PROCESSED
+ * @val2: Denominator of the fraction needed by IIO_VAL_PROCESSED
+ *
+ * The function returns a fraction which returns celsius
+ */
+static void sysmon_q8p7_to_celsius(int raw_data, int *val, int *val2)
+{
+	*val = (raw_data & 0x8000) ? -(twoscomp(raw_data)) : raw_data;
+	*val2 = 128;
+}
+
+/**
+ * sysmon_celsius_to_q8p7() - converts value from IIO Framework to ADC Raw data
+ * @raw_data: Raw ADC value
+ * @val: The numerator of the fraction provided by the IIO Framework
+ * @val2: Denominator of the fraction provided by the IIO Framework
+ *
+ * The function takes in exponent and mantissa as val and val2 respectively
+ * of temperature value in Deg Celsius and returns raw adc value for the
+ * given temperature.
+ */
+static void sysmon_celsius_to_q8p7(u32 *raw_data, int val, int val2)
+{
+	int scale = 1 << 7;
+
+	/* The value is scaled by 10^6 in the IIO framework
+	 * dividing by 1000 twice to avoid overflow
+	 */
+	val2 = val2 / 1000;
+	*raw_data = (val * scale) + ((val2 * scale) / 1000);
+}
+
+static void sysmon_supply_rawtoprocessed(int raw_data, int *val, int *val2)
+{
+	int mantissa, format, exponent;
+
+	mantissa = raw_data & SYSMON_MANTISSA_MASK;
+	exponent = (raw_data & SYSMON_MODE_MASK) >> SYSMON_MODE_SHIFT;
+	format = (raw_data & SYSMON_FMT_MASK) >> SYSMON_FMT_SHIFT;
+
+	*val2 = 1 << (16 - exponent);
+	*val = mantissa;
+	if (format && (mantissa >> SYSMON_MANTISSA_SIGN_SHIFT))
+		*val = (~(mantissa) & SYSMON_MANTISSA_MASK) * -1;
+}
+
+static void sysmon_supply_processedtoraw(int val, int val2, u32 reg_val,
+					 u32 *raw_data)
+{
+	int exponent = (reg_val & SYSMON_MODE_MASK) >> SYSMON_MODE_SHIFT;
+	int format = (reg_val & SYSMON_FMT_MASK) >> SYSMON_FMT_SHIFT;
+	int scale = 1 << (16 - exponent);
+	int tmp;
+
+	/**
+	 * The value is scaled by 10^6 in the IIO framework
+	 * dividing by 1000 twice to avoid overflow
+	 */
+	val2 = val2 / 1000;
+	tmp = (val * scale) + ((val2 * scale) / 1000);
+
+	/* Set out of bound values to saturation levels */
+	if (format) {
+		if (tmp > SYSMON_UPPER_SATURATION_SIGNED)
+			tmp = 0x7fff;
+		else if (tmp < SYSMON_LOWER_SATURATION_SIGNED)
+			tmp = 0x8000;
+
+	} else {
+		if (tmp > SYSMON_UPPER_SATURATION)
+			tmp = 0xffff;
+		else if (tmp < SYSMON_LOWER_SATURATION)
+			tmp = 0x0000;
+	}
+
+	*raw_data = tmp & 0xffff;
+}
+
+static int sysmon_read_raw(struct iio_dev *indio_dev,
+			   struct iio_chan_spec const *chan, int *val,
+			   int *val2, long mask)
+{
+	struct sysmon *sysmon = iio_priv(indio_dev);
+	u32 offset, regval;
+	u32 ret = -EINVAL;
+
+	mutex_lock(&sysmon->mutex);
+	switch (mask) {
+	case IIO_CHAN_INFO_RAW:
+		switch (chan->type) {
+		case IIO_TEMP:
+			offset = sysmon_temp_offset(chan->address);
+			sysmon_read_reg(sysmon, offset, val);
+			*val2 = 0;
+			ret = IIO_VAL_INT;
+			break;
+
+		case IIO_VOLTAGE:
+			offset = sysmon_supply_offset(chan->address);
+			sysmon_read_reg(sysmon, offset, val);
+			*val2 = 0;
+			ret = IIO_VAL_INT;
+			break;
+
+		default:
+			break;
+		}
+		break;
+
+	case IIO_CHAN_INFO_PROCESSED:
+		switch (chan->type) {
+		case IIO_TEMP:
+			/* In Deg C */
+			offset = sysmon_temp_offset(chan->address);
+			sysmon_read_reg(sysmon, offset, &regval);
+			sysmon_q8p7_to_celsius(regval, val, val2);
+			ret = IIO_VAL_FRACTIONAL;
+			break;
+
+		case IIO_VOLTAGE:
+			/* In Volts */
+			offset = sysmon_supply_offset(chan->address);
+			sysmon_read_reg(sysmon, offset, &regval);
+			sysmon_supply_rawtoprocessed(regval, val, val2);
+			ret = IIO_VAL_FRACTIONAL;
+			break;
+
+		default:
+			break;
+		}
+		break;
+
+	default:
+		break;
+	}
+
+	mutex_unlock(&sysmon->mutex);
+	return ret;
+}
+
+static int sysmon_get_event_mask(unsigned long address)
+{
+	if (address == TEMP_EVENT)
+		return BIT(SYSMON_BIT_TEMP);
+	else if (address == OT_EVENT)
+		return BIT(SYSMON_BIT_OT);
+
+	/* return supply */
+	return BIT(address / 32);
+}
+
+static int sysmon_read_alarm_config(struct sysmon *sysmon,
+				    unsigned long address)
+{
+	u32 reg_val;
+	u32 alarm_reg_num = ALARM_REG(address);
+	u32 shift = ALARM_SHIFT(address);
+	u32 offset = SYSMON_ALARM_REG + (4 * alarm_reg_num);
+
+	sysmon_read_reg(sysmon, offset, &reg_val);
+
+	return reg_val & BIT(shift);
+}
+
+static void sysmon_write_alarm_config(struct sysmon *sysmon,
+				      unsigned long address, u32 val)
+{
+	u32 alarm_reg_num = ALARM_REG(address);
+	u32 shift = ALARM_SHIFT(address);
+	u32 offset = SYSMON_ALARM_REG + (4 * alarm_reg_num);
+
+	sysmon_update_reg(sysmon, offset, BIT(shift), (val << shift));
+}
+
+static int sysmon_read_event_config(struct iio_dev *indio_dev,
+				    const struct iio_chan_spec *chan,
+				    enum iio_event_type type,
+				    enum iio_event_direction dir)
+{
+	struct sysmon *sysmon = iio_priv(indio_dev);
+	u32 config_value, imr;
+	u32 alarm_event_mask = sysmon_get_event_mask(chan->address);
+
+	sysmon_read_reg(sysmon, SYSMON_IMR, &imr);
+
+	/* Getting the unmasked interrupts */
+	imr = ~imr;
+
+	if (chan->type == IIO_VOLTAGE) {
+		config_value = sysmon_read_alarm_config(sysmon, chan->address);
+
+		return (config_value && (imr & alarm_event_mask));
+	}
+
+	return (imr & sysmon_get_event_mask(chan->address)) ? 1 : 0;
+}
+
+static int sysmon_write_event_config(struct iio_dev *indio_dev,
+				     const struct iio_chan_spec *chan,
+				     enum iio_event_type type,
+				     enum iio_event_direction dir, int state)
+{
+	struct sysmon *sysmon = iio_priv(indio_dev);
+	u32 alarm_reg_num = ALARM_REG(chan->address);
+	u32 offset = SYSMON_ALARM_REG + (4 * alarm_reg_num);
+	u32 ier = sysmon_get_event_mask(chan->address);
+	u32 alarm_config;
+	unsigned long flags;
+
+	mutex_lock(&sysmon->mutex);
+	spin_lock_irqsave(&sysmon->lock, flags);
+
+	if (chan->type == IIO_VOLTAGE) {
+		sysmon_write_alarm_config(sysmon, chan->address, state);
+
+		sysmon_read_reg(sysmon, offset, &alarm_config);
+
+		if (alarm_config)
+			sysmon_write_reg(sysmon, SYSMON_IER, ier);
+		else
+			sysmon_write_reg(sysmon, SYSMON_IDR, ier);
+	} else {
+		if (state) {
+			sysmon_write_reg(sysmon, SYSMON_IER, ier);
+			sysmon->temp_mask &= ~ier;
+		} else {
+			sysmon_write_reg(sysmon, SYSMON_IDR, ier);
+			sysmon->temp_mask |= ier;
+		}
+	}
+
+	spin_unlock_irqrestore(&sysmon->lock, flags);
+	mutex_unlock(&sysmon->mutex);
+
+	return 0;
+}
+
+static int sysmon_read_event_value(struct iio_dev *indio_dev,
+				   const struct iio_chan_spec *chan,
+				   enum iio_event_type type,
+				   enum iio_event_direction dir,
+				   enum iio_event_info info, int *val,
+				   int *val2)
+{
+	struct sysmon *sysmon = iio_priv(indio_dev);
+	u32 offset, reg_val;
+	u32 mask, shift;
+	u32 ret = -EINVAL;
+
+	mutex_lock(&sysmon->mutex);
+	if (chan->type == IIO_TEMP) {
+		if (info == IIO_EV_INFO_VALUE) {
+			offset = sysmon_temp_thresh_offset(chan->address, dir);
+			sysmon_read_reg(sysmon, offset, &reg_val);
+			sysmon_q8p7_to_celsius(reg_val, val, val2);
+			ret = IIO_VAL_FRACTIONAL;
+		} else if (info == IIO_EV_INFO_HYSTERESIS) {
+			mask = (chan->address == OT_EVENT) ? 0x1 : 0x2;
+			shift = mask - 1;
+			sysmon_read_reg(sysmon, SYSMON_TEMP_EV_CFG, &reg_val);
+			*val = (reg_val & mask) >> shift;
+			*val2 = 0;
+			ret = IIO_VAL_INT;
+		}
+	} else if (chan->type == IIO_VOLTAGE) {
+		offset = sysmon_supply_thresh_offset(chan->address, dir);
+		sysmon_read_reg(sysmon, offset, &reg_val);
+		sysmon_supply_rawtoprocessed(reg_val, val, val2);
+		ret = IIO_VAL_FRACTIONAL;
+	}
+
+	mutex_unlock(&sysmon->mutex);
+	return ret;
+}
+
+static int sysmon_write_event_value(struct iio_dev *indio_dev,
+				    const struct iio_chan_spec *chan,
+				    enum iio_event_type type,
+				    enum iio_event_direction dir,
+				    enum iio_event_info info, int val, int val2)
+{
+	struct sysmon *sysmon = iio_priv(indio_dev);
+	u32 offset, raw_val, reg_val;
+	u32 mask, shift;
+
+	mutex_lock(&sysmon->mutex);
+	if (chan->type == IIO_TEMP) {
+		if (info == IIO_EV_INFO_VALUE) {
+			offset = sysmon_temp_thresh_offset(chan->address, dir);
+			sysmon_celsius_to_q8p7(&reg_val, val, val2);
+			sysmon_write_reg(sysmon, offset, reg_val);
+		} else if (info == IIO_EV_INFO_HYSTERESIS) {
+			/* calculating the mask value for OT and TEMP Alarms */
+			mask = (chan->address == OT_EVENT) ? 1 : 2;
+			shift = mask - 1;
+			sysmon_update_reg(sysmon, SYSMON_TEMP_EV_CFG, mask,
+					  (val << shift));
+		}
+	} else if (chan->type == IIO_VOLTAGE) {
+		offset = sysmon_supply_thresh_offset(chan->address, dir);
+		sysmon_read_reg(sysmon, offset, &reg_val);
+		sysmon_supply_processedtoraw(val, val2, reg_val, &raw_val);
+		sysmon_write_reg(sysmon, offset, raw_val);
+	}
+
+	mutex_unlock(&sysmon->mutex);
+	return 0;
+}
+
+static const struct iio_info iio_dev_info = {
+	.read_raw = sysmon_read_raw,
+	.read_event_config = sysmon_read_event_config,
+	.write_event_config = sysmon_write_event_config,
+	.read_event_value = sysmon_read_event_value,
+	.write_event_value = sysmon_write_event_value,
+};
+
+/* sysmon instance for in kernel exported functions */
+static struct sysmon *g_sysmon;
+
+/**
+ * sysmon_register_temp_ops - register temperature based event handler for a
+ *			      given region.
+ * @cb: callback function pointer.
+ * @data: private data to be passed to the callback.
+ * @region_id: id of the region for which the callback is to be set.
+ * @return: 0 for success and negative number in case of failure.
+ */
+int sysmon_register_temp_ops(void (*cb)(void *data, struct regional_node *node),
+			     void *data, enum sysmon_region region_id)
+{
+	struct sysmon *sysmon = g_sysmon;
+	struct region_info *region;
+	int ret = 0, found = 0;
+
+	if (!cb || !sysmon)
+		return -EINVAL;
+
+	ret = mutex_lock_interruptible(&sysmon->mutex);
+	if (ret) {
+		dev_err(sysmon->dev, "Failed to acquire a lock. Process was interrupted by fatal signals");
+		return ret;
+	}
+
+	if (list_empty(&sysmon->region_list)) {
+		dev_err(sysmon->dev, "Failed to set a callback. HW node info missing in the device tree/ Not supported for this device");
+		ret = -EINVAL;
+		goto exit;
+	}
+
+	list_for_each_entry(region, &sysmon->region_list, list) {
+		if (region->id == region_id) {
+			found = 1;
+			if (region->cb) {
+				dev_err(sysmon->dev, "Error callback already set. Unregister the existing callback to set a new one.");
+				ret = -EINVAL;
+				goto exit;
+			}
+			region->cb = cb;
+			region->data = data;
+			break;
+		}
+	}
+
+	if (!found) {
+		dev_err(sysmon->dev, "Error invalid region. Please select the correct region");
+		ret = -EINVAL;
+	}
+
+exit:
+	mutex_unlock(&sysmon->mutex);
+	return ret;
+}
+EXPORT_SYMBOL(sysmon_register_temp_ops);
+
+/**
+ * sysmon_unregister_temp_ops - Unregister the callback for temperature
+ *				notification.
+ * @region_id: id of the region for which the callback is to be set.
+ * @return: 0 for success and negative number in case of failure.
+ */
+int sysmon_unregister_temp_ops(enum sysmon_region region_id)
+{
+	struct sysmon *sysmon = g_sysmon;
+	struct region_info *region;
+	int ret = 0, found = 0;
+
+	if (!sysmon)
+		return -EINVAL;
+
+	ret = mutex_lock_interruptible(&sysmon->mutex);
+	if (ret) {
+		dev_err(sysmon->dev, "Failed to acquire a lock. Process was interrupted by fatal signals");
+		return ret;
+	}
+
+	if (list_empty(&sysmon->region_list)) {
+		dev_err(sysmon->dev, "Failed to set a callback. HW node info missing in the device tree/ Not supported for this device");
+		ret = -EINVAL;
+		goto exit;
+	}
+
+	list_for_each_entry(region, &sysmon->region_list, list) {
+		if (region->id == region_id) {
+			found = 1;
+			region->cb = NULL;
+			region->data = NULL;
+			break;
+		}
+	}
+
+	if (!found) {
+		dev_err(sysmon->dev, "Error no such region. Please select the correct region");
+		ret = -EINVAL;
+	}
+
+exit:
+	mutex_unlock(&sysmon->mutex);
+	return ret;
+}
+EXPORT_SYMBOL(sysmon_unregister_temp_ops);
+
+/**
+ * sysmon_nodes_by_region - returns the nodes list for a particular region.
+ * @region_id: id for the region for which nodes are requested.
+ * @return: Pointer to the linked list or NULL if region is not present.
+ */
+struct list_head *sysmon_nodes_by_region(enum sysmon_region region_id)
+{
+	struct sysmon *sysmon = g_sysmon;
+	struct region_info *region;
+
+	if (!sysmon)
+		return NULL;
+
+	list_for_each_entry(region, &sysmon->region_list, list) {
+		if (region->id == region_id)
+			return &region->node_list;
+	}
+
+	dev_err(sysmon->dev, "Error invalid region. Please select the correct region");
+
+	return NULL;
+}
+EXPORT_SYMBOL(sysmon_nodes_by_region);
+
+/**
+ * sysmon_get_node_value - returns value of the sensor at a node.
+ * @sat_id: id of the node.
+ * @return: -EINVAL if not initialized or returns raw value of the sensor.
+ */
+int sysmon_get_node_value(int sat_id)
+{
+	struct sysmon *sysmon = g_sysmon;
+	u32 raw;
+
+	if (!sysmon)
+		return -EINVAL;
+
+	sysmon_read_reg(sysmon, SYSMON_NODE_OFFSET, &raw);
+
+	return raw;
+}
+EXPORT_SYMBOL(sysmon_get_node_value);
+
+static void sysmon_push_event(struct iio_dev *indio_dev, u32 address)
+{
+	u32 i;
+	const struct iio_chan_spec *chan;
+
+	for (i = 0; i < indio_dev->num_channels; i++) {
+		if (indio_dev->channels[i].address == address) {
+			chan = &indio_dev->channels[i];
+			iio_push_event(indio_dev,
+				       IIO_UNMOD_EVENT_CODE(chan->type,
+							    chan->channel,
+							    IIO_EV_TYPE_THRESH,
+							    IIO_EV_DIR_EITHER),
+				       iio_get_time_ns(indio_dev));
+		}
+	}
+}
+
+static void sysmon_region_event_handler(struct sysmon *sysmon)
+{
+	struct region_info *region;
+	struct regional_node *node, *eventnode;
+	u32 regval, event = 0;
+	u16 thresh_up, val;
+
+	sysmon_read_reg(sysmon, SYSMON_TEMP_TH_UP, &regval);
+	thresh_up = (u16)regval;
+
+	list_for_each_entry(region, &sysmon->region_list, list) {
+		list_for_each_entry(node, &region->node_list,
+				    regional_node_list) {
+			val = sysmon_get_node_value(node->sat_id);
+
+			/* Find the highest value */
+			if (compare(val, thresh_up)) {
+				eventnode = node;
+				eventnode->temp = val;
+				thresh_up = val;
+				event = 1;
+			}
+		}
+		if (event && region->cb)
+			region->cb(region->data, eventnode);
+	}
+}
+
+static void sysmon_handle_event(struct iio_dev *indio_dev, u32 event)
+{
+	struct sysmon *sysmon = iio_priv(indio_dev);
+	unsigned long alarm_flag_reg;
+	u32 address, bit, reg_val;
+	u32 alarm_flag_offset = SYSMON_ALARM_FLAG + (event * 4);
+	u32 alarm_reg_offset = SYSMON_ALARM_REG + (event * 4);
+
+	switch (event) {
+	case SYSMON_BIT_TEMP:
+		address = TEMP_EVENT;
+		sysmon_push_event(indio_dev, address);
+		sysmon_write_reg(sysmon, SYSMON_IDR, BIT(SYSMON_BIT_TEMP));
+		sysmon->masked_temp |= BIT(SYSMON_BIT_TEMP);
+		sysmon_region_event_handler(sysmon);
+		break;
+
+	case SYSMON_BIT_OT:
+		address = OT_EVENT;
+		sysmon_push_event(indio_dev, address);
+		sysmon_write_reg(sysmon, SYSMON_IDR, BIT(SYSMON_BIT_OT));
+		sysmon->masked_temp |= BIT(SYSMON_BIT_OT);
+		sysmon_region_event_handler(sysmon);
+		break;
+
+	case SYSMON_BIT_ALARM4:
+	case SYSMON_BIT_ALARM3:
+	case SYSMON_BIT_ALARM2:
+	case SYSMON_BIT_ALARM1:
+	case SYSMON_BIT_ALARM0:
+		/* Read enabled alarms */
+		sysmon_read_reg(sysmon, alarm_flag_offset, &reg_val);
+		alarm_flag_reg = (unsigned long)reg_val;
+
+		for_each_set_bit(bit, &alarm_flag_reg, 32) {
+			address = bit + (32 * event);
+			sysmon_push_event(indio_dev, address);
+			/* disable alarm */
+			sysmon_update_reg(sysmon, alarm_reg_offset, BIT(bit),
+					  0);
+		}
+		/* clear alarms */
+		sysmon_write_reg(sysmon, alarm_flag_offset, alarm_flag_reg);
+		break;
+
+	default:
+		break;
+	}
+}
+
+static void sysmon_handle_events(struct iio_dev *indio_dev,
+				 unsigned long events)
+{
+	unsigned int bit;
+
+	for_each_set_bit(bit, &events, SYSMON_NO_OF_EVENTS)
+		sysmon_handle_event(indio_dev, bit);
+}
+
+static void sysmon_unmask_temp(struct sysmon *sysmon, unsigned int isr)
+{
+	unsigned int unmask, status;
+
+	status = isr & SYSMON_TEMP_MASK;
+
+	/* clear bits that are not active any more */
+	unmask = (sysmon->masked_temp ^ status) & sysmon->masked_temp;
+	sysmon->masked_temp &= status;
+
+	/* clear status of disabled alarm */
+	unmask &= ~sysmon->temp_mask;
+
+	sysmon_write_reg(sysmon, SYSMON_IER, unmask);
+}
+
+/*
+ * The Versal threshold interrupts are level sensitive. Since we can't make the
+ * threshold condition go way from within the interrupt handler, this means as
+ * soon as a threshold condition is present we would enter the interrupt handler
+ * again and again. To work around this we mask all active thresholds interrupts
+ * in the interrupt handler and start a timer. In this timer we poll the
+ * interrupt status and only if the interrupt is inactive we unmask it again.
+ */
+static void sysmon_unmask_worker(struct work_struct *work)
+{
+	struct sysmon *sysmon = container_of(work, struct sysmon,
+					     sysmon_unmask_work.work);
+	unsigned int isr;
+
+	spin_lock_irq(&sysmon->lock);
+
+	/* Read the current interrupt status */
+	sysmon_read_reg(sysmon, SYSMON_ISR, &isr);
+
+	/* Clear interrupts */
+	sysmon_write_reg(sysmon, SYSMON_ISR, isr);
+
+	sysmon_unmask_temp(sysmon, isr);
+
+	spin_unlock_irq(&sysmon->lock);
+
+	/* if still pending some alarm re-trigger the timer */
+	if (sysmon->masked_temp)
+		schedule_delayed_work(&sysmon->sysmon_unmask_work,
+				      msecs_to_jiffies(500));
+	else
+		/*
+		 * Reset the temp_max_max and temp_min_min values to reset the
+		 * previously reached high/low values during an alarm.
+		 * This will enable the user to see the high/low values attained
+		 * during an event
+		 */
+		sysmon_write_reg(sysmon, SYSMON_STATUS_RESET, 1);
+}
+
+static irqreturn_t sysmon_iio_irq(int irq, void *data)
+{
+	u32 isr, imr;
+	struct iio_dev *indio_dev = data;
+	struct sysmon *sysmon = iio_priv(indio_dev);
+
+	spin_lock(&sysmon->lock);
+
+	sysmon_read_reg(sysmon, SYSMON_ISR, &isr);
+	sysmon_read_reg(sysmon, SYSMON_IMR, &imr);
+
+	/* only process alarm that are not masked */
+	isr &= ~imr;
+
+	/* clear interrupt */
+	sysmon_write_reg(sysmon, SYSMON_ISR, isr);
+
+	if (isr) {
+		sysmon_handle_events(indio_dev, isr);
+
+		schedule_delayed_work(&sysmon->sysmon_unmask_work,
+				      msecs_to_jiffies(500));
+	}
+
+	spin_unlock(&sysmon->lock);
+
+	return IRQ_HANDLED;
+}
+
+static int get_hw_node_properties(struct platform_device *pdev,
+				  struct list_head *region_list)
+{
+	struct region_info *region = NULL;
+	struct regional_node *nodes;
+	struct device_node *np = pdev->dev.of_node;
+	int size;
+	u32 id, satid, x, y, i, offset, prev = 0;
+
+	/* get hw-node-info */
+	if (!of_get_property(np, "hw-node", &size))
+		return 0;
+
+	if (size % 16) {
+		dev_info(&pdev->dev, "HW-Node properties not correct");
+		return -EINVAL;
+	}
+
+	for (i = 0; i < (size / 16); i++) {
+		offset = i * 4;
+		of_property_read_u32_index(np, "hw-node", offset, &id);
+		of_property_read_u32_index(np, "hw-node", offset + 1, &satid);
+		of_property_read_u32_index(np, "hw-node", offset + 2, &x);
+		of_property_read_u32_index(np, "hw-node", offset + 3, &y);
+
+		if (list_empty(region_list) || prev != id) {
+			region = devm_kzalloc(&pdev->dev, sizeof(*region),
+					      GFP_KERNEL);
+			if (!region)
+				return -ENOMEM;
+
+			region->id = id;
+			INIT_LIST_HEAD(&region->node_list);
+			list_add(&region->list, region_list);
+		}
+
+		prev = id;
+		nodes = devm_kzalloc(&pdev->dev, sizeof(*nodes), GFP_KERNEL);
+		if (!nodes)
+			return -ENOMEM;
+		nodes->sat_id = satid;
+		nodes->x = x;
+		nodes->y = y;
+		list_add(&nodes->regional_node_list, &region->node_list);
+	}
+
+	return 0;
+}
+
+static int sysmon_parse_dt(struct iio_dev *indio_dev,
+			   struct platform_device *pdev)
+{
+	struct sysmon *sysmon;
+	struct iio_chan_spec *sysmon_channels;
+	struct device_node *child_node = NULL, *np = pdev->dev.of_node;
+	int ret, i = 0;
+	u8 num_supply_chan = 0;
+	u32 reg = 0, num_temp_chan = 0;
+	const char *name;
+	u32 chan_size = sizeof(struct iio_chan_spec);
+	u32 temp_chan_size;
+
+	sysmon = iio_priv(indio_dev);
+	ret = of_property_read_u8(np, "xlnx,numchannels", &num_supply_chan);
+	if (ret < 0)
+		return ret;
+
+	INIT_LIST_HEAD(&sysmon->region_list);
+
+	if (sysmon->irq > 0)
+		get_hw_node_properties(pdev, &sysmon->region_list);
+
+	/* Initialize buffer for channel specification */
+	temp_chan_size = (sysmon->irq > 0) ? (sizeof(temp_channels) +
+					      sizeof(temp_events)) :
+		sizeof(temp_channels);
+
+	num_temp_chan = ARRAY_SIZE(temp_channels);
+
+	sysmon_channels = devm_kzalloc(&pdev->dev,
+				       (chan_size * num_supply_chan) +
+				       temp_chan_size, GFP_KERNEL);
+
+	for_each_child_of_node(np, child_node) {
+		ret = of_property_read_u32(child_node, "reg", &reg);
+		if (ret < 0)
+			return ret;
+
+		ret = of_property_read_string(child_node, "xlnx,name", &name);
+		if (ret < 0)
+			return ret;
+
+		sysmon_channels[i].type = IIO_VOLTAGE;
+		sysmon_channels[i].indexed = 1;
+		sysmon_channels[i].address = reg;
+		sysmon_channels[i].channel = reg;
+		sysmon_channels[i].info_mask_separate =
+			BIT(IIO_CHAN_INFO_RAW) | BIT(IIO_CHAN_INFO_PROCESSED);
+
+		if (sysmon->irq > 0) {
+			sysmon_channels[i].event_spec = sysmon_supply_events;
+			sysmon_channels[i].num_event_specs =
+				ARRAY_SIZE(sysmon_supply_events);
+		}
+
+		sysmon_channels[i].scan_index = i;
+		sysmon_channels[i].scan_type.realbits = 19;
+		sysmon_channels[i].scan_type.storagebits = 32;
+
+		sysmon_channels[i].scan_type.endianness = IIO_CPU;
+		sysmon_channels[i].extend_name = name;
+
+		if (of_property_read_bool(child_node, "xlnx,bipolar"))
+			sysmon_channels[i].scan_type.sign = 's';
+		else
+			sysmon_channels[i].scan_type.sign = 'u';
+
+		i++;
+	}
+
+	/* Append static temperature channels to the channel list */
+	memcpy(sysmon_channels + num_supply_chan, temp_channels,
+	       sizeof(temp_channels));
+	indio_dev->num_channels = num_supply_chan + ARRAY_SIZE(temp_channels);
+
+	if (sysmon->irq > 0) {
+		memcpy(sysmon_channels + num_supply_chan + num_temp_chan,
+		       temp_events, sizeof(temp_events));
+		indio_dev->num_channels += ARRAY_SIZE(temp_events);
+	}
+
+	indio_dev->channels = sysmon_channels;
+
+	return 0;
+}
+
+static void sysmon_init_interrupt(struct sysmon *sysmon)
+{
+	u32 imr;
+
+	/* Read default Interrupt Mask */
+	sysmon_read_reg(sysmon, SYSMON_IMR, &imr);
+	sysmon->temp_mask = imr & SYSMON_TEMP_MASK;
+}
+
+static int sysmon_probe(struct platform_device *pdev)
+{
+	struct iio_dev *indio_dev;
+	struct sysmon *sysmon;
+	struct resource *mem;
+	int ret;
+
+	indio_dev = devm_iio_device_alloc(&pdev->dev, sizeof(*sysmon));
+	if (!indio_dev)
+		return -ENOMEM;
+
+	sysmon = iio_priv(indio_dev);
+
+	sysmon->dev = &pdev->dev;
+
+	mutex_init(&sysmon->mutex);
+	spin_lock_init(&sysmon->lock);
+
+	indio_dev->dev.parent = &pdev->dev;
+	indio_dev->dev.of_node = pdev->dev.of_node;
+	indio_dev->name = "xlnx,versal-sysmon";
+	indio_dev->info = &iio_dev_info;
+	indio_dev->modes = INDIO_DIRECT_MODE;
+
+	mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	sysmon->base = devm_ioremap_resource(&pdev->dev, mem);
+	if (IS_ERR(sysmon->base))
+		return PTR_ERR(sysmon->base);
+
+	sysmon_write_reg(sysmon, SYSMON_NPI_LOCK, NPI_UNLOCK);
+
+	sysmon->irq = platform_get_irq_optional(pdev, 0);
+
+	ret = sysmon_parse_dt(indio_dev, pdev);
+	if (ret)
+		return ret;
+
+	if (sysmon->irq > 0) {
+		g_sysmon = sysmon;
+		INIT_DELAYED_WORK(&sysmon->sysmon_unmask_work,
+				  sysmon_unmask_worker);
+		sysmon_init_interrupt(sysmon);
+		ret = devm_request_irq(&pdev->dev, sysmon->irq, &sysmon_iio_irq,
+				       0, "sysmon-irq", indio_dev);
+		if (ret < 0)
+			return ret;
+	} else if (sysmon->irq == -EPROBE_DEFER) {
+		return -EPROBE_DEFER;
+	}
+
+	platform_set_drvdata(pdev, indio_dev);
+
+	ret = iio_device_register(indio_dev);
+	if (ret < 0)
+		return ret;
+
+	dev_info(&pdev->dev, "Successfully registered Versal Sysmon");
+
+	return 0;
+}
+
+static int sysmon_remove(struct platform_device *pdev)
+{
+	struct iio_dev *indio_dev = platform_get_drvdata(pdev);
+
+	/* Unregister the device */
+	iio_device_unregister(indio_dev);
+	return 0;
+}
+
+static int sysmon_resume(struct platform_device *pdev)
+{
+	struct iio_dev *indio_dev = platform_get_drvdata(pdev);
+	struct sysmon *sysmon = iio_priv(indio_dev);
+
+	sysmon_write_reg(sysmon, SYSMON_NPI_LOCK, NPI_UNLOCK);
+
+	return 0;
+}
+
+static const struct of_device_id sysmon_of_match_table[] = {
+	{ .compatible = "xlnx,versal-sysmon" },
+	{}
+};
+MODULE_DEVICE_TABLE(of, sysmon_of_match_table);
+
+static struct platform_driver sysmon_driver = {
+	.probe = sysmon_probe,
+	.remove = sysmon_remove,
+	.resume = sysmon_resume,
+	.driver = {
+		.name = "sysmon",
+		.of_match_table = sysmon_of_match_table,
+	},
+};
+module_platform_driver(sysmon_driver);
+
+MODULE_LICENSE("GPL v2");
+MODULE_DESCRIPTION("Xilinx Versal SysMon Driver");
+MODULE_AUTHOR("Anand Ashok Dumbre <anand.ashok.dumbre@xilinx.com>");
diff --git a/drivers/iio/adc/versal-sysmon.h b/drivers/iio/adc/versal-sysmon.h
new file mode 100644
index 000000000..566c69fdd
--- /dev/null
+++ b/drivers/iio/adc/versal-sysmon.h
@@ -0,0 +1,170 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Xilinx SYSMON for Versal
+ *
+ * Copyright (C) 2019 - 2021 Xilinx, Inc.
+ *
+ * Description:
+ * This driver is developed for SYSMON on Versal. The driver supports INDIO Mode
+ * and supports voltage and temperature monitoring via IIO sysfs interface.
+ */
+
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/iio/buffer.h>
+#include <linux/iio/events.h>
+#include <linux/iio/sysfs.h>
+#include <linux/iio/adc/versal-sysmon-events.h>
+#include <linux/iopoll.h>
+#include <linux/kernel.h>
+#include <linux/list.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/of_address.h>
+
+/* Channel IDs for Temp Channels */
+/* TEMP_MAX gives the current temperature for Production
+ * silicon.
+ * TEMP_MAX gives the current maximum temperature for ES1
+ * silicon.
+ */
+#define TEMP_MAX	160
+
+/* TEMP_MIN is not applicable for Production silicon.
+ * TEMP_MIN gives the current minimum temperature for ES1 silicon.
+ */
+#define TEMP_MIN	161
+
+#define TEMP_MAX_MAX	162
+#define TEMP_MIN_MIN	163
+#define TEMP_EVENT	164
+#define OT_EVENT	165
+
+/* Register Unlock Code */
+#define NPI_UNLOCK	0xF9E8D7C6
+
+/* Register Offsets */
+#define SYSMON_NPI_LOCK		0x000C
+#define SYSMON_ISR		0x0044
+#define SYSMON_TEMP_MASK	0x300
+#define SYSMON_IMR		0x0048
+#define SYSMON_IER		0x004C
+#define SYSMON_IDR		0x0050
+#define SYSMON_ALARM_FLAG	0x1018
+#define SYSMON_TEMP_MAX		0x1030
+#define SYSMON_TEMP_MIN		0x1034
+#define SYSMON_SUPPLY_BASE	0x1040
+#define SYSMON_ALARM_REG	0x1940
+#define SYSMON_TEMP_TH_LOW	0x1970
+#define SYSMON_TEMP_TH_UP	0x1974
+#define SYSMON_OT_TH_LOW	0x1978
+#define SYSMON_OT_TH_UP		0x197C
+#define SYSMON_SUPPLY_TH_LOW	0x1980
+#define SYSMON_SUPPLY_TH_UP	0x1C80
+#define SYSMON_TEMP_MAX_MAX	0x1F90
+#define SYSMON_TEMP_MIN_MIN	0x1F8C
+#define SYSMON_TEMP_EV_CFG	0x1F84
+#define SYSMON_NODE_OFFSET	0x1FAC
+#define SYSMON_STATUS_RESET	0x1F94
+
+#define SYSMON_NO_OF_EVENTS	32
+
+/* Supply Voltage Conversion macros */
+#define SYSMON_MANTISSA_MASK		0xFFFF
+#define SYSMON_FMT_MASK			0x10000
+#define SYSMON_FMT_SHIFT		16
+#define SYSMON_MODE_MASK		0x60000
+#define SYSMON_MODE_SHIFT		17
+#define SYSMON_MANTISSA_SIGN_SHIFT	15
+#define SYSMON_UPPER_SATURATION_SIGNED	32767
+#define SYSMON_LOWER_SATURATION_SIGNED	-32768
+#define SYSMON_UPPER_SATURATION		65535
+#define SYSMON_LOWER_SATURATION		0
+
+#define SYSMON_CHAN_TEMP_EVENT(_address, _ext, _events) { \
+	.type = IIO_TEMP, \
+	.indexed = 1, \
+	.address = _address, \
+	.channel = _address, \
+	.event_spec = _events, \
+	.num_event_specs = ARRAY_SIZE(_events), \
+	.scan_type = { \
+		.sign = 's', \
+		.realbits = 15, \
+		.storagebits = 16, \
+		.endianness = IIO_CPU, \
+	}, \
+	.extend_name = _ext, \
+	}
+
+#define SYSMON_CHAN_TEMP(_address, _ext) { \
+	.type = IIO_TEMP, \
+	.indexed = 1, \
+	.address = _address, \
+	.channel = _address, \
+	.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) | \
+		BIT(IIO_CHAN_INFO_PROCESSED), \
+	.scan_type = { \
+		.sign = 's', \
+		.realbits = 15, \
+		.storagebits = 16, \
+		.endianness = IIO_CPU, \
+	}, \
+	.extend_name = _ext, \
+}
+
+#define twoscomp(val) ((((val) ^ 0xFFFF) + 1) & 0x0000FFFF)
+#define ALARM_REG(address) ((address) / 32)
+#define ALARM_SHIFT(address) ((address) % 32)
+
+#define compare(val, thresh) (((val) & 0x8000) || ((thresh) & 0x8000) ? \
+			      ((val) < (thresh)) : ((val) > (thresh)))  \
+
+enum sysmon_alarm_bit {
+	SYSMON_BIT_ALARM0 = 0,
+	SYSMON_BIT_ALARM1 = 1,
+	SYSMON_BIT_ALARM2 = 2,
+	SYSMON_BIT_ALARM3 = 3,
+	SYSMON_BIT_ALARM4 = 4,
+	SYSMON_BIT_ALARM5 = 5,
+	SYSMON_BIT_ALARM6 = 6,
+	SYSMON_BIT_ALARM7 = 7,
+	SYSMON_BIT_OT = 8,
+	SYSMON_BIT_TEMP = 9,
+};
+
+/**
+ * struct sysmon - Driver data for Sysmon
+ * @base: physical base address of device
+ * @dev: pointer to device struct
+ * @mutex: to handle multiple user interaction
+ * @lock: to help manage interrupt registers correctly
+ * @irq: interrupt number of the sysmon
+ * @region_list: list of the regions of sysmon
+ * @masked_temp: currently masked due to alarm
+ * @temp_mask: temperature based interrupt configuration
+ * @sysmon_unmask_work: re-enables event once the event condition disappears
+ *
+ * This structure contains necessary state for Sysmon driver to operate
+ */
+struct sysmon {
+	void __iomem *base;
+	struct device *dev;
+	/* kernel doc above */
+	struct mutex mutex;
+	/* kernel doc above*/
+	spinlock_t lock;
+	int irq;
+	struct list_head region_list;
+	unsigned int masked_temp;
+	unsigned int temp_mask;
+	struct delayed_work sysmon_unmask_work;
+};
+
+int sysmon_register_temp_ops(void (*cb)(void *data, struct regional_node *node),
+			     void *data, enum sysmon_region region_id);
+int sysmon_unregister_temp_ops(enum sysmon_region region_id);
+struct list_head *sysmon_nodes_by_region(enum sysmon_region region_id);
+int sysmon_get_node_value(int sat_id);
diff --git a/drivers/iio/adc/xilinx-ams.c b/drivers/iio/adc/xilinx-ams.c
new file mode 100644
index 000000000..9fe6faed9
--- /dev/null
+++ b/drivers/iio/adc/xilinx-ams.c
@@ -0,0 +1,1115 @@
+/*
+ * Xilinx AMS driver
+ *
+ * Licensed under the GPL-2
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/module.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/clk.h>
+#include <linux/of_address.h>
+#include <linux/iopoll.h>
+
+#include <linux/iio/iio.h>
+#include <linux/iio/sysfs.h>
+#include <linux/iio/events.h>
+#include <linux/iio/buffer.h>
+#include <linux/io.h>
+
+#include "xilinx-ams.h"
+#include <linux/delay.h>
+
+static const unsigned int AMS_UNMASK_TIMEOUT = 500;
+
+static inline void ams_read_reg(struct ams *ams, unsigned int offset, u32 *data)
+{
+	*data = readl(ams->base + offset);
+}
+
+static inline void ams_write_reg(struct ams *ams, unsigned int offset, u32 data)
+{
+	writel(data, ams->base + offset);
+}
+
+static inline void ams_update_reg(struct ams *ams, unsigned int offset,
+				  u32 mask, u32 data)
+{
+	u32 val;
+
+	ams_read_reg(ams, offset, &val);
+	ams_write_reg(ams, offset, (val & ~mask) | (mask & data));
+}
+
+static inline void ams_ps_read_reg(struct ams *ams, unsigned int offset,
+				   u32 *data)
+{
+	*data = readl(ams->ps_base + offset);
+}
+
+static inline void ams_ps_write_reg(struct ams *ams, unsigned int offset,
+				    u32 data)
+{
+	writel(data, ams->ps_base + offset);
+}
+
+static inline void ams_ps_update_reg(struct ams *ams, unsigned int offset,
+				     u32 mask, u32 data)
+{
+	u32 val;
+
+	ams_ps_read_reg(ams, offset, &val);
+	ams_ps_write_reg(ams, offset, (val & ~mask) | (data & mask));
+}
+
+static inline void ams_apb_pl_read_reg(struct ams *ams, unsigned int offset,
+				       u32 *data)
+{
+	*data = readl(ams->pl_base + offset);
+}
+
+static inline void ams_apb_pl_write_reg(struct ams *ams, unsigned int offset,
+					u32 data)
+{
+	writel(data, ams->pl_base + offset);
+}
+
+static inline void ams_apb_pl_update_reg(struct ams *ams, unsigned int offset,
+					 u32 mask, u32 data)
+{
+	u32 val;
+
+	ams_apb_pl_read_reg(ams, offset, &val);
+	ams_apb_pl_write_reg(ams, offset, (val & ~mask) | (data & mask));
+}
+
+static void ams_update_intrmask(struct ams *ams, u64 mask, u64 val)
+{
+	/* intr_mask variable in ams represent bit in AMS regisetr IDR0 and IDR1
+	 * first 32 biit will be of IDR0, next one are of IDR1 register.
+	 */
+	ams->intr_mask &= ~mask;
+	ams->intr_mask |= (val & mask);
+
+	ams_write_reg(ams, AMS_IER_0, ~(ams->intr_mask | ams->masked_alarm));
+	ams_write_reg(ams, AMS_IER_1,
+		      ~(ams->intr_mask >> AMS_ISR1_INTR_MASK_SHIFT));
+	ams_write_reg(ams, AMS_IDR_0, ams->intr_mask | ams->masked_alarm);
+	ams_write_reg(ams, AMS_IDR_1,
+		      ams->intr_mask >> AMS_ISR1_INTR_MASK_SHIFT);
+}
+
+static void iio_ams_disable_all_alarm(struct ams *ams)
+{
+	/* disable PS module alarm */
+	if (ams->ps_base) {
+		ams_ps_update_reg(ams, AMS_REG_CONFIG1, AMS_REGCFG1_ALARM_MASK,
+				  AMS_REGCFG1_ALARM_MASK);
+		ams_ps_update_reg(ams, AMS_REG_CONFIG3, AMS_REGCFG3_ALARM_MASK,
+				  AMS_REGCFG3_ALARM_MASK);
+	}
+
+	/* disable PL module alarm */
+	if (ams->pl_base) {
+		ams->pl_bus->update(ams, AMS_REG_CONFIG1,
+				    AMS_REGCFG1_ALARM_MASK,
+				    AMS_REGCFG1_ALARM_MASK);
+		ams->pl_bus->update(ams, AMS_REG_CONFIG3,
+				    AMS_REGCFG3_ALARM_MASK,
+				    AMS_REGCFG3_ALARM_MASK);
+	}
+}
+
+static void iio_ams_update_alarm(struct ams *ams, unsigned long alarm_mask)
+{
+	u32 cfg;
+	unsigned long flags;
+	unsigned long pl_alarm_mask;
+
+	if (ams->ps_base) {
+		/* Configuring PS alarm enable */
+		cfg = ~((alarm_mask & AMS_ISR0_ALARM_2_TO_0_MASK) <<
+			       AMS_CONF1_ALARM_2_TO_0_SHIFT);
+		cfg &= ~((alarm_mask & AMS_ISR0_ALARM_6_TO_3_MASK) <<
+				AMS_CONF1_ALARM_6_TO_3_SHIFT);
+		ams_ps_update_reg(ams, AMS_REG_CONFIG1, AMS_REGCFG1_ALARM_MASK,
+				  cfg);
+
+		cfg = ~((alarm_mask >> AMS_CONF3_ALARM_12_TO_7_SHIFT) &
+				AMS_ISR0_ALARM_12_TO_7_MASK);
+		ams_ps_update_reg(ams, AMS_REG_CONFIG3, AMS_REGCFG3_ALARM_MASK,
+				  cfg);
+	}
+
+	if (ams->pl_base) {
+		pl_alarm_mask = (alarm_mask >> AMS_PL_ALARM_START);
+		/* Configuring PL alarm enable */
+		cfg = ~((pl_alarm_mask & AMS_ISR0_ALARM_2_TO_0_MASK) <<
+			       AMS_CONF1_ALARM_2_TO_0_SHIFT);
+		cfg &= ~((pl_alarm_mask & AMS_ISR0_ALARM_6_TO_3_MASK) <<
+				AMS_CONF1_ALARM_6_TO_3_SHIFT);
+		ams->pl_bus->update(ams, AMS_REG_CONFIG1,
+				AMS_REGCFG1_ALARM_MASK, cfg);
+
+		cfg = ~((pl_alarm_mask >> AMS_CONF3_ALARM_12_TO_7_SHIFT) &
+				AMS_ISR0_ALARM_12_TO_7_MASK);
+		ams->pl_bus->update(ams, AMS_REG_CONFIG3,
+				AMS_REGCFG3_ALARM_MASK, cfg);
+	}
+
+	spin_lock_irqsave(&ams->lock, flags);
+	ams_update_intrmask(ams, AMS_ISR0_ALARM_MASK, ~alarm_mask);
+	spin_unlock_irqrestore(&ams->lock, flags);
+}
+
+static void ams_enable_channel_sequence(struct ams *ams)
+{
+	int i;
+	unsigned long long scan_mask;
+	struct iio_dev *indio_dev = ams->indio_dev;
+
+	/* Enable channel sequence. First 22 bit of scan_mask represent
+	 * PS channels, and  next remaining bit represents PL channels.
+	 */
+
+	/* Run calibration of PS & PL as part of the sequence */
+	scan_mask = 1 | (1 << PS_SEQ_MAX);
+	for (i = 0; i < indio_dev->num_channels; i++)
+		scan_mask |= BIT(indio_dev->channels[i].scan_index);
+
+	if (ams->ps_base) {
+		/* put sysmon in a soft reset to change the sequence */
+		ams_ps_update_reg(ams, AMS_REG_CONFIG1, AMS_CONF1_SEQ_MASK,
+				  AMS_CONF1_SEQ_DEFAULT);
+
+		/* configure basic channels */
+		ams_ps_write_reg(ams, AMS_REG_SEQ_CH0,
+				 scan_mask & AMS_REG_SEQ0_MASK);
+		ams_ps_write_reg(ams, AMS_REG_SEQ_CH2, AMS_REG_SEQ2_MASK &
+				(scan_mask >> AMS_REG_SEQ2_MASK_SHIFT));
+
+		/* set continuous sequence mode */
+		ams_ps_update_reg(ams, AMS_REG_CONFIG1, AMS_CONF1_SEQ_MASK,
+				  AMS_CONF1_SEQ_CONTINUOUS);
+	}
+
+	if (ams->pl_base) {
+		/* put sysmon in a soft reset to change the sequence */
+		ams->pl_bus->update(ams, AMS_REG_CONFIG1, AMS_CONF1_SEQ_MASK,
+				    AMS_CONF1_SEQ_DEFAULT);
+
+		/* configure basic channels */
+		scan_mask = (scan_mask >> PS_SEQ_MAX);
+		ams->pl_bus->write(ams, AMS_REG_SEQ_CH0,
+				scan_mask & AMS_REG_SEQ0_MASK);
+		ams->pl_bus->write(ams, AMS_REG_SEQ_CH2, AMS_REG_SEQ2_MASK &
+				(scan_mask >> AMS_REG_SEQ2_MASK_SHIFT));
+		ams->pl_bus->write(ams, AMS_REG_SEQ_CH1, AMS_REG_SEQ1_MASK &
+				(scan_mask >> AMS_REG_SEQ1_MASK_SHIFT));
+
+		/* set continuous sequence mode */
+		ams->pl_bus->update(ams, AMS_REG_CONFIG1, AMS_CONF1_SEQ_MASK,
+				AMS_CONF1_SEQ_CONTINUOUS);
+	}
+}
+
+static int iio_ams_init_device(struct ams *ams)
+{
+	int ret = 0;
+	u32 reg;
+
+	/* reset AMS */
+	if (ams->ps_base) {
+		ams_ps_write_reg(ams, AMS_VP_VN, AMS_PS_RESET_VALUE);
+
+		ret = readl_poll_timeout(ams->base + AMS_PS_CSTS, reg,
+					 (reg & AMS_PS_CSTS_PS_READY) ==
+					 AMS_PS_CSTS_PS_READY, 0,
+					 AMS_INIT_TIMEOUT);
+		if (ret)
+			return ret;
+
+		/* put sysmon in a default state */
+		ams_ps_update_reg(ams, AMS_REG_CONFIG1, AMS_CONF1_SEQ_MASK,
+				  AMS_CONF1_SEQ_DEFAULT);
+	}
+
+	if (ams->pl_base) {
+		ams->pl_bus->write(ams, AMS_VP_VN, AMS_PL_RESET_VALUE);
+
+		ret = readl_poll_timeout(ams->base + AMS_PL_CSTS, reg,
+					 (reg & AMS_PL_CSTS_ACCESS_MASK) ==
+					 AMS_PL_CSTS_ACCESS_MASK, 0,
+					 AMS_INIT_TIMEOUT);
+		if (ret)
+			return ret;
+
+		/* put sysmon in a default state */
+		ams->pl_bus->update(ams, AMS_REG_CONFIG1, AMS_CONF1_SEQ_MASK,
+				    AMS_CONF1_SEQ_DEFAULT);
+	}
+
+	iio_ams_disable_all_alarm(ams);
+
+	/* Disable interrupt */
+	ams_update_intrmask(ams, ~0, ~0);
+
+	/* Clear any pending interrupt */
+	ams_write_reg(ams, AMS_ISR_0, AMS_ISR0_ALARM_MASK);
+	ams_write_reg(ams, AMS_ISR_1, AMS_ISR1_ALARM_MASK);
+
+	return ret;
+}
+
+static void ams_enable_single_channel(struct ams *ams, unsigned int offset)
+{
+	u8 channel_num = 0;
+
+	switch (offset) {
+	case AMS_VCC_PSPLL0:
+		channel_num = AMS_VCC_PSPLL0_CH;
+		break;
+	case AMS_VCC_PSPLL3:
+		channel_num = AMS_VCC_PSPLL3_CH;
+		break;
+	case AMS_VCCINT:
+		channel_num = AMS_VCCINT_CH;
+		break;
+	case AMS_VCCBRAM:
+		channel_num = AMS_VCCBRAM_CH;
+		break;
+	case AMS_VCCAUX:
+		channel_num = AMS_VCCAUX_CH;
+		break;
+	case AMS_PSDDRPLL:
+		channel_num = AMS_PSDDRPLL_CH;
+		break;
+	case AMS_PSINTFPDDR:
+		channel_num = AMS_PSINTFPDDR_CH;
+		break;
+	default:
+		break;
+	}
+
+	/* set single channel, sequencer off mode */
+	ams_ps_update_reg(ams, AMS_REG_CONFIG1, AMS_CONF1_SEQ_MASK,
+			AMS_CONF1_SEQ_SINGLE_CHANNEL);
+
+	/* write the channel number */
+	ams_ps_update_reg(ams, AMS_REG_CONFIG0, AMS_CONF0_CHANNEL_NUM_MASK,
+			channel_num);
+	mdelay(1);
+}
+
+static void ams_read_vcc_reg(struct ams *ams, unsigned int offset, u32 *data)
+{
+	ams_enable_single_channel(ams, offset);
+	ams_read_reg(ams, offset, data);
+	ams_enable_channel_sequence(ams);
+}
+
+static int ams_read_raw(struct iio_dev *indio_dev,
+			struct iio_chan_spec const *chan,
+			int *val, int *val2, long mask)
+{
+	struct ams *ams = iio_priv(indio_dev);
+
+	switch (mask) {
+	case IIO_CHAN_INFO_RAW:
+		mutex_lock(&ams->mutex);
+		if (chan->scan_index >= (PS_SEQ_MAX * 3))
+			ams_read_vcc_reg(ams, chan->address, val);
+		else if (chan->scan_index >= PS_SEQ_MAX)
+			ams->pl_bus->read(ams, chan->address, val);
+		else
+			ams_ps_read_reg(ams, chan->address, val);
+		mutex_unlock(&ams->mutex);
+
+		*val2 = 0;
+		return IIO_VAL_INT;
+	case IIO_CHAN_INFO_SCALE:
+		switch (chan->type) {
+		case IIO_VOLTAGE:
+			switch (chan->address) {
+			case AMS_SUPPLY1:
+			case AMS_SUPPLY2:
+			case AMS_SUPPLY3:
+			case AMS_SUPPLY4:
+				*val = AMS_SUPPLY_SCALE_3VOLT;
+				break;
+			case AMS_SUPPLY5:
+			case AMS_SUPPLY6:
+				if (chan->scan_index < PS_SEQ_MAX)
+					*val = AMS_SUPPLY_SCALE_6VOLT;
+				else
+					*val = AMS_SUPPLY_SCALE_3VOLT;
+				break;
+			case AMS_SUPPLY7:
+			case AMS_SUPPLY8:
+				*val = AMS_SUPPLY_SCALE_6VOLT;
+				break;
+			case AMS_SUPPLY9:
+			case AMS_SUPPLY10:
+				if (chan->scan_index < PS_SEQ_MAX)
+					*val = AMS_SUPPLY_SCALE_3VOLT;
+				else
+					*val = AMS_SUPPLY_SCALE_6VOLT;
+				break;
+			case AMS_VREFP:
+			case AMS_VREFN:
+					*val = AMS_SUPPLY_SCALE_3VOLT;
+				break;
+
+			default:
+				if (chan->scan_index >= (PS_SEQ_MAX * 3))
+					*val = AMS_SUPPLY_SCALE_3VOLT;
+				else
+					*val = AMS_SUPPLY_SCALE_1VOLT;
+				break;
+			}
+			*val2 = AMS_SUPPLY_SCALE_DIV_BIT;
+			return IIO_VAL_FRACTIONAL_LOG2;
+		case IIO_TEMP:
+			*val = AMS_TEMP_SCALE;
+			*val2 = AMS_TEMP_SCALE_DIV_BIT;
+			return IIO_VAL_FRACTIONAL_LOG2;
+		default:
+			return -EINVAL;
+		}
+	case IIO_CHAN_INFO_OFFSET:
+		/* Only the temperature channel has an offset */
+		*val = AMS_TEMP_OFFSET;
+		*val2 = 0;
+		return IIO_VAL_INT;
+	}
+
+	return -EINVAL;
+}
+
+static int ams_get_alarm_offset(int scan_index, enum iio_event_direction dir)
+{
+	int offset = 0;
+
+	if (scan_index >= PS_SEQ_MAX)
+		scan_index -= PS_SEQ_MAX;
+
+	if (dir == IIO_EV_DIR_FALLING) {
+		if (scan_index < AMS_SEQ_SUPPLY7)
+			offset = AMS_ALARM_THRESOLD_OFF_10;
+		else
+			offset = AMS_ALARM_THRESOLD_OFF_20;
+	}
+
+	switch (scan_index) {
+	case AMS_SEQ_TEMP:
+		return (AMS_ALARM_TEMP + offset);
+	case AMS_SEQ_SUPPLY1:
+		return (AMS_ALARM_SUPPLY1 + offset);
+	case AMS_SEQ_SUPPLY2:
+		return (AMS_ALARM_SUPPLY2 + offset);
+	case AMS_SEQ_SUPPLY3:
+		return (AMS_ALARM_SUPPLY3 + offset);
+	case AMS_SEQ_SUPPLY4:
+		return (AMS_ALARM_SUPPLY4 + offset);
+	case AMS_SEQ_SUPPLY5:
+		return (AMS_ALARM_SUPPLY5 + offset);
+	case AMS_SEQ_SUPPLY6:
+		return (AMS_ALARM_SUPPLY6 + offset);
+	case AMS_SEQ_SUPPLY7:
+		return (AMS_ALARM_SUPPLY7 + offset);
+	case AMS_SEQ_SUPPLY8:
+		return (AMS_ALARM_SUPPLY8 + offset);
+	case AMS_SEQ_SUPPLY9:
+		return (AMS_ALARM_SUPPLY9 + offset);
+	case AMS_SEQ_SUPPLY10:
+		return (AMS_ALARM_SUPPLY10 + offset);
+	case AMS_SEQ_VCCAMS:
+		return (AMS_ALARM_VCCAMS + offset);
+	case AMS_SEQ_TEMP_REMOTE:
+		return (AMS_ALARM_TEMP_REMOTE + offset);
+	}
+
+	return 0;
+}
+
+static const struct iio_chan_spec *ams_event_to_channel(
+		struct iio_dev *indio_dev, u32 event)
+{
+	int scan_index = 0, i;
+
+	if (event >= AMS_PL_ALARM_START) {
+		event -= AMS_PL_ALARM_START;
+		scan_index = PS_SEQ_MAX;
+	}
+
+	switch (event) {
+	case AMS_ALARM_BIT_TEMP:
+		scan_index += AMS_SEQ_TEMP;
+		break;
+	case AMS_ALARM_BIT_SUPPLY1:
+		scan_index += AMS_SEQ_SUPPLY1;
+		break;
+	case AMS_ALARM_BIT_SUPPLY2:
+		scan_index += AMS_SEQ_SUPPLY2;
+		break;
+	case AMS_ALARM_BIT_SUPPLY3:
+		scan_index += AMS_SEQ_SUPPLY3;
+		break;
+	case AMS_ALARM_BIT_SUPPLY4:
+		scan_index += AMS_SEQ_SUPPLY4;
+		break;
+	case AMS_ALARM_BIT_SUPPLY5:
+		scan_index += AMS_SEQ_SUPPLY5;
+		break;
+	case AMS_ALARM_BIT_SUPPLY6:
+		scan_index += AMS_SEQ_SUPPLY6;
+		break;
+	case AMS_ALARM_BIT_SUPPLY7:
+		scan_index += AMS_SEQ_SUPPLY7;
+		break;
+	case AMS_ALARM_BIT_SUPPLY8:
+		scan_index += AMS_SEQ_SUPPLY8;
+		break;
+	case AMS_ALARM_BIT_SUPPLY9:
+		scan_index += AMS_SEQ_SUPPLY9;
+		break;
+	case AMS_ALARM_BIT_SUPPLY10:
+		scan_index += AMS_SEQ_SUPPLY10;
+		break;
+	case AMS_ALARM_BIT_VCCAMS:
+		scan_index += AMS_SEQ_VCCAMS;
+		break;
+	case AMS_ALARM_BIT_TEMP_REMOTE:
+		scan_index += AMS_SEQ_TEMP_REMOTE;
+		break;
+	}
+
+	for (i = 0; i < indio_dev->num_channels; i++)
+		if (indio_dev->channels[i].scan_index == scan_index)
+			break;
+
+	return &indio_dev->channels[i];
+}
+
+static int ams_get_alarm_mask(int scan_index)
+{
+	int bit = 0;
+
+	if (scan_index >= PS_SEQ_MAX) {
+		bit = AMS_PL_ALARM_START;
+		scan_index -= PS_SEQ_MAX;
+	}
+
+	switch (scan_index) {
+	case AMS_SEQ_TEMP:
+		return BIT(AMS_ALARM_BIT_TEMP + bit);
+	case AMS_SEQ_SUPPLY1:
+		return BIT(AMS_ALARM_BIT_SUPPLY1 + bit);
+	case AMS_SEQ_SUPPLY2:
+		return BIT(AMS_ALARM_BIT_SUPPLY2 + bit);
+	case AMS_SEQ_SUPPLY3:
+		return BIT(AMS_ALARM_BIT_SUPPLY3 + bit);
+	case AMS_SEQ_SUPPLY4:
+		return BIT(AMS_ALARM_BIT_SUPPLY4 + bit);
+	case AMS_SEQ_SUPPLY5:
+		return BIT(AMS_ALARM_BIT_SUPPLY5 + bit);
+	case AMS_SEQ_SUPPLY6:
+		return BIT(AMS_ALARM_BIT_SUPPLY6 + bit);
+	case AMS_SEQ_SUPPLY7:
+		return BIT(AMS_ALARM_BIT_SUPPLY7 + bit);
+	case AMS_SEQ_SUPPLY8:
+		return BIT(AMS_ALARM_BIT_SUPPLY8 + bit);
+	case AMS_SEQ_SUPPLY9:
+		return BIT(AMS_ALARM_BIT_SUPPLY9 + bit);
+	case AMS_SEQ_SUPPLY10:
+		return BIT(AMS_ALARM_BIT_SUPPLY10 + bit);
+	case AMS_SEQ_VCCAMS:
+		return BIT(AMS_ALARM_BIT_VCCAMS + bit);
+	case AMS_SEQ_TEMP_REMOTE:
+		return BIT(AMS_ALARM_BIT_TEMP_REMOTE + bit);
+	}
+
+	return 0;
+}
+
+static int ams_read_event_config(struct iio_dev *indio_dev,
+				 const struct iio_chan_spec *chan,
+				 enum iio_event_type type,
+				 enum iio_event_direction dir)
+{
+	struct ams *ams = iio_priv(indio_dev);
+
+	return (ams->alarm_mask & ams_get_alarm_mask(chan->scan_index)) ? 1 : 0;
+}
+
+static int ams_write_event_config(struct iio_dev *indio_dev,
+				  const struct iio_chan_spec *chan,
+				  enum iio_event_type type,
+				  enum iio_event_direction dir,
+				  int state)
+{
+	struct ams *ams = iio_priv(indio_dev);
+	unsigned int alarm;
+
+	alarm = ams_get_alarm_mask(chan->scan_index);
+
+	mutex_lock(&ams->mutex);
+
+	if (state)
+		ams->alarm_mask |= alarm;
+	else
+		ams->alarm_mask &= ~alarm;
+
+	iio_ams_update_alarm(ams, ams->alarm_mask);
+
+	mutex_unlock(&ams->mutex);
+
+	return 0;
+}
+
+static int ams_read_event_value(struct iio_dev *indio_dev,
+				const struct iio_chan_spec *chan,
+				enum iio_event_type type,
+				enum iio_event_direction dir,
+				enum iio_event_info info, int *val, int *val2)
+{
+	struct ams *ams = iio_priv(indio_dev);
+	unsigned int offset = ams_get_alarm_offset(chan->scan_index, dir);
+
+	mutex_lock(&ams->mutex);
+
+	if (chan->scan_index >= PS_SEQ_MAX)
+		ams->pl_bus->read(ams, offset, val);
+	else
+		ams_ps_read_reg(ams, offset, val);
+
+	mutex_unlock(&ams->mutex);
+
+	*val2 = 0;
+	return IIO_VAL_INT;
+}
+
+static int ams_write_event_value(struct iio_dev *indio_dev,
+				 const struct iio_chan_spec *chan,
+				 enum iio_event_type type,
+				 enum iio_event_direction dir,
+				 enum iio_event_info info, int val, int val2)
+{
+	struct ams *ams = iio_priv(indio_dev);
+	unsigned int offset;
+
+	mutex_lock(&ams->mutex);
+
+	/* Set temperature channel threshold to direct threshold */
+	if (chan->type == IIO_TEMP) {
+		offset = ams_get_alarm_offset(chan->scan_index,
+					      IIO_EV_DIR_FALLING);
+
+		if (chan->scan_index >= PS_SEQ_MAX)
+			ams->pl_bus->update(ams, offset,
+					    AMS_ALARM_THR_DIRECT_MASK,
+					    AMS_ALARM_THR_DIRECT_MASK);
+		else
+			ams_ps_update_reg(ams, offset,
+					  AMS_ALARM_THR_DIRECT_MASK,
+					  AMS_ALARM_THR_DIRECT_MASK);
+	}
+
+	offset = ams_get_alarm_offset(chan->scan_index, dir);
+	if (chan->scan_index >= PS_SEQ_MAX)
+		ams->pl_bus->write(ams, offset, val);
+	else
+		ams_ps_write_reg(ams, offset, val);
+
+	mutex_unlock(&ams->mutex);
+
+	return 0;
+}
+
+static void ams_handle_event(struct iio_dev *indio_dev, u32 event)
+{
+	const struct iio_chan_spec *chan;
+
+	chan = ams_event_to_channel(indio_dev, event);
+
+	if (chan->type == IIO_TEMP) {
+		/* The temperature channel only supports over-temperature
+		 * events
+		 */
+		iio_push_event(indio_dev,
+			       IIO_UNMOD_EVENT_CODE(chan->type, chan->channel,
+						    IIO_EV_TYPE_THRESH,
+						    IIO_EV_DIR_RISING),
+			iio_get_time_ns(indio_dev));
+	} else {
+		/* For other channels we don't know whether it is a upper or
+		 * lower threshold event. Userspace will have to check the
+		 * channel value if it wants to know.
+		 */
+		iio_push_event(indio_dev,
+			       IIO_UNMOD_EVENT_CODE(chan->type, chan->channel,
+						    IIO_EV_TYPE_THRESH,
+						    IIO_EV_DIR_EITHER),
+			iio_get_time_ns(indio_dev));
+	}
+}
+
+static void ams_handle_events(struct iio_dev *indio_dev, unsigned long events)
+{
+	unsigned int bit;
+
+	for_each_set_bit(bit, &events, AMS_NO_OF_ALARMS)
+		ams_handle_event(indio_dev, bit);
+}
+
+/**
+ * ams_unmask_worker - ams alarm interrupt unmask worker
+ * @work :		work to be done
+ *
+ * The ZynqMP threshold interrupts are level sensitive. Since we can't make the
+ * threshold condition go way from within the interrupt handler, this means as
+ * soon as a threshold condition is present we would enter the interrupt handler
+ * again and again. To work around this we mask all active thresholds interrupts
+ * in the interrupt handler and start a timer. In this timer we poll the
+ * interrupt status and only if the interrupt is inactive we unmask it again.
+ */
+static void ams_unmask_worker(struct work_struct *work)
+{
+	struct ams *ams = container_of(work, struct ams, ams_unmask_work.work);
+	unsigned int status, unmask;
+
+	spin_lock_irq(&ams->lock);
+
+	ams_read_reg(ams, AMS_ISR_0, &status);
+
+	/* Clear those bits which are not active anymore */
+	unmask = (ams->masked_alarm ^ status) & ams->masked_alarm;
+
+	/* clear status of disabled alarm */
+	unmask |= ams->intr_mask;
+
+	ams->masked_alarm &= status;
+
+	/* Also clear those which are masked out anyway */
+	ams->masked_alarm &= ~ams->intr_mask;
+
+	/* Clear the interrupts before we unmask them */
+	ams_write_reg(ams, AMS_ISR_0, unmask);
+
+	ams_update_intrmask(ams, 0, 0);
+
+	spin_unlock_irq(&ams->lock);
+
+	/* if still pending some alarm re-trigger the timer */
+	if (ams->masked_alarm)
+		schedule_delayed_work(&ams->ams_unmask_work,
+				      msecs_to_jiffies(AMS_UNMASK_TIMEOUT));
+}
+
+static irqreturn_t ams_iio_irq(int irq, void *data)
+{
+	unsigned int isr0, isr1;
+	struct iio_dev *indio_dev = data;
+	struct ams *ams = iio_priv(indio_dev);
+
+	spin_lock(&ams->lock);
+
+	ams_read_reg(ams, AMS_ISR_0, &isr0);
+	ams_read_reg(ams, AMS_ISR_1, &isr1);
+
+	/* only process alarm that are not masked */
+	isr0 &= ~((ams->intr_mask & AMS_ISR0_ALARM_MASK) | ams->masked_alarm);
+	isr1 &= ~(ams->intr_mask >> AMS_ISR1_INTR_MASK_SHIFT);
+
+	/* clear interrupt */
+	ams_write_reg(ams, AMS_ISR_0, isr0);
+	ams_write_reg(ams, AMS_ISR_1, isr1);
+
+	if (isr0) {
+		/* Once the alarm interrupt occurred, mask until get cleared */
+		ams->masked_alarm |= isr0;
+		ams_update_intrmask(ams, 0, 0);
+
+		ams_handle_events(indio_dev, isr0);
+
+		schedule_delayed_work(&ams->ams_unmask_work,
+				      msecs_to_jiffies(AMS_UNMASK_TIMEOUT));
+	}
+
+	spin_unlock(&ams->lock);
+
+	return IRQ_HANDLED;
+}
+
+static const struct iio_event_spec ams_temp_events[] = {
+	{
+		.type = IIO_EV_TYPE_THRESH,
+		.dir = IIO_EV_DIR_RISING,
+		.mask_separate = BIT(IIO_EV_INFO_ENABLE) |
+				BIT(IIO_EV_INFO_VALUE),
+	},
+};
+
+static const struct iio_event_spec ams_voltage_events[] = {
+	{
+		.type = IIO_EV_TYPE_THRESH,
+		.dir = IIO_EV_DIR_RISING,
+		.mask_separate = BIT(IIO_EV_INFO_VALUE),
+	}, {
+		.type = IIO_EV_TYPE_THRESH,
+		.dir = IIO_EV_DIR_FALLING,
+		.mask_separate = BIT(IIO_EV_INFO_VALUE),
+	}, {
+		.type = IIO_EV_TYPE_THRESH,
+		.dir = IIO_EV_DIR_EITHER,
+		.mask_separate = BIT(IIO_EV_INFO_ENABLE),
+	},
+};
+
+static const struct iio_chan_spec ams_ps_channels[] = {
+	AMS_PS_CHAN_TEMP(AMS_SEQ_TEMP, AMS_TEMP, "ps_temp"),
+	AMS_PS_CHAN_TEMP(AMS_SEQ_TEMP_REMOTE, AMS_TEMP_REMOTE, "remote_temp"),
+	AMS_PS_CHAN_VOLTAGE(AMS_SEQ_SUPPLY1, AMS_SUPPLY1, "vccpsintlp"),
+	AMS_PS_CHAN_VOLTAGE(AMS_SEQ_SUPPLY2, AMS_SUPPLY2, "vccpsintfp"),
+	AMS_PS_CHAN_VOLTAGE(AMS_SEQ_SUPPLY3, AMS_SUPPLY3, "vccpsaux"),
+	AMS_PS_CHAN_VOLTAGE(AMS_SEQ_SUPPLY4, AMS_SUPPLY4, "vccpsddr"),
+	AMS_PS_CHAN_VOLTAGE(AMS_SEQ_SUPPLY5, AMS_SUPPLY5, "vccpsio3"),
+	AMS_PS_CHAN_VOLTAGE(AMS_SEQ_SUPPLY6, AMS_SUPPLY6, "vccpsio0"),
+	AMS_PS_CHAN_VOLTAGE(AMS_SEQ_SUPPLY7, AMS_SUPPLY7, "vccpsio1"),
+	AMS_PS_CHAN_VOLTAGE(AMS_SEQ_SUPPLY8, AMS_SUPPLY8, "vccpsio2"),
+	AMS_PS_CHAN_VOLTAGE(AMS_SEQ_SUPPLY9, AMS_SUPPLY9, "psmgtravcc"),
+	AMS_PS_CHAN_VOLTAGE(AMS_SEQ_SUPPLY10, AMS_SUPPLY10, "psmgtravtt"),
+	AMS_PS_CHAN_VOLTAGE(AMS_SEQ_VCCAMS, AMS_VCCAMS, "vccams"),
+};
+
+static const struct iio_chan_spec ams_pl_channels[] = {
+	AMS_PL_CHAN_TEMP(AMS_SEQ_TEMP, AMS_TEMP, "pl_temp"),
+	AMS_PL_CHAN_VOLTAGE(AMS_SEQ_SUPPLY1, AMS_SUPPLY1, "vccint", true),
+	AMS_PL_CHAN_VOLTAGE(AMS_SEQ_SUPPLY2, AMS_SUPPLY2, "vccaux", true),
+	AMS_PL_CHAN_VOLTAGE(AMS_SEQ_VREFP, AMS_VREFP, "vccvrefp", false),
+	AMS_PL_CHAN_VOLTAGE(AMS_SEQ_VREFN, AMS_VREFN, "vccvrefn", false),
+	AMS_PL_CHAN_VOLTAGE(AMS_SEQ_SUPPLY3, AMS_SUPPLY3, "vccbram", true),
+	AMS_PL_CHAN_VOLTAGE(AMS_SEQ_SUPPLY4, AMS_SUPPLY4, "vccplintlp", true),
+	AMS_PL_CHAN_VOLTAGE(AMS_SEQ_SUPPLY5, AMS_SUPPLY5, "vccplintfp", true),
+	AMS_PL_CHAN_VOLTAGE(AMS_SEQ_SUPPLY6, AMS_SUPPLY6, "vccplaux", true),
+	AMS_PL_CHAN_VOLTAGE(AMS_SEQ_VCCAMS, AMS_VCCAMS, "vccams", true),
+	AMS_PL_CHAN_VOLTAGE(AMS_SEQ_VP_VN, AMS_VP_VN, "vccvpvn", false),
+	AMS_PL_CHAN_VOLTAGE(AMS_SEQ_SUPPLY7, AMS_SUPPLY7, "vuser0", true),
+	AMS_PL_CHAN_VOLTAGE(AMS_SEQ_SUPPLY8, AMS_SUPPLY8, "vuser1", true),
+	AMS_PL_CHAN_VOLTAGE(AMS_SEQ_SUPPLY9, AMS_SUPPLY9, "vuser2", true),
+	AMS_PL_CHAN_VOLTAGE(AMS_SEQ_SUPPLY10, AMS_SUPPLY10, "vuser3", true),
+	AMS_PL_AUX_CHAN_VOLTAGE(0, "vccaux0"),
+	AMS_PL_AUX_CHAN_VOLTAGE(1, "vccaux1"),
+	AMS_PL_AUX_CHAN_VOLTAGE(2, "vccaux2"),
+	AMS_PL_AUX_CHAN_VOLTAGE(3, "vccaux3"),
+	AMS_PL_AUX_CHAN_VOLTAGE(4, "vccaux4"),
+	AMS_PL_AUX_CHAN_VOLTAGE(5, "vccaux5"),
+	AMS_PL_AUX_CHAN_VOLTAGE(6, "vccaux6"),
+	AMS_PL_AUX_CHAN_VOLTAGE(7, "vccaux7"),
+	AMS_PL_AUX_CHAN_VOLTAGE(8, "vccaux8"),
+	AMS_PL_AUX_CHAN_VOLTAGE(9, "vccaux9"),
+	AMS_PL_AUX_CHAN_VOLTAGE(10, "vccaux10"),
+	AMS_PL_AUX_CHAN_VOLTAGE(11, "vccaux11"),
+	AMS_PL_AUX_CHAN_VOLTAGE(12, "vccaux12"),
+	AMS_PL_AUX_CHAN_VOLTAGE(13, "vccaux13"),
+	AMS_PL_AUX_CHAN_VOLTAGE(14, "vccaux14"),
+	AMS_PL_AUX_CHAN_VOLTAGE(15, "vccaux15"),
+};
+
+static const struct iio_chan_spec ams_ctrl_channels[] = {
+	AMS_CTRL_CHAN_VOLTAGE(AMS_SEQ_VCC_PSPLL, AMS_VCC_PSPLL0, "vcc_pspll0"),
+	AMS_CTRL_CHAN_VOLTAGE(AMS_SEQ_VCC_PSBATT, AMS_VCC_PSPLL3, "vcc_psbatt"),
+	AMS_CTRL_CHAN_VOLTAGE(AMS_SEQ_VCCINT, AMS_VCCINT, "vccint"),
+	AMS_CTRL_CHAN_VOLTAGE(AMS_SEQ_VCCBRAM, AMS_VCCBRAM, "vccbram"),
+	AMS_CTRL_CHAN_VOLTAGE(AMS_SEQ_VCCAUX, AMS_VCCAUX, "vccaux"),
+	AMS_CTRL_CHAN_VOLTAGE(AMS_SEQ_PSDDRPLL, AMS_PSDDRPLL, "vcc_psddrpll"),
+	AMS_CTRL_CHAN_VOLTAGE(AMS_SEQ_INTDDR, AMS_PSINTFPDDR, "vccpsintfpddr"),
+};
+
+static int ams_init_module(struct iio_dev *indio_dev, struct device_node *np,
+			   struct iio_chan_spec *channels)
+{
+	struct ams *ams = iio_priv(indio_dev);
+	struct device_node *chan_node, *child;
+	int ret, num_channels = 0;
+	unsigned int reg;
+
+	if (of_device_is_compatible(np, "xlnx,zynqmp-ams-ps")) {
+		ams->ps_base = of_iomap(np, 0);
+		if (!ams->ps_base)
+			return -ENXIO;
+
+		/* add PS channels to iio device channels */
+		memcpy(channels + num_channels, ams_ps_channels,
+		       sizeof(ams_ps_channels));
+		num_channels += ARRAY_SIZE(ams_ps_channels);
+	} else if (of_device_is_compatible(np, "xlnx,zynqmp-ams-pl")) {
+		ams->pl_base = of_iomap(np, 0);
+		if (!ams->pl_base)
+			return -ENXIO;
+
+		/* Copy only first 10 fix channels */
+		memcpy(channels + num_channels, ams_pl_channels,
+		       AMS_PL_MAX_FIXED_CHANNEL * sizeof(*channels));
+		num_channels += AMS_PL_MAX_FIXED_CHANNEL;
+
+		chan_node = of_get_child_by_name(np, "xlnx,ext-channels");
+		if (chan_node) {
+			for_each_child_of_node(chan_node, child) {
+				ret = of_property_read_u32(child, "reg", &reg);
+				if (ret || reg > AMS_PL_MAX_EXT_CHANNEL)
+					continue;
+
+				memcpy(&channels[num_channels],
+				       &ams_pl_channels[reg +
+				       AMS_PL_MAX_FIXED_CHANNEL],
+				       sizeof(*channels));
+
+				if (of_property_read_bool(child,
+							  "xlnx,bipolar"))
+					channels[num_channels].
+						scan_type.sign = 's';
+
+				num_channels += 1;
+			}
+		}
+		of_node_put(chan_node);
+	} else if (of_device_is_compatible(np, "xlnx,zynqmp-ams")) {
+		/* add AMS channels to iio device channels */
+		memcpy(channels + num_channels, ams_ctrl_channels,
+				sizeof(ams_ctrl_channels));
+		num_channels += ARRAY_SIZE(ams_ctrl_channels);
+	} else {
+		return -EINVAL;
+	}
+
+	return num_channels;
+}
+
+static int ams_parse_dt(struct iio_dev *indio_dev, struct platform_device *pdev)
+{
+	struct ams *ams = iio_priv(indio_dev);
+	struct iio_chan_spec *ams_channels, *dev_channels;
+	struct device_node *child_node = NULL, *np = pdev->dev.of_node;
+	int ret, chan_vol = 0, chan_temp = 0, i, rising_off, falling_off;
+	unsigned int num_channels = 0;
+
+	/* Initialize buffer for channel specification */
+	ams_channels = kzalloc(sizeof(ams_ps_channels) +
+			       sizeof(ams_pl_channels) +
+			       sizeof(ams_ctrl_channels), GFP_KERNEL);
+	if (!ams_channels)
+		return -ENOMEM;
+
+	if (of_device_is_available(np)) {
+		ret = ams_init_module(indio_dev, np, ams_channels);
+		if (ret < 0) {
+			kfree(ams_channels);
+			return ret;
+		}
+
+		num_channels += ret;
+	}
+
+	for_each_child_of_node(np, child_node) {
+		if (of_device_is_available(child_node)) {
+			ret = ams_init_module(indio_dev, child_node,
+					      ams_channels + num_channels);
+			if (ret < 0) {
+				kfree(ams_channels);
+				return ret;
+			}
+
+			num_channels += ret;
+		}
+	}
+
+	for (i = 0; i < num_channels; i++) {
+		if (ams_channels[i].type == IIO_VOLTAGE)
+			ams_channels[i].channel = chan_vol++;
+		else
+			ams_channels[i].channel = chan_temp++;
+
+		if (ams_channels[i].scan_index < (PS_SEQ_MAX * 3)) {
+			/* set threshold to max and min for each channel */
+			falling_off = ams_get_alarm_offset(
+					ams_channels[i].scan_index,
+					IIO_EV_DIR_FALLING);
+			rising_off = ams_get_alarm_offset(
+					ams_channels[i].scan_index,
+					IIO_EV_DIR_RISING);
+			if (ams_channels[i].scan_index >= PS_SEQ_MAX) {
+				ams->pl_bus->write(ams, falling_off,
+						AMS_ALARM_THR_MIN);
+				ams->pl_bus->write(ams, rising_off,
+						AMS_ALARM_THR_MAX);
+			} else {
+				ams_ps_write_reg(ams, falling_off,
+						AMS_ALARM_THR_MIN);
+				ams_ps_write_reg(ams, rising_off,
+						AMS_ALARM_THR_MAX);
+			}
+		}
+	}
+
+	dev_channels = devm_kzalloc(&pdev->dev, sizeof(*dev_channels) *
+				    num_channels, GFP_KERNEL);
+	if (!dev_channels) {
+		kfree(ams_channels);
+		return -ENOMEM;
+	}
+
+	memcpy(dev_channels, ams_channels,
+	       sizeof(*ams_channels) * num_channels);
+	kfree(ams_channels);
+	indio_dev->channels = dev_channels;
+	indio_dev->num_channels = num_channels;
+
+	return 0;
+}
+
+static const struct iio_info iio_pl_info = {
+	.read_raw = &ams_read_raw,
+	.read_event_config = &ams_read_event_config,
+	.write_event_config = &ams_write_event_config,
+	.read_event_value = &ams_read_event_value,
+	.write_event_value = &ams_write_event_value,
+};
+
+static const struct ams_pl_bus_ops ams_pl_apb = {
+	.read = ams_apb_pl_read_reg,
+	.write = ams_apb_pl_write_reg,
+	.update = ams_apb_pl_update_reg,
+};
+
+static const struct of_device_id ams_of_match_table[] = {
+	{ .compatible = "xlnx,zynqmp-ams", &ams_pl_apb },
+	{ }
+};
+MODULE_DEVICE_TABLE(of, ams_of_match_table);
+
+static int ams_probe(struct platform_device *pdev)
+{
+	struct iio_dev *indio_dev;
+	struct ams *ams;
+	struct resource *res;
+	const struct of_device_id *id;
+	int ret;
+
+	if (!pdev->dev.of_node)
+		return -ENODEV;
+
+	id = of_match_node(ams_of_match_table, pdev->dev.of_node);
+	if (!id)
+		return -ENODEV;
+
+	indio_dev = devm_iio_device_alloc(&pdev->dev, sizeof(*ams));
+	if (!indio_dev)
+		return -ENOMEM;
+
+	ams = iio_priv(indio_dev);
+	ams->indio_dev = indio_dev;
+	ams->pl_bus = id->data;
+	mutex_init(&ams->mutex);
+	spin_lock_init(&ams->lock);
+
+	indio_dev->dev.parent = &pdev->dev;
+	indio_dev->dev.of_node = pdev->dev.of_node;
+	indio_dev->name = "ams";
+
+	indio_dev->info = &iio_pl_info;
+	indio_dev->modes = INDIO_DIRECT_MODE;
+
+	res = platform_get_resource_byname(pdev, IORESOURCE_MEM, "ams-base");
+	ams->base = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(ams->base))
+		return PTR_ERR(ams->base);
+
+	INIT_DELAYED_WORK(&ams->ams_unmask_work, ams_unmask_worker);
+
+	ams->clk = devm_clk_get(&pdev->dev, NULL);
+	if (IS_ERR(ams->clk))
+		return PTR_ERR(ams->clk);
+	clk_prepare_enable(ams->clk);
+
+	ret = iio_ams_init_device(ams);
+	if (ret) {
+		dev_err(&pdev->dev, "failed to initialize AMS\n");
+		goto clk_disable;
+	}
+
+	ret = ams_parse_dt(indio_dev, pdev);
+	if (ret) {
+		dev_err(&pdev->dev, "failure in parsing DT\n");
+		goto clk_disable;
+	}
+
+	ams_enable_channel_sequence(ams);
+
+	ams->irq = platform_get_irq_byname(pdev, "ams-irq");
+	ret = devm_request_irq(&pdev->dev, ams->irq, &ams_iio_irq, 0, "ams-irq",
+			       indio_dev);
+	if (ret < 0) {
+		dev_err(&pdev->dev, "failed to register interrupt\n");
+		goto clk_disable;
+	}
+
+	platform_set_drvdata(pdev, indio_dev);
+
+	return iio_device_register(indio_dev);
+
+clk_disable:
+	clk_disable_unprepare(ams->clk);
+	return ret;
+}
+
+static int ams_remove(struct platform_device *pdev)
+{
+	struct iio_dev *indio_dev = platform_get_drvdata(pdev);
+	struct ams *ams = iio_priv(indio_dev);
+
+	cancel_delayed_work(&ams->ams_unmask_work);
+
+	/* Unregister the device */
+	iio_device_unregister(indio_dev);
+	clk_disable_unprepare(ams->clk);
+	return 0;
+}
+
+static int __maybe_unused ams_suspend(struct device *dev)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct ams *ams = iio_priv(indio_dev);
+
+	clk_disable_unprepare(ams->clk);
+
+	return 0;
+}
+
+static int __maybe_unused ams_resume(struct device *dev)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct ams *ams = iio_priv(indio_dev);
+
+	clk_prepare_enable(ams->clk);
+	return 0;
+}
+
+static SIMPLE_DEV_PM_OPS(ams_pm_ops, ams_suspend, ams_resume);
+
+static struct platform_driver ams_driver = {
+	.probe = ams_probe,
+	.remove = ams_remove,
+	.driver = {
+		.name = "ams",
+		.pm	= &ams_pm_ops,
+		.of_match_table = ams_of_match_table,
+	},
+};
+module_platform_driver(ams_driver);
+
+MODULE_LICENSE("GPL v2");
+MODULE_AUTHOR("Rajnikant Bhojani <rajnikant.bhojani@xilinx.com>");
diff --git a/drivers/iio/adc/xilinx-ams.h b/drivers/iio/adc/xilinx-ams.h
new file mode 100644
index 000000000..012b85faa
--- /dev/null
+++ b/drivers/iio/adc/xilinx-ams.h
@@ -0,0 +1,279 @@
+#ifndef __XILINX_AMS_H__
+#define __XILINX_AMS_H__
+
+#define AMS_MISC_CTRL     0x000
+#define AMS_ISR_0         0x010
+#define AMS_ISR_1         0x014
+#define AMS_IMR_0         0x018
+#define AMS_IMR_1         0x01c
+#define AMS_IER_0         0x020
+#define AMS_IER_1         0x024
+#define AMS_IDR_0         0x028
+#define AMS_IDR_1         0x02c
+#define AMS_PS_CSTS       0x040
+#define AMS_PL_CSTS       0x044
+#define AMS_MON_CSTS      0x050
+
+#define AMS_VCC_PSPLL0    0x060
+#define AMS_VCC_PSPLL3    0x06C
+#define AMS_VCCINT        0x078
+#define AMS_VCCBRAM       0x07C
+#define AMS_VCCAUX        0x080
+#define AMS_PSDDRPLL      0x084
+#define AMS_PSINTFPDDR    0x09C
+
+#define AMS_VCC_PSPLL0_CH 48
+#define AMS_VCC_PSPLL3_CH 51
+#define AMS_VCCINT_CH     54
+#define AMS_VCCBRAM_CH    55
+#define AMS_VCCAUX_CH     56
+#define AMS_PSDDRPLL_CH   57
+#define AMS_PSINTFPDDR_CH 63
+
+#define AMS_REG_CONFIG0   0x100
+#define AMS_REG_CONFIG1   0x104
+#define AMS_REG_CONFIG2   0x108
+#define AMS_REG_CONFIG3   0x10C
+#define AMS_REG_CONFIG4   0x110
+#define AMS_REG_SEQ_CH0   0x120
+#define AMS_REG_SEQ_CH1   0x124
+#define AMS_REG_SEQ_CH2   0x118
+
+#define AMS_TEMP          0x000
+#define AMS_SUPPLY1       0x004
+#define AMS_SUPPLY2       0x008
+#define AMS_VP_VN         0x00c
+#define AMS_VREFP         0x010
+#define AMS_VREFN         0x014
+#define AMS_SUPPLY3       0x018
+#define AMS_SUPPLY4       0x034
+#define AMS_SUPPLY5       0x038
+#define AMS_SUPPLY6       0x03c
+#define AMS_SUPPLY7       0x200
+#define AMS_SUPPLY8       0x204
+#define AMS_SUPPLY9       0x208
+#define AMS_SUPPLY10      0x20c
+#define AMS_VCCAMS        0x210
+#define AMS_TEMP_REMOTE   0x214
+
+#define AMS_REG_VAUX(x)   (0x40 + (4*(x)))
+#define AMS_REG_VUSER(x)  (0x200 + (4*(x)))
+
+#define AMS_PS_RESET_VALUE   0xFFFFU
+#define AMS_PL_RESET_VALUE   0xFFFFU
+
+#define AMS_CONF0_CHANNEL_NUM_MASK      (0x3f << 0)
+
+#define AMS_CONF1_SEQ_MASK              (0xf << 12)
+#define AMS_CONF1_SEQ_DEFAULT           (0 << 12)
+#define AMS_CONF1_SEQ_SINGLE_PASS       (1 << 12)
+#define AMS_CONF1_SEQ_CONTINUOUS        (2 << 12)
+#define AMS_CONF1_SEQ_SINGLE_CHANNEL    (3 << 12)
+
+#define AMS_REG_SEQ0_MASK        0xFFFF
+#define AMS_REG_SEQ2_MASK        0x3F
+#define AMS_REG_SEQ1_MASK        0xFFFF
+#define AMS_REG_SEQ2_MASK_SHIFT  16
+#define AMS_REG_SEQ1_MASK_SHIFT  22
+
+#define AMS_REGCFG1_ALARM_MASK   0xF0F
+#define AMS_REGCFG3_ALARM_MASK   0x3F
+
+#define AMS_ALARM_TEMP            0x140
+#define AMS_ALARM_SUPPLY1         0x144
+#define AMS_ALARM_SUPPLY2         0x148
+#define AMS_ALARM_OT              0x14c
+
+#define AMS_ALARM_SUPPLY3         0x160
+#define AMS_ALARM_SUPPLY4         0x164
+#define AMS_ALARM_SUPPLY5         0x168
+#define AMS_ALARM_SUPPLY6         0x16c
+#define AMS_ALARM_SUPPLY7         0x180
+#define AMS_ALARM_SUPPLY8         0x184
+#define AMS_ALARM_SUPPLY9         0x188
+#define AMS_ALARM_SUPPLY10        0x18c
+#define AMS_ALARM_VCCAMS          0x190
+#define AMS_ALARM_TEMP_REMOTE     0x194
+#define AMS_ALARM_THRESOLD_OFF_10 0x10
+#define AMS_ALARM_THRESOLD_OFF_20 0x20
+
+#define AMS_ALARM_THR_DIRECT_MASK 0x01
+#define AMS_ALARM_THR_MIN         0x0000
+#define AMS_ALARM_THR_MAX         0xffff
+
+#define AMS_NO_OF_ALARMS             32
+#define AMS_PL_ALARM_START           16
+#define AMS_ISR0_ALARM_MASK          0xFFFFFFFFU
+#define AMS_ISR1_ALARM_MASK          0xE000001FU
+#define AMS_ISR1_INTR_MASK_SHIFT     32
+#define AMS_ISR0_ALARM_2_TO_0_MASK     0x07
+#define AMS_ISR0_ALARM_6_TO_3_MASK     0x78
+#define AMS_ISR0_ALARM_12_TO_7_MASK    0x3F
+#define AMS_CONF1_ALARM_2_TO_0_SHIFT   1
+#define AMS_CONF1_ALARM_6_TO_3_SHIFT   5
+#define AMS_CONF3_ALARM_12_TO_7_SHIFT  8
+
+#define AMS_PS_CSTS_PS_READY       0x08010000U
+#define AMS_PL_CSTS_ACCESS_MASK    0x00000001U
+
+#define AMS_PL_MAX_FIXED_CHANNEL   10
+#define AMS_PL_MAX_EXT_CHANNEL     20
+
+#define AMS_INIT_TIMEOUT	10000
+
+/* Following scale and offset value is derivef from
+ * UG580 (v1.7) December 20, 2016
+ */
+#define AMS_SUPPLY_SCALE_1VOLT     1000
+#define AMS_SUPPLY_SCALE_3VOLT     3000
+#define AMS_SUPPLY_SCALE_6VOLT     6000
+#define AMS_SUPPLY_SCALE_DIV_BIT   16
+
+#define AMS_TEMP_SCALE             509314
+#define AMS_TEMP_SCALE_DIV_BIT     16
+#define AMS_TEMP_OFFSET            -((280230L << 16) / 509314)
+
+enum ams_alarm_bit {
+	AMS_ALARM_BIT_TEMP,
+	AMS_ALARM_BIT_SUPPLY1,
+	AMS_ALARM_BIT_SUPPLY2,
+	AMS_ALARM_BIT_SUPPLY3,
+	AMS_ALARM_BIT_SUPPLY4,
+	AMS_ALARM_BIT_SUPPLY5,
+	AMS_ALARM_BIT_SUPPLY6,
+	AMS_ALARM_BIT_RESERVED,
+	AMS_ALARM_BIT_SUPPLY7,
+	AMS_ALARM_BIT_SUPPLY8,
+	AMS_ALARM_BIT_SUPPLY9,
+	AMS_ALARM_BIT_SUPPLY10,
+	AMS_ALARM_BIT_VCCAMS,
+	AMS_ALARM_BIT_TEMP_REMOTE
+};
+
+enum ams_seq {
+	AMS_SEQ_VCC_PSPLL,
+	AMS_SEQ_VCC_PSBATT,
+	AMS_SEQ_VCCINT,
+	AMS_SEQ_VCCBRAM,
+	AMS_SEQ_VCCAUX,
+	AMS_SEQ_PSDDRPLL,
+	AMS_SEQ_INTDDR
+};
+
+enum ams_ps_pl_seq {
+	AMS_SEQ_CALIB,
+	AMS_SEQ_RSVD_1,
+	AMS_SEQ_RSVD_2,
+	AMS_SEQ_TEST,
+	AMS_SEQ_RSVD_4,
+	AMS_SEQ_SUPPLY4,
+	AMS_SEQ_SUPPLY5,
+	AMS_SEQ_SUPPLY6,
+	AMS_SEQ_TEMP,
+	AMS_SEQ_SUPPLY2,
+	AMS_SEQ_SUPPLY1,
+	AMS_SEQ_VP_VN,
+	AMS_SEQ_VREFP,
+	AMS_SEQ_VREFN,
+	AMS_SEQ_SUPPLY3,
+	AMS_SEQ_CURRENT_MON,
+	AMS_SEQ_SUPPLY7,
+	AMS_SEQ_SUPPLY8,
+	AMS_SEQ_SUPPLY9,
+	AMS_SEQ_SUPPLY10,
+	AMS_SEQ_VCCAMS,
+	AMS_SEQ_TEMP_REMOTE,
+	AMS_SEQ_MAX
+};
+
+#define AMS_SEQ(x)          (AMS_SEQ_MAX + (x))
+#define AMS_VAUX_SEQ(x)     (AMS_SEQ_MAX + (x))
+
+#define PS_SEQ_MAX          AMS_SEQ_MAX
+#define PS_SEQ(x)           (x)
+#define PL_SEQ(x)           (PS_SEQ_MAX + x)
+
+#define AMS_CHAN_TEMP(_scan_index, _addr, _ext) { \
+	.type = IIO_TEMP, \
+	.indexed = 1, \
+	.address = (_addr), \
+	.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) | \
+		BIT(IIO_CHAN_INFO_SCALE) | \
+		BIT(IIO_CHAN_INFO_OFFSET), \
+	.info_mask_shared_by_all = BIT(IIO_CHAN_INFO_SAMP_FREQ), \
+	.event_spec = ams_temp_events, \
+	.num_event_specs = ARRAY_SIZE(ams_temp_events), \
+	.scan_index = (_scan_index), \
+	.scan_type = { \
+		.sign = 'u', \
+		.realbits = 12, \
+		.storagebits = 16, \
+		.shift = 4, \
+		.endianness = IIO_CPU, \
+	}, \
+	.extend_name = _ext, \
+}
+
+#define AMS_CHAN_VOLTAGE(_scan_index, _addr, _ext, _alarm) { \
+	.type = IIO_VOLTAGE, \
+	.indexed = 1, \
+	.address = (_addr), \
+	.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) | \
+		BIT(IIO_CHAN_INFO_SCALE), \
+	.info_mask_shared_by_all = BIT(IIO_CHAN_INFO_SAMP_FREQ), \
+	.event_spec = (_alarm) ? ams_voltage_events : NULL, \
+	.num_event_specs = (_alarm) ? ARRAY_SIZE(ams_voltage_events) : 0, \
+	.scan_index = (_scan_index), \
+	.scan_type = { \
+		.realbits = 10, \
+		.storagebits = 16, \
+		.shift = 6, \
+		.endianness = IIO_CPU, \
+	}, \
+	.extend_name = _ext, \
+}
+
+#define AMS_PS_CHAN_TEMP(_scan_index, _addr, _ext) \
+	AMS_CHAN_TEMP(PS_SEQ(_scan_index), _addr, _ext)
+#define AMS_PS_CHAN_VOLTAGE(_scan_index, _addr, _ext) \
+	AMS_CHAN_VOLTAGE(PS_SEQ(_scan_index), _addr, _ext, true)
+
+#define AMS_PL_CHAN_TEMP(_scan_index, _addr, _ext) \
+	AMS_CHAN_TEMP(PL_SEQ(_scan_index), _addr, _ext)
+#define AMS_PL_CHAN_VOLTAGE(_scan_index, _addr, _ext, _alarm) \
+	AMS_CHAN_VOLTAGE(PL_SEQ(_scan_index), _addr, _ext, _alarm)
+#define AMS_PL_AUX_CHAN_VOLTAGE(_auxno, _ext) \
+	AMS_CHAN_VOLTAGE(PL_SEQ(AMS_VAUX_SEQ(_auxno)), \
+			AMS_REG_VAUX(_auxno), _ext, false)
+#define AMS_CTRL_CHAN_VOLTAGE(_scan_index, _addr, _ext) \
+	AMS_CHAN_VOLTAGE(PL_SEQ(AMS_VAUX_SEQ(AMS_SEQ(_scan_index))), \
+			_addr, _ext, false)
+
+struct ams {
+	void __iomem *base;
+	void __iomem *ps_base;
+	void __iomem *pl_base;
+	struct clk *clk;
+	struct device *dev;
+
+	struct mutex mutex;
+	spinlock_t lock;
+
+	unsigned int alarm_mask;
+	unsigned int masked_alarm;
+	u64 intr_mask;
+	int irq;
+
+	struct delayed_work ams_unmask_work;
+	const struct ams_pl_bus_ops *pl_bus;
+	struct iio_dev *indio_dev;
+};
+
+struct ams_pl_bus_ops {
+	void (*read)(struct ams *ams, unsigned int offset, unsigned int *data);
+	void (*write)(struct ams *ams, unsigned int offset, unsigned int data);
+	void (*update)(struct ams *ams, unsigned int offset, u32 mask,
+			u32 data);
+};
+
+#endif /* __XILINX_AMS_H__ */
diff --git a/drivers/iio/adc/xilinx-xadc-core.c b/drivers/iio/adc/xilinx-xadc-core.c
index f93c34fe5..fd3ee0894 100644
--- a/drivers/iio/adc/xilinx-xadc-core.c
+++ b/drivers/iio/adc/xilinx-xadc-core.c
@@ -94,6 +94,9 @@ static const unsigned int XADC_ZYNQ_UNMASK_TIMEOUT = 500;
 #define XADC_AXI_REG_IPIER		0x68
 #define XADC_AXI_ADC_REG_OFFSET		0x200
 
+/* AXI sysmon offset */
+#define XADC_AXI_SYSMON_REG_OFFSET	0x400
+
 #define XADC_AXI_RESET_MAGIC		0xa
 #define XADC_AXI_GIER_ENABLE		BIT(31)
 
@@ -468,6 +471,26 @@ static int xadc_axi_write_adc_reg(struct xadc *xadc, unsigned int reg,
 	return 0;
 }
 
+/* AXI sysmon read/write methods */
+static int xadc_axi_read_sysmon_reg(struct xadc *xadc, unsigned int reg,
+	uint16_t *val)
+{
+	uint32_t val32;
+
+	xadc_read_reg(xadc, XADC_AXI_SYSMON_REG_OFFSET + reg * 4, &val32);
+	*val = val32 & 0xffff;
+
+	return 0;
+}
+
+static int xadc_axi_write_sysmon_reg(struct xadc *xadc, unsigned int reg,
+	uint16_t val)
+{
+	xadc_write_reg(xadc, XADC_AXI_SYSMON_REG_OFFSET + reg * 4, val);
+
+	return 0;
+}
+
 static int xadc_axi_setup(struct platform_device *pdev,
 	struct iio_dev *indio_dev, int irq)
 {
@@ -551,6 +574,17 @@ static const struct xadc_ops xadc_axi_ops = {
 	.flags = XADC_FLAGS_BUFFERED,
 };
 
+/* AXI sysmon */
+static const struct xadc_ops sysmon_axi_ops = {
+	.read = xadc_axi_read_sysmon_reg,
+	.write = xadc_axi_write_sysmon_reg,
+	.setup = xadc_axi_setup,
+	.get_dclk_rate = xadc_axi_get_dclk,
+	.update_alarm = xadc_axi_update_alarm,
+	.interrupt_handler = xadc_axi_interrupt_handler,
+	.flags = XADC_FLAGS_BUFFERED,
+};
+
 static int _xadc_update_adc_reg(struct xadc *xadc, unsigned int reg,
 	uint16_t mask, uint16_t val)
 {
@@ -1053,23 +1087,23 @@ static const struct iio_chan_spec xadc_channels[] = {
 	XADC_CHAN_VOLTAGE(5, 7, XADC_REG_VCCO_DDR, "vccoddr", true),
 	XADC_CHAN_VOLTAGE(6, 12, XADC_REG_VREFP, "vrefp", false),
 	XADC_CHAN_VOLTAGE(7, 13, XADC_REG_VREFN, "vrefn", false),
-	XADC_CHAN_VOLTAGE(8, 11, XADC_REG_VPVN, NULL, false),
-	XADC_CHAN_VOLTAGE(9, 16, XADC_REG_VAUX(0), NULL, false),
-	XADC_CHAN_VOLTAGE(10, 17, XADC_REG_VAUX(1), NULL, false),
-	XADC_CHAN_VOLTAGE(11, 18, XADC_REG_VAUX(2), NULL, false),
-	XADC_CHAN_VOLTAGE(12, 19, XADC_REG_VAUX(3), NULL, false),
-	XADC_CHAN_VOLTAGE(13, 20, XADC_REG_VAUX(4), NULL, false),
-	XADC_CHAN_VOLTAGE(14, 21, XADC_REG_VAUX(5), NULL, false),
-	XADC_CHAN_VOLTAGE(15, 22, XADC_REG_VAUX(6), NULL, false),
-	XADC_CHAN_VOLTAGE(16, 23, XADC_REG_VAUX(7), NULL, false),
-	XADC_CHAN_VOLTAGE(17, 24, XADC_REG_VAUX(8), NULL, false),
-	XADC_CHAN_VOLTAGE(18, 25, XADC_REG_VAUX(9), NULL, false),
-	XADC_CHAN_VOLTAGE(19, 26, XADC_REG_VAUX(10), NULL, false),
-	XADC_CHAN_VOLTAGE(20, 27, XADC_REG_VAUX(11), NULL, false),
-	XADC_CHAN_VOLTAGE(21, 28, XADC_REG_VAUX(12), NULL, false),
-	XADC_CHAN_VOLTAGE(22, 29, XADC_REG_VAUX(13), NULL, false),
-	XADC_CHAN_VOLTAGE(23, 30, XADC_REG_VAUX(14), NULL, false),
-	XADC_CHAN_VOLTAGE(24, 31, XADC_REG_VAUX(15), NULL, false),
+	XADC_CHAN_VOLTAGE(8, 11, XADC_REG_VPVN, "vpvn", false),
+	XADC_CHAN_VOLTAGE(9, 16, XADC_REG_VAUX(0), "vaux0", false),
+	XADC_CHAN_VOLTAGE(10, 17, XADC_REG_VAUX(1), "vaux1", false),
+	XADC_CHAN_VOLTAGE(11, 18, XADC_REG_VAUX(2), "vaux2", false),
+	XADC_CHAN_VOLTAGE(12, 19, XADC_REG_VAUX(3), "vaux3", false),
+	XADC_CHAN_VOLTAGE(13, 20, XADC_REG_VAUX(4), "vaux4", false),
+	XADC_CHAN_VOLTAGE(14, 21, XADC_REG_VAUX(5), "vaux5", false),
+	XADC_CHAN_VOLTAGE(15, 22, XADC_REG_VAUX(6), "vaux6", false),
+	XADC_CHAN_VOLTAGE(16, 23, XADC_REG_VAUX(7), "vaux7", false),
+	XADC_CHAN_VOLTAGE(17, 24, XADC_REG_VAUX(8), "vaux8", false),
+	XADC_CHAN_VOLTAGE(18, 25, XADC_REG_VAUX(9), "vaux9", false),
+	XADC_CHAN_VOLTAGE(19, 26, XADC_REG_VAUX(10), "vaux10", false),
+	XADC_CHAN_VOLTAGE(20, 27, XADC_REG_VAUX(11), "vaux11", false),
+	XADC_CHAN_VOLTAGE(21, 28, XADC_REG_VAUX(12), "vaux12", false),
+	XADC_CHAN_VOLTAGE(22, 29, XADC_REG_VAUX(13), "vaux13", false),
+	XADC_CHAN_VOLTAGE(23, 30, XADC_REG_VAUX(14), "vaux14", false),
+	XADC_CHAN_VOLTAGE(24, 31, XADC_REG_VAUX(15), "vaux15", false),
 };
 
 static const struct iio_info xadc_info = {
@@ -1085,6 +1119,7 @@ static const struct iio_info xadc_info = {
 static const struct of_device_id xadc_of_match_table[] = {
 	{ .compatible = "xlnx,zynq-xadc-1.00.a", (void *)&xadc_zynq_ops },
 	{ .compatible = "xlnx,axi-xadc-1.00.a", (void *)&xadc_axi_ops },
+	{ .compatible = "xlnx,axi-sysmon-1.3", (void *)&sysmon_axi_ops},
 	{ },
 };
 MODULE_DEVICE_TABLE(of, xadc_of_match_table);
@@ -1094,7 +1129,7 @@ static int xadc_parse_dt(struct iio_dev *indio_dev, struct device_node *np,
 {
 	struct device *dev = indio_dev->dev.parent;
 	struct xadc *xadc = iio_priv(indio_dev);
-	struct iio_chan_spec *channels, *chan;
+	struct iio_chan_spec *iio_xadc_channels;
 	struct device_node *chan_node, *child;
 	unsigned int num_channels;
 	const char *external_mux;
@@ -1137,13 +1172,12 @@ static int xadc_parse_dt(struct iio_dev *indio_dev, struct device_node *np,
 		*conf |= XADC_CONF0_MUX | XADC_CONF0_CHAN(ext_mux_chan);
 	}
 
-	channels = devm_kmemdup(dev, xadc_channels,
+	iio_xadc_channels = devm_kmemdup(dev, xadc_channels,
 				sizeof(xadc_channels), GFP_KERNEL);
-	if (!channels)
+	if (!iio_xadc_channels)
 		return -ENOMEM;
 
 	num_channels = 9;
-	chan = &channels[9];
 
 	chan_node = of_get_child_by_name(np, "xlnx,channels");
 	if (chan_node) {
@@ -1157,29 +1191,24 @@ static int xadc_parse_dt(struct iio_dev *indio_dev, struct device_node *np,
 			if (ret || reg > 16)
 				continue;
 
+			iio_xadc_channels[num_channels] = xadc_channels[reg + 9];
+			iio_xadc_channels[num_channels].channel = num_channels - 1;
+
 			if (of_property_read_bool(child, "xlnx,bipolar"))
-				chan->scan_type.sign = 's';
-
-			if (reg == 0) {
-				chan->scan_index = 11;
-				chan->address = XADC_REG_VPVN;
-			} else {
-				chan->scan_index = 15 + reg;
-				chan->address = XADC_REG_VAUX(reg - 1);
-			}
+				iio_xadc_channels[num_channels].scan_type.sign = 's';
+
 			num_channels++;
-			chan++;
 		}
 	}
 	of_node_put(chan_node);
 
 	indio_dev->num_channels = num_channels;
-	indio_dev->channels = devm_krealloc(dev, channels,
-					    sizeof(*channels) * num_channels,
+	indio_dev->channels = devm_krealloc(dev, iio_xadc_channels,
+					    sizeof(*iio_xadc_channels) * num_channels,
 					    GFP_KERNEL);
 	/* If we can't resize the channels array, just use the original */
 	if (!indio_dev->channels)
-		indio_dev->channels = channels;
+		indio_dev->channels = iio_xadc_channels;
 
 	return 0;
 }
diff --git a/drivers/iio/industrialio-core.c b/drivers/iio/industrialio-core.c
index 261d3b17e..9955672fc 100644
--- a/drivers/iio/industrialio-core.c
+++ b/drivers/iio/industrialio-core.c
@@ -594,6 +594,7 @@ static ssize_t __iio_format_value(char *buf, size_t len, unsigned int type,
 {
 	unsigned long long tmp;
 	int tmp0, tmp1;
+	s64 tmp2;
 	bool scale_db = false;
 
 	switch (type) {
@@ -616,10 +617,13 @@ static ssize_t __iio_format_value(char *buf, size_t len, unsigned int type,
 		else
 			return scnprintf(buf, len, "%d.%09u", vals[0], vals[1]);
 	case IIO_VAL_FRACTIONAL:
-		tmp = div_s64((s64)vals[0] * 1000000000LL, vals[1]);
+		tmp2 = div_s64((s64)vals[0] * 1000000000LL, vals[1]);
 		tmp1 = vals[1];
-		tmp0 = (int)div_s64_rem(tmp, 1000000000, &tmp1);
-		return scnprintf(buf, len, "%d.%09u", tmp0, abs(tmp1));
+		tmp0 = (int)div_s64_rem(tmp2, 1000000000, &tmp1);
+		if ((tmp2 < 0) && (tmp0 == 0))
+			return snprintf(buf, len, "-0.%09u", abs(tmp1));
+		else
+			return snprintf(buf, len, "%d.%09u", tmp0, abs(tmp1));
 	case IIO_VAL_FRACTIONAL_LOG2:
 		tmp = shift_right((s64)vals[0] * 1000000000LL, vals[1]);
 		tmp0 = (int)div_s64_rem(tmp, 1000000000LL, &tmp1);
diff --git a/include/linux/iio/adc/versal-sysmon-events.h b/include/linux/iio/adc/versal-sysmon-events.h
new file mode 100644
index 000000000..ea65278cb
--- /dev/null
+++ b/include/linux/iio/adc/versal-sysmon-events.h
@@ -0,0 +1,55 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Xilinx SYSMON hardware info
+ *
+ * Copyright (C) 2019 - 2021 Xilinx, Inc.
+ *
+ */
+#ifndef _VERSAL_SYSMON_H_
+#define _VERSAL_SYSMON_H_
+
+#include <linux/types.h>
+#include <linux/iio/types.h>
+
+/* Sysmon region ids */
+enum sysmon_region {
+	SYSMON_AIE = 0,
+	SYSMON_PMC = 1,
+	SYSMON_XPIO = 2,
+	SYSMON_VNOC = 3,
+	SYSMON_CC = 4,
+};
+
+/**
+ * struct regional_node - regional node properties
+ * @sat_id: node_id
+ * @x: x co-ordinate of the node
+ * @y: y co-ordinate of the node
+ * @temp: raw sensor value
+ * @regional_node_list: list of nodes in the region
+ */
+struct regional_node {
+	int sat_id;
+	int x;
+	int y;
+	u16 temp;
+	struct list_head regional_node_list;
+};
+
+/**
+ * struct region_info - information about a regions sensors
+ * @id: region id
+ * @cb: callback to be called when there is a region specific event
+ * @data: pointer to the callback data
+ * @node_list: head to the regional_nodes list
+ * @list: list of regions
+ */
+struct region_info {
+	enum sysmon_region id;
+	void (*cb)(void *data, struct regional_node *node);
+	void *data;
+	struct list_head node_list;
+	struct list_head list;
+};
+
+#endif
