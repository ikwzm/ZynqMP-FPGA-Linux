diff --git a/Documentation/devicetree/bindings/phy/xlnx,v-hmdi-phy1.yaml b/Documentation/devicetree/bindings/phy/xlnx,v-hmdi-phy1.yaml
new file mode 100644
index 000000000..c04a777c6
--- /dev/null
+++ b/Documentation/devicetree/bindings/phy/xlnx,v-hmdi-phy1.yaml
@@ -0,0 +1,228 @@
+# SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause) %YAML 1.2
+%YAML 1.2
+---
+$id: http://devicetree.org/schemas/phy/xlnx,v-hmdi-phy1.yaml#
+$schema: http://devicetree.org/meta-schemas/core.yaml#
+
+title: Xilinx HDMI PHY
+
+maintainers:
+  - Rajesh Gugulothu <gugulothu.rajesh@xilinx.com>
+
+description: |
+  The Xilinx HDMI PHY Controller core is designed for enabling plug-and-play
+  connectivity with Xilinx HDMI 2.1 technology MAC transmit or receive
+  subsystems. The interface between the video MAC and PHY layers are
+  standardized to enable ease of use in accessing shared transceiver resource.
+
+properties:
+  compatible:
+    items:
+      - enum:
+          - xlnx,v-hdmi-phy1-1.0
+
+  reg:
+    maxItems: 1
+
+  rxch4-sel-gpios:
+    maxItems: 1
+    description: |
+      Select HDMI 2.1 PHY Rx channel as data or clock based on FRL or TMDS mode.
+      Polarity of this GPIO is GPIO_ACTIVE_LOW
+
+  interrupts:
+    maxItems: 1
+
+  clocks:
+    description: List of clock specifiers
+    items:
+      - description: AXI Lite clock
+      - description: DRP clock
+
+  clock-names:
+    items:
+      - const: axi4lite_aclk
+      - const: drpclk
+
+  xlnx,transceiver-type:
+    description: |
+      Gigabit transceiver type that IP configured with.Possible values are as
+      below -
+      5  - GTHE4
+      6  - GTYE4
+      7  - GTYE5
+    allOf:
+      - $ref: /schemas/types.yaml#/definitions/uint32
+      - enum: [5, 6, 7]
+
+  xlnx,tx-no-of-channels:
+    description: Max number of channels that Tx configured with.
+    allOf:
+      - $ref: /schemas/types.yaml#/definitions/uint32
+      - enum: [1, 2, 4]
+
+  xlnx,rx-no-of-channels:
+    description: Max number of channels that Rx configured with.
+    allOf:
+      - $ref: /schemas/types.yaml#/definitions/uint32
+      - enum: [1, 2, 4]
+
+  xlnx,rx-protocol:
+    description: Protocol type that Tx is configured with.
+    $ref: /schemas/types.yaml#/definitions/uint32
+    minimum: 1
+    maximum: 3
+
+  xlnx,tx-protocol:
+    description: Protocol type that Rx is configured with.
+    $ref: /schemas/types.yaml#/definitions/uint32
+    minimum: 1
+    maximum: 3
+
+  xlnx,nidru:
+    description: nidru present in the IP or not.
+    allOf:
+      - $ref: /schemas/types.yaml#/definitions/uint32
+      - enum: [0, 1]
+
+  xlnx,tx-refclk-sel:
+    description: Available reference clocks for Tx PLL clock selection
+                 multiplexer.
+    $ref: /schemas/types.yaml#/definitions/uint32
+    minimum: 0
+    maximum: 6
+
+  xlnx,rx-refclk-sel:
+    description: Available reference clocks for Rx PLL clock selection
+                 multiplexer.
+    $ref: /schemas/types.yaml#/definitions/uint32
+    minimum: 0
+    maximum: 6
+
+  xlnx,tx-frl-refclk-sel:
+    description: Available reference clocks for Tx PLL FRL(fixed rate link)
+                 clock selection multiplexer.
+    $ref: /schemas/types.yaml#/definitions/uint32
+    minimum: 1
+    maximum: 7
+
+  xlnx,rx-frl-refclk-sel:
+    description: Available reference clocks for Rx PLL FRL(fixed rate link)
+                 clock selection multiplexer.
+    $ref: /schemas/types.yaml#/definitions/uint32
+    minimum: 0
+    maximum: 6
+
+  xlnx,tx-pll-selection:
+    description: Available reference clocks used to driver Tx datapath.
+    $ref: /schemas/types.yaml#/definitions/uint32
+    minimum: 0
+    maximum: 6
+
+  xlnx,rx-pll-selection:
+    description: Available reference clocks used to driver Rx datapath.
+    $ref: /schemas/types.yaml#/definitions/uint32
+    minimum: 0
+    maximum: 6
+
+  xlnx,nidru-refclk-sel:
+    description: Available reference clocks for NI-DRU(non-integer data rate
+                 unit) clock selection multiplexer.
+    $ref: /schemas/types.yaml#/definitions/uint32
+    minimum: 1
+    maximum: 7
+
+  xlnx,transceiver-width:
+    description: Transceiver width that IP is configured with.
+    allOf:
+      - $ref: /schemas/types.yaml#/definitions/uint32
+      - enum: [2, 4]
+
+  xlnx,input-pixels-per-clock:
+    description: |
+      Input number of pixel per clock that IP configured with.
+    allOf:
+      - $ref: /schemas/types.yaml#/definitions/uint32
+      - enum: [1, 2, 4, 8]
+
+  xlnx,use-gt-ch4-hdmi:
+    description: |
+      use 4th GT channel as tx TMDS clock.
+    allOf:
+      - $ref: /schemas/types.yaml#/definitions/uint32
+      - enum: [0, 1]
+
+  xlnx,rx-max-gt-line-rate:
+    description: |
+      Maxmimum Rx GT linerate that IP is configured with.
+    allOf:
+      - $ref: /schemas/types.yaml#/definitions/uint32
+      - enum: [3, 6, 8 ,10, 12]
+
+  xlnx,tx-max-gt-line-rate:
+    description: |
+      Maxmimum Tx GT linerate that IP is configured with.
+    allOf:
+      - $ref: /schemas/types.yaml#/definitions/uint32
+      - enum: [3, 6, 8 ,10, 12]
+
+  "#phy-cells":
+    const: 0
+
+required:
+  - clock-names
+  - clocks
+  - compatible
+  - interrupts
+  - reg
+  - rxch4-sel-gpios
+  - xlnx,transceiver-type
+  - xlnx,tx-no-of-channels
+  - xlnx,rx-no-of-channels
+  - xlnx,tx-refclk-sel
+  - xlnx,rx-refclk-sel
+  - xlnx,tx-frl-refclk-sel
+  - xlnx,rx-frl-refclk-sel
+  - xlnx,tx-pll-selection
+  - xlnx,rx-pll-selection
+  - xlnx,nidru-refclk-sel
+  - xlnx,transceiver-width
+  - xlnx,input-pixels-per-clock
+  - xlnx,use-gt-ch4-hdmi
+  - xlnx,rx-max-gt-line-rate
+  - xlnx,tx-max-gt-line-rate
+  - '#phy-cells'
+
+additionalProperties: false
+
+examples:
+  - |
+   v_hdmi_phy1@80040000 {
+           clock-names = "axi4lite_aclk", "drpclk";
+           clocks =  <&zynqmp_clk 71>, <&zynqmp_clk 71>;
+           compatible = "xlnx,v-hdmi-phy1-1.0";
+           interrupt-parent = <&gic>;
+           interrupts = <0 89 4>;
+           reg = <0x80040000 0x10000>;
+           rxch4-sel-gpios = <&foo_gpio 18 1>;
+           xlnx,transceiver-type = <5>;
+           xlnx,tx-no-of-channels = <4>;
+           xlnx,rx-no-of-channels = <4>;
+           xlnx,rx-protocol = <2>;
+           xlnx,tx-protocol = <2>;
+           xlnx,tx-refclk-sel = <2>;
+           xlnx,rx-refclk-sel = <0>;
+           xlnx,tx-frl-refclk-sel = <2>;
+           xlnx,rx-frl-refclk-sel = <0>;
+           xlnx,tx-pll-selection = <6>;
+           xlnx,rx-pll-selection = <0>;
+           xlnx,nidru = <1>;
+           xlnx,nidru-refclk-sel = <4>;
+           xlnx,transceiver-width = <4>;
+           xlnx,input-pixels-per-clock = <4>;
+           xlnx,use-gt-ch4-hdmi = <1>;
+           xlnx,rx-max-gt-line-rate = <0xc>;
+           xlnx,tx-max-gt-line-rate = <0xc>;
+           #phy-cells = <0>;
+   };
+...
diff --git a/drivers/phy/xilinx/Kconfig b/drivers/phy/xilinx/Kconfig
index d8b0d46b2..47913226d 100644
--- a/drivers/phy/xilinx/Kconfig
+++ b/drivers/phy/xilinx/Kconfig
@@ -11,3 +11,12 @@ config PHY_XILINX_ZYNQMP
 	help
 	  Enable this to support ZynqMP High Speed Gigabit Transceiver
 	  that is part of ZynqMP SoC.
+
+config PHY_XILINX_HDMIPHY
+       tristate "Xilinx HDMI PHY driver"
+       depends on ARCH_ZYNQMP
+       select GENERIC_PHY
+       help
+         Enable this to support HDMI PHY Controller core in FPGA.It is designed
+         for enabling plug-and-play connectivity with xilinx HDMI 2.1
+         technology MAC transmit or receive subsystem.
diff --git a/drivers/phy/xilinx/Makefile b/drivers/phy/xilinx/Makefile
index 3f1f6a2a9..828101308 100644
--- a/drivers/phy/xilinx/Makefile
+++ b/drivers/phy/xilinx/Makefile
@@ -1,3 +1,9 @@
 # SPDX-License-Identifier: GPL-2.0
 
 obj-$(CONFIG_PHY_XILINX_ZYNQMP)		+= phy-zynqmp.o
+obj-$(CONFIG_PHY_XILINX_HDMIPHY)       += xilinx-hdmiphy.o
+xilinx-hdmiphy-objs := xhdmiphy.o
+xilinx-hdmiphy-objs += xhdmiphy_core.o
+xilinx-hdmiphy-objs += xhdmiphy_modules.o
+xilinx-hdmiphy-objs += xhdmiphy_gt_helper.o
+xilinx-hdmiphy-objs += xhdmiphy_mmcm.o
diff --git a/drivers/phy/xilinx/phy-zynqmp.c b/drivers/phy/xilinx/phy-zynqmp.c
index b8ccac6f3..9be9535ad 100644
--- a/drivers/phy/xilinx/phy-zynqmp.c
+++ b/drivers/phy/xilinx/phy-zynqmp.c
@@ -209,6 +209,7 @@ struct xpsgtr_phy {
  * @gtr_mutex: mutex for locking
  * @phys: PHY lanes
  * @refclk_sscs: spread spectrum settings for the reference clocks
+ * @clk: reference clocks
  * @tx_term_fix: fix for GT issue
  * @saved_icm_cfg0: stored value of ICM CFG0 register
  * @saved_icm_cfg1: stored value of ICM CFG1 register
@@ -220,6 +221,7 @@ struct xpsgtr_dev {
 	struct mutex gtr_mutex; /* mutex for locking */
 	struct xpsgtr_phy phys[NUM_LANES];
 	const struct xpsgtr_ssc *refclk_sscs[NUM_LANES];
+	struct clk *clk[NUM_LANES];
 	bool tx_term_fix;
 	unsigned int saved_icm_cfg0;
 	unsigned int saved_icm_cfg1;
@@ -625,6 +627,9 @@ static int xpsgtr_phy_power_on(struct phy *phy)
 	struct xpsgtr_phy *gtr_phy = phy_get_drvdata(phy);
 	int ret = 0;
 
+	/* Skip initialization if not required. */
+	if (!xpsgtr_phy_init_required(gtr_phy))
+		return ret;
 	/*
 	 * Wait for the PLL to lock. For DP, only wait on DP0 to avoid
 	 * cumulating waits for both lanes. The user is expected to initialize
@@ -819,11 +824,15 @@ static struct phy *xpsgtr_xlate(struct device *dev,
 static int __maybe_unused xpsgtr_suspend(struct device *dev)
 {
 	struct xpsgtr_dev *gtr_dev = dev_get_drvdata(dev);
+	unsigned int i;
 
 	/* Save the snapshot ICM_CFG registers. */
 	gtr_dev->saved_icm_cfg0 = xpsgtr_read(gtr_dev, ICM_CFG0);
 	gtr_dev->saved_icm_cfg1 = xpsgtr_read(gtr_dev, ICM_CFG1);
 
+	for (i = 0; i < ARRAY_SIZE(gtr_dev->clk); i++)
+		clk_disable_unprepare(gtr_dev->clk[i]);
+
 	return 0;
 }
 
@@ -833,6 +842,13 @@ static int __maybe_unused xpsgtr_resume(struct device *dev)
 	unsigned int icm_cfg0, icm_cfg1;
 	unsigned int i;
 	bool skip_phy_init;
+	int err;
+
+	for (i = 0; i < ARRAY_SIZE(gtr_dev->clk); i++) {
+		err = clk_prepare_enable(gtr_dev->clk[i]);
+		if (err)
+			goto err_clk_put;
+	}
 
 	icm_cfg0 = xpsgtr_read(gtr_dev, ICM_CFG0);
 	icm_cfg1 = xpsgtr_read(gtr_dev, ICM_CFG1);
@@ -853,6 +869,12 @@ static int __maybe_unused xpsgtr_resume(struct device *dev)
 		gtr_dev->phys[i].skip_phy_init = skip_phy_init;
 
 	return 0;
+
+err_clk_put:
+	while (i--)
+		clk_disable_unprepare(gtr_dev->clk[i]);
+
+	return err;
 }
 
 static const struct dev_pm_ops xpsgtr_pm_ops = {
@@ -866,6 +888,7 @@ static const struct dev_pm_ops xpsgtr_pm_ops = {
 static int xpsgtr_get_ref_clocks(struct xpsgtr_dev *gtr_dev)
 {
 	unsigned int refclk;
+	int ret;
 
 	for (refclk = 0; refclk < ARRAY_SIZE(gtr_dev->refclk_sscs); ++refclk) {
 		unsigned long rate;
@@ -876,16 +899,21 @@ static int xpsgtr_get_ref_clocks(struct xpsgtr_dev *gtr_dev)
 		snprintf(name, sizeof(name), "ref%u", refclk);
 		clk = devm_clk_get_optional(gtr_dev->dev, name);
 		if (IS_ERR(clk)) {
-			if (PTR_ERR(clk) != -EPROBE_DEFER)
-				dev_err(gtr_dev->dev,
-					"Failed to get reference clock %u: %ld\n",
-					refclk, PTR_ERR(clk));
-			return PTR_ERR(clk);
+			ret = dev_err_probe(gtr_dev->dev, PTR_ERR(clk),
+					    "Failed to get reference clock %u\n",
+					    refclk);
+			goto err_clk_put;
 		}
 
 		if (!clk)
 			continue;
 
+		ret = clk_prepare_enable(clk);
+		if (ret)
+			goto err_clk_put;
+
+		gtr_dev->clk[refclk] = clk;
+
 		/*
 		 * Get the spread spectrum (SSC) settings for the reference
 		 * clock rate.
@@ -903,11 +931,18 @@ static int xpsgtr_get_ref_clocks(struct xpsgtr_dev *gtr_dev)
 			dev_err(gtr_dev->dev,
 				"Invalid rate %lu for reference clock %u\n",
 				rate, refclk);
-			return -EINVAL;
+			ret = -EINVAL;
+			goto err_clk_put;
 		}
 	}
 
 	return 0;
+
+err_clk_put:
+	while (refclk--)
+		clk_disable_unprepare(gtr_dev->clk[refclk]);
+
+	return ret;
 }
 
 static int xpsgtr_probe(struct platform_device *pdev)
@@ -916,6 +951,7 @@ static int xpsgtr_probe(struct platform_device *pdev)
 	struct xpsgtr_dev *gtr_dev;
 	struct phy_provider *provider;
 	unsigned int port;
+	unsigned int i;
 	int ret;
 
 	gtr_dev = devm_kzalloc(&pdev->dev, sizeof(*gtr_dev), GFP_KERNEL);
@@ -955,7 +991,8 @@ static int xpsgtr_probe(struct platform_device *pdev)
 		phy = devm_phy_create(&pdev->dev, np, &xpsgtr_phyops);
 		if (IS_ERR(phy)) {
 			dev_err(&pdev->dev, "failed to create PHY\n");
-			return PTR_ERR(phy);
+			ret = PTR_ERR(phy);
+			goto err_clk_put;
 		}
 
 		gtr_phy->phy = phy;
@@ -966,9 +1003,16 @@ static int xpsgtr_probe(struct platform_device *pdev)
 	provider = devm_of_phy_provider_register(&pdev->dev, xpsgtr_xlate);
 	if (IS_ERR(provider)) {
 		dev_err(&pdev->dev, "registering provider failed\n");
-		return PTR_ERR(provider);
+		ret = PTR_ERR(provider);
+		goto err_clk_put;
 	}
 	return 0;
+
+err_clk_put:
+	for (i = 0; i < ARRAY_SIZE(gtr_dev->clk); i++)
+		clk_disable_unprepare(gtr_dev->clk[i]);
+
+	return ret;
 }
 
 static const struct of_device_id xpsgtr_of_match[] = {
diff --git a/drivers/phy/xilinx/xhdmiphy.c b/drivers/phy/xilinx/xhdmiphy.c
new file mode 100644
index 000000000..3ee2fe609
--- /dev/null
+++ b/drivers/phy/xilinx/xhdmiphy.c
@@ -0,0 +1,837 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * Xilinx HDMI PHY
+ *
+ * Copyright (C) 2021 Xilinx, Inc.
+ *
+ * Author: Rajesh Gugulothu <gugulothu.rajesh@xilinx.com>
+ *
+ */
+
+#include <linux/clk.h>
+#include <linux/device.h>
+#include <linux/of_device.h>
+#include <linux/gpio/consumer.h>
+#include <linux/interrupt.h>
+#include <linux/phy/phy.h>
+#include <linux/phy/phy-hdmi.h>
+#include <linux/platform_device.h>
+#include <linux/delay.h>
+#include "xhdmiphy.h"
+
+struct xhdmiphy_lane {
+	struct phy *phy;
+	u32 share_laneclk;
+	u8 direction;
+	u8 lane;
+	void *data;
+};
+
+static int xhdmiphy_init(struct phy *phy)
+{
+	struct xhdmiphy_lane *phy_lane = phy_get_drvdata(phy);
+	struct xhdmiphy_dev *phy_dev = phy_lane->data;
+	unsigned int ret;
+	static int count;
+
+	count++;
+
+	if (count < XHDMIPHY_MAX_LANES)
+		return 0;
+
+	/* initialize HDMI phy */
+	ret = xhdmiphy_init_phy(phy_dev);
+	if (ret != 0) {
+		dev_err(phy_dev->dev, "HDMI PHY initialization error\n");
+		return -ENODEV;
+	}
+	count = 0;
+
+	return 0;
+}
+
+static int xhdmiphy_reset(struct phy *phy)
+{
+	struct xhdmiphy_lane *phy_lane = phy_get_drvdata(phy);
+	struct xhdmiphy_dev *phy_dev = phy_lane->data;
+
+	if (!phy_lane->direction)
+		xhdmiphy_ibufds_en(phy_dev, XHDMIPHY_DIR_TX, false);
+
+	return 0;
+}
+
+static bool xhdmiphy_clk_srcsel(struct xhdmiphy_dev *priv, u8 dir, u8 clksrc)
+{
+	if (priv->data && !priv->data->sel_mux(dir, clksrc))
+		return 0;
+
+	dev_dbg(priv->dev, "failed to select clock source\n");
+
+	return -EIO;
+}
+
+static bool xhdmiphy_set_lrate(struct xhdmiphy_dev *priv, u8 dir, u8 mode,
+			       u64 lrate)
+{
+	if (priv->data && !priv->data->set_linerate(dir, mode, lrate))
+		return 0;
+
+	dev_dbg(priv->dev, "failed to set linerate\n");
+
+	return -EIO;
+}
+
+static int xhdmiphy_configure(struct phy *phy, union phy_configure_opts *opts)
+{
+	struct xhdmiphy_lane *phy_lane = phy_get_drvdata(phy);
+	struct xhdmiphy_dev *phy_dev = phy_lane->data;
+	struct phy_configure_opts_hdmi *cfg = &opts->hdmi;
+	struct hdmiphy_callback *cb_ptr = &cfg->hdmiphycb;
+	unsigned int ret = 0;
+	static int count_tx, count_rx;
+
+	if (!phy_lane->direction) {
+		count_rx++;
+		if (count_rx < XHDMIPHY_MAX_LANES) {
+			return 0;
+		} else if (cfg->ibufds) {
+			xhdmiphy_ibufds_en(phy_dev, XHDMIPHY_DIR_RX,
+					   cfg->ibufds_en);
+		} else if (cfg->tmdsclock_ratio_flag) {
+			/* update TMDS clock ratio */
+			phy_dev->rx_tmdsclock_ratio = cfg->tmdsclock_ratio;
+		} else if (cfg->phycb) {
+			switch (cb_ptr->type) {
+			case RX_INIT_CB:
+				phy_dev->phycb[RX_INIT_CB].cb =
+							cfg->hdmiphycb.cb;
+				phy_dev->phycb[RX_INIT_CB].data =
+							cfg->hdmiphycb.data;
+				break;
+			case RX_READY_CB:
+				phy_dev->phycb[RX_READY_CB].cb =
+							cfg->hdmiphycb.cb;
+				phy_dev->phycb[RX_READY_CB].data =
+							cfg->hdmiphycb.data;
+				break;
+			default:
+				dev_info(phy_dev->dev,
+					 "type - %d phy callback does't match\n\r",
+					 cb_ptr->type);
+				break;
+			}
+		} else if (cfg->cal_mmcm_param) {
+			ret = xhdmiphy_cal_mmcm_param(phy_dev,
+						      XHDMIPHY_CHID_CH1,
+						      XHDMIPHY_DIR_RX, cfg->ppc,
+						      cfg->bpc);
+			if (ret)
+				dev_err(phy_dev->dev,
+					"failed to update mmcm params\n\r");
+
+			xhdmiphy_mmcm_start(phy_dev, XHDMIPHY_DIR_RX);
+		} else if (cfg->clkout1_obuftds) {
+			xhdmiphy_clkout1_obuftds_en(phy_dev, XHDMIPHY_DIR_RX,
+						    cfg->clkout1_obuftds_en);
+			cfg->clkout1_obuftds_en = 0;
+		} else if (cfg->config_hdmi20 && !cfg->config_hdmi21) {
+			/* set Rx ch4 as clock */
+			gpiod_set_value(phy_dev->rxch4_gpio, 0);
+			xhdmiphy_hdmi20_conf(phy_dev, XHDMIPHY_DIR_RX);
+			xhdmiphy_clk_srcsel(phy_dev, phy_lane->direction,
+					    tmds_mode);
+		} else if (!cfg->config_hdmi20 && cfg->config_hdmi21) {
+			/*
+			 * Phy needs to switch between rxch4 as data or
+			 * clk based on FRL or TMDS mode. Note we can have TMDS
+			 * mode in HDMI2.1
+			 */
+			gpiod_set_value(phy_dev->rxch4_gpio, 1);
+			if (phy_dev->conf.rx_refclk_sel !=
+			    phy_dev->conf.rx_frl_refclk_sel) {
+				xhdmiphy_ibufds_en(phy_dev, XHDMIPHY_DIR_RX, 1);
+			}
+
+			xhdmiphy_hdmi21_conf(phy_dev, XHDMIPHY_DIR_RX,
+					     cfg->linerate, cfg->nchannels);
+			xhdmiphy_clk_srcsel(phy_dev, phy_lane->direction,
+					    frl_mode);
+			xhdmiphy_clkdet_freq_reset(phy_dev, XHDMIPHY_DIR_RX);
+			xhdmiphy_set_lrate(phy_dev, phy_lane->direction, 1,
+					   cfg->rx_refclk_hz);
+		} else if (cfg->rx_get_refclk) {
+			cfg->rx_refclk_hz = phy_dev->rx_refclk_hz;
+			xhdmiphy_set_lrate(phy_dev, phy_lane->direction, 1,
+					   cfg->rx_refclk_hz);
+		} else if (cfg->reset_gt) {
+			xhdmiphy_rst_gt_txrx(phy_dev, XHDMIPHY_CHID_CHA,
+					     XHDMIPHY_DIR_RX, false);
+		}
+		count_rx = 0;
+	}
+
+	if (phy_lane->direction) {
+		count_tx++;
+
+		if (count_tx < XHDMIPHY_MAX_LANES) {
+			return 0;
+		} else if (cfg->ibufds) {
+			xhdmiphy_ibufds_en(phy_dev, XHDMIPHY_DIR_TX,
+					   cfg->ibufds_en);
+			cfg->ibufds = 0;
+		} else if (cfg->clkout1_obuftds) {
+			xhdmiphy_clkout1_obuftds_en(phy_dev, XHDMIPHY_DIR_TX,
+						    cfg->clkout1_obuftds_en);
+			cfg->clkout1_obuftds_en = 0;
+		} else if (cfg->tx_params) {
+			xhdmiphy_clk_srcsel(phy_dev, phy_lane->direction,
+					    tmds_mode);
+			usleep_range(1000, 1100);
+			phy_dev->tx_refclk_hz = cfg->tx_tmdsclk;
+
+			clk_set_rate(phy_dev->tmds_clk, phy_dev->tx_refclk_hz);
+			ret = xhdmiphy_set_tx_param(phy_dev,
+						    XHDMIPHY_CHID_CHA,
+						    cfg->ppc, cfg->bpc,
+						    cfg->fmt);
+			if (ret)
+				dev_err(phy_dev->dev,
+					"unable to set requested tx resolutions\n\r");
+			cfg->tx_params = 0;
+			dev_info(phy_dev->dev,
+				 "tx_tmdsclk %lld\n", cfg->tx_tmdsclk);
+			xhdmiphy_set_lrate(phy_dev, phy_lane->direction, 0,
+					   cfg->tx_tmdsclk);
+		} else if (cfg->config_hdmi21) {
+			xhdmiphy_clk_srcsel(phy_dev, phy_lane->direction,
+					    frl_mode);
+			usleep_range(1000, 1100);
+			xhdmiphy_set_lrate(phy_dev, phy_lane->direction, 1,
+					   cfg->tx_tmdsclk);
+			gpiod_set_value(phy_dev->rxch4_gpio, 1);
+			xhdmiphy_hdmi21_conf(phy_dev, XHDMIPHY_DIR_TX,
+					     cfg->linerate, cfg->nchannels);
+			xhdmiphy_clkdet_freq_reset(phy_dev, XHDMIPHY_DIR_TX);
+			cfg->config_hdmi21 = 0;
+		}
+		count_tx = 0;
+	}
+
+	return 0;
+}
+
+static const struct phy_ops xhdmiphy_phyops = {
+	.configure	= xhdmiphy_configure,
+	.reset		= xhdmiphy_reset,
+	.init		= xhdmiphy_init,
+	.owner		= THIS_MODULE,
+};
+
+static struct phy *xhdmiphy_xlate(struct device *dev,
+				  struct of_phandle_args *args)
+{
+	struct xhdmiphy_dev *priv = dev_get_drvdata(dev);
+	struct xhdmiphy_lane *hdmiphy_lane = NULL;
+	struct device_node *hdmiphynode = args->np;
+	int index;
+
+	if (args->args_count != 4) {
+		dev_err(dev, "Invalid number of cells in 'phy' property\n");
+		return ERR_PTR(-EINVAL);
+	}
+
+	if (!of_device_is_available(hdmiphynode)) {
+		dev_warn(dev, "requested PHY is disabled\n");
+		return ERR_PTR(-ENODEV);
+	}
+
+	for (index = 0; index < of_get_child_count(dev->of_node); index++) {
+		if (hdmiphynode == priv->lanes[index]->phy->dev.of_node) {
+			hdmiphy_lane = priv->lanes[index];
+			break;
+		}
+	}
+
+	if (!hdmiphy_lane) {
+		dev_err(dev, "failed to find appropriate phy\n");
+		return ERR_PTR(-EINVAL);
+	}
+
+	hdmiphy_lane->share_laneclk = args->args[2];
+	hdmiphy_lane->direction = args->args[3];
+
+	return hdmiphy_lane->phy;
+}
+
+static irqreturn_t xhdmiphy_irq_handler(int irq, void *dev_id)
+{
+	struct xhdmiphy_dev *priv;
+
+	priv = (struct xhdmiphy_dev *)dev_id;
+	if (!priv)
+		return IRQ_NONE;
+
+	/*
+	 * disable interrupts in the HDMI PHY, they are re-enabled once
+	 * serviced
+	 */
+	xhdmiphy_intr_dis(priv, XHDMIPHY_INTR_ALL_MASK);
+
+	return IRQ_WAKE_THREAD;
+}
+
+static irqreturn_t xhdmiphy_irq_thread(int irq, void *dev_id)
+{
+	struct xhdmiphy_dev *priv;
+	u32 status;
+	u32 event_mask;
+	u32 event_ack;
+
+	priv = (struct xhdmiphy_dev *)dev_id;
+	if (!priv)
+		return IRQ_NONE;
+
+	/* call baremetal interrupt handler with mutex locked */
+	mutex_lock(&priv->hdmiphy_mutex);
+
+	status = xhdmiphy_read(priv, XHDMIPHY_INTR_STS_REG);
+	dev_dbg(priv->dev, "xhdmiphy status = %x\n", status);
+
+	if (priv->conf.gt_type != XHDMIPHY_GTYE5) {
+		event_mask = XHDMIPHY_INTR_QPLL0_LOCK_MASK |
+			     XHDMIPHY_INTR_CPLL_LOCK_MASK |
+			     XHDMIPHY_INTR_QPLL1_LOCK_MASK |
+			     XHDMIPHY_INTR_TXALIGNDONE_MASK |
+			     XHDMIPHY_INTR_TXRESETDONE_MASK |
+			     XHDMIPHY_INTR_RXRESETDONE_MASK |
+			     XHDMIPHY_INTR_TXMMCMUSRCLK_LOCK_MASK |
+			     XHDMIPHY_INTR_RXMMCMUSRCLK_LOCK_MASK;
+	} else {
+		event_mask = XHDMIPHY_INTR_LCPLL_LOCK_MASK |
+			     XHDMIPHY_INTR_RPLL_LOCK_MASK |
+			     XHDMIPHY_INTR_TXGPO_RE_MASK |
+			     XHDMIPHY_INTR_RXGPO_RE_MASK |
+			     XHDMIPHY_INTR_TXRESETDONE_MASK |
+			     XHDMIPHY_INTR_RXRESETDONE_MASK |
+			     XHDMIPHY_INTR_TXMMCMUSRCLK_LOCK_MASK |
+			     XHDMIPHY_INTR_RXMMCMUSRCLK_LOCK_MASK;
+	}
+
+	event_ack = event_mask & status;
+	if (event_ack)
+		xhdmiphy_gt_handler(priv, event_ack, status);
+
+	event_mask = XHDMIPHY_INTR_TXFREQCHANGE_MASK |
+		     XHDMIPHY_INTR_RXFREQCHANGE_MASK |
+		     XHDMIPHY_INTR_TXTMRTIMEOUT_MASK |
+		     XHDMIPHY_INTR_RXTMRTIMEOUT_MASK;
+
+	event_ack = event_mask & status;
+	if (event_ack)
+		xhdmiphy_clkdet_handler(priv, event_ack, status);
+
+	mutex_unlock(&priv->hdmiphy_mutex);
+
+	/* enable interrupt requesting in the PHY */
+	xhdmiphy_intr_en(priv, XHDMIPHY_INTR_ALL_MASK);
+
+	return IRQ_HANDLED;
+}
+
+static int xhdmiphy_parse_of(struct xhdmiphy_dev *priv)
+{
+	struct xhdmiphy_conf *xgtphycfg = &priv->conf;
+	struct device *dev = priv->dev;
+	struct device_node *node = dev->of_node;
+	int rc, val;
+
+	rc = of_property_read_u32(node, "xlnx,transceiver-type", &val);
+	if (rc < 0) {
+		dev_err(priv->dev, "unable to parse %s property\n",
+			"xlnx,transceiver-type");
+		return rc;
+	}
+
+	if (val != XHDMIPHY_GTHE4 && val != XHDMIPHY_GTYE4 &&
+	    val != XHDMIPHY_GTYE5) {
+		dev_err(priv->dev, "dt transceiver-type %d is invalid\n", val);
+		return -EINVAL;
+	}
+	xgtphycfg->gt_type = val;
+
+	rc = of_property_read_u32(node, "xlnx,input-pixels-per-clock", &val);
+	if (rc < 0) {
+		dev_err(priv->dev, "unable to parse %s property\n",
+			"xlnx,input-pixels-per-clock");
+		return rc;
+	}
+
+	if (val != 4 && val != 8) {
+		dev_err(priv->dev, "dt input-pixels-per-clock %d is invalid\n",
+			val);
+		return -EINVAL;
+	}
+	xgtphycfg->ppc = val;
+
+	rc = of_property_read_u32(node, "xlnx,nidru", &val);
+	if (rc < 0) {
+		dev_err(priv->dev, "unable to parse %s property\n",
+			"xlnx,nidru");
+		return rc;
+	}
+
+	if (val != 0 && val != 1) {
+		dev_err(priv->dev, "dt nidru %d is invalid\n",
+			val);
+		return -EINVAL;
+	}
+	xgtphycfg->dru_present = val;
+
+	rc = of_property_read_u32(node, "xlnx,nidru-refclk-sel", &val);
+	if (rc < 0) {
+		dev_err(priv->dev, "unable to parse %s property\n",
+			"xlnx,nidru-refclk-sel");
+		return rc;
+	}
+
+	if (val < XHDMIPHY_PLL_REFCLKSEL_GTREFCLK0 - 1 &&
+	    val > XHDMIPHY_PLL_REFCLKSEL_GTGREFCLK - 1) {
+		dev_err(priv->dev, "dt nidru-refclk-sel %d is invalid\n",
+			val);
+		return -EINVAL;
+	}
+	xgtphycfg->dru_refclk_sel = val;
+
+	rc = of_property_read_u32(node, "xlnx,rx-no-of-channels", &val);
+	if (rc < 0) {
+		dev_err(priv->dev, "unable to parse %s property\n",
+			"xlnx,rx-no-of-channels");
+		return rc;
+	}
+
+	if (val != 1 && val != 2 && val != 4) {
+		dev_err(priv->dev, "dt rx-no-of-channels %d is invalid\n",
+			val);
+		return -EINVAL;
+	}
+	xgtphycfg->rx_channels = val;
+
+	rc = of_property_read_u32(node, "xlnx,tx-no-of-channels", &val);
+	if (rc < 0) {
+		dev_err(priv->dev, "unable to parse %s property\n",
+			"xlnx,tx-no-of-channels");
+		return rc;
+	}
+
+	if (val != 1 && val != 2 && val != 4) {
+		dev_err(priv->dev, "dt tx-no-of-channels %d is invalid\n",
+			val);
+		return -EINVAL;
+	}
+	xgtphycfg->tx_channels = val;
+
+	rc = of_property_read_u32(node, "xlnx,rx-protocol", &val);
+	if (rc < 0) {
+		dev_err(priv->dev, "unable to parse %s property\n",
+			"xlnx,rx-protocol");
+		return rc;
+	}
+
+	if (val != XHDMIPHY_PROT_HDMI && val != XHDMIPHY_PROT_HDMI21 &&
+	    val != XHDMIPHY_PROT_NONE) {
+		dev_err(priv->dev, "dt rx-protocol %d is invalid\n",
+			val);
+		return -EINVAL;
+	}
+	xgtphycfg->rx_protocol = val;
+
+	rc = of_property_read_u32(node, "xlnx,tx-protocol", &val);
+	if (rc < 0) {
+		dev_err(priv->dev, "unable to parse %s property\n",
+			"xlnx,tx-protocol");
+		return rc;
+	}
+
+	if (val != XHDMIPHY_PROT_HDMI && val != XHDMIPHY_PROT_HDMI21 &&
+	    val != XHDMIPHY_PROT_NONE) {
+		dev_err(priv->dev, "dt tx-protocol %d is invalid\n",
+			val);
+		return -EINVAL;
+	}
+	xgtphycfg->tx_protocol = val;
+
+	rc = of_property_read_u32(node, "xlnx,rx-refclk-sel", &val);
+	if (rc < 0) {
+		dev_err(priv->dev, "unable to parse %s property\n",
+			"xlnx,rx-refclk-sel");
+		return rc;
+	}
+
+	if (val < XHDMIPHY_PLL_REFCLKSEL_GTREFCLK0 - 1 &&
+	    val > XHDMIPHY_PLL_REFCLKSEL_GTGREFCLK - 1) {
+		dev_err(priv->dev, "dt rx-refclk-sel %d is invalid\n",
+			val);
+		return -EINVAL;
+	}
+	xgtphycfg->rx_refclk_sel = val;
+
+	rc = of_property_read_u32(node, "xlnx,tx-refclk-sel", &val);
+	if (rc < 0) {
+		dev_err(priv->dev, "unable to parse %s property\n",
+			"xlnx,tx-refclk-sel");
+		return rc;
+	}
+
+	if (val < XHDMIPHY_PLL_REFCLKSEL_GTREFCLK0 - 1 &&
+	    val > XHDMIPHY_PLL_REFCLKSEL_GTGREFCLK - 1) {
+		dev_err(priv->dev, "dt tx-refclk-sel %d is invalid\n",
+			val);
+		return -EINVAL;
+	}
+	xgtphycfg->tx_refclk_sel = val;
+
+	rc = of_property_read_u32(node, "xlnx,rx-pll-selection", &val);
+	if (rc < 0) {
+		dev_err(priv->dev, "unable to parse %s property\n",
+			"xlnx,rx-pll-selection");
+		return rc;
+	}
+
+	if (val < 0 && val > 6) {
+		dev_err(priv->dev, "dt rx-pll-selection %d is invalid\n",
+			val);
+		return -EINVAL;
+	}
+	xgtphycfg->rx_pllclk_sel = val;
+
+	rc = of_property_read_u32(node, "xlnx,tx-pll-selection", &val);
+	if (rc < 0) {
+		dev_err(priv->dev, "unable to parse %s property\n",
+			"xlnx,tx-pll-selection");
+		return rc;
+	}
+
+	if (val < 0 && val > 6) {
+		dev_err(priv->dev, "dt tx-pll-selection %d is invalid\n",
+			val);
+		return -EINVAL;
+	}
+	xgtphycfg->tx_pllclk_sel = val;
+
+	rc = of_property_read_u32(node, "xlnx,transceiver-width", &val);
+	if (rc < 0) {
+		dev_err(priv->dev, "unable to parse %s property\n",
+			"xlnx,transceiver-width");
+		return rc;
+	}
+	if (val != 2 && val != 4) {
+		dev_err(priv->dev, "dt transceiver-width %d is invalid\n",
+			val);
+		return -EINVAL;
+	}
+	xgtphycfg->transceiver_width = val;
+
+	rc = of_property_read_u32(node, "xlnx,rx-max-gt-line-rate", &val);
+	if (rc < 0) {
+		dev_err(priv->dev, "unable to parse %s property\n",
+			"xlnx,rx-max-gt-line-rate");
+		return rc;
+	}
+
+	if (val != 3 && val != 6 && val != 8 && val != 10 && val != 12) {
+		dev_err(priv->dev, "dt rx-max-gt-line-rate %d is invalid\n",
+			val);
+		return -EINVAL;
+	}
+	xgtphycfg->rx_maxrate = val;
+
+	rc = of_property_read_u32(node, "xlnx,tx-max-gt-line-rate", &val);
+	if (rc < 0) {
+		dev_err(priv->dev, "unable to parse %s property\n",
+			"xlnx,tx-max-gt-line-rate");
+		return rc;
+	}
+
+	if (val != 3 && val != 6 && val != 8 && val != 10 && val != 12) {
+		dev_err(priv->dev, "dt tx-max-gt-line-rate %d is invalid\n",
+			val);
+		return -EINVAL;
+	}
+	xgtphycfg->tx_maxrate = val;
+
+	rc = of_property_read_u32(node, "xlnx,use-gt-ch4-hdmi", &val);
+	if (rc < 0) {
+		dev_err(priv->dev, "unable to parse %s property\n",
+			"xlnx,use-gt-ch4-hdmi");
+		return rc;
+	}
+
+	if (val != 0 && val != 1) {
+		dev_err(priv->dev, "dt use-gt-ch4-hdmi %d is invalid\n",
+			val);
+		return -EINVAL;
+	}
+	xgtphycfg->gt_as_tx_tmdsclk = val;
+
+	rc = of_property_read_u32(node, "xlnx,rx-frl-refclk-sel", &val);
+	if (rc < 0) {
+		dev_err(priv->dev, "unable to parse %s property\n",
+			"xlnx,rx-frl-refclk-sel");
+		return rc;
+	}
+
+	if (val < XHDMIPHY_PLL_REFCLKSEL_GTREFCLK0 - 1 &&
+	    val > XHDMIPHY_PLL_REFCLKSEL_GTGREFCLK - 1) {
+		dev_err(priv->dev, "dt rx-frl-refclk-sel %d is invalid\n",
+			val);
+		return -EINVAL;
+	}
+	xgtphycfg->rx_frl_refclk_sel = val;
+
+	rc = of_property_read_u32(node, "xlnx,tx-frl-refclk-sel", &val);
+	if (rc < 0) {
+		dev_err(priv->dev, "unable to parse %s property\n",
+			"xlnx,tx-frl-refclk-sel");
+		return rc;
+	}
+
+	if (val < XHDMIPHY_PLL_REFCLKSEL_GTREFCLK0 - 1 &&
+	    val > XHDMIPHY_PLL_REFCLKSEL_GTGREFCLK - 1) {
+		dev_err(priv->dev, "dt tx-frl-refclk-sel %d is invalid\n",
+			val);
+		return -EINVAL;
+	}
+	xgtphycfg->tx_frl_refclk_sel = val;
+
+	priv->rxch4_gpio = devm_gpiod_get(priv->dev,
+					  "rxch4-sel", GPIOD_OUT_LOW);
+
+	if (IS_ERR(priv->rxch4_gpio)) {
+		if (PTR_ERR(priv->rxch4_gpio) != -EPROBE_DEFER)
+			dev_err(priv->dev, "rxch4-sel not setup in DT\n");
+		return PTR_ERR(priv->rxch4_gpio);
+	}
+
+	return rc;
+}
+
+static int xhdmiphy_clk_init(struct xhdmiphy_dev *priv)
+{
+	unsigned long dru_clk_rate = 0;
+	int err;
+
+	priv->axi_lite_clk = devm_clk_get(priv->dev, "vid_phy_axi4lite_aclk");
+	if (IS_ERR(priv->axi_lite_clk))
+		return dev_err_probe(priv->dev, PTR_ERR(priv->axi_lite_clk),
+				     "failed to get vid_phy_axi4lite_aclk\n");
+
+	priv->tmds_clk = devm_clk_get(priv->dev, "tmds_clock");
+	if (IS_ERR(priv->tmds_clk))
+		return dev_err_probe(priv->dev, PTR_ERR(priv->tmds_clk),
+				     "failed to get tmds_clock\n");
+
+	if (priv->conf.dru_present) {
+		priv->dru_clk = devm_clk_get(priv->dev, "drpclk");
+		if (IS_ERR(priv->dru_clk))
+			return dev_err_probe(priv->dev, PTR_ERR(priv->dru_clk),
+					     "failed to get drpclk\n");
+	} else {
+		dev_dbg(priv->dev, "DRU is not enabled from device tree\n");
+	}
+
+	err = clk_prepare_enable(priv->axi_lite_clk);
+	if (err) {
+		dev_err(priv->dev,
+			"failed to enable axi-lite clk (%d)\n", err);
+		return err;
+	}
+
+	err = clk_prepare_enable(priv->tmds_clk);
+	if (err) {
+		dev_err(priv->dev, "failed to enable tmds_clk (%d)\n", err);
+		goto err_disable_axiclk;
+	}
+
+	if (priv->conf.dru_present) {
+		err = clk_prepare_enable(priv->dru_clk);
+		if (err) {
+			dev_err(priv->dev,
+				"failed to enable nidru clk (%d)\n", err);
+			goto err_disable_tmds_clk;
+		}
+
+		dru_clk_rate = clk_get_rate(priv->dru_clk);
+		dev_dbg(priv->dev, "default dru-clk rate = %lu\n",
+			dru_clk_rate);
+		if (dru_clk_rate != XHDMIPHY_DRU_REF_CLK_HZ) {
+			err = clk_set_rate(priv->dru_clk,
+					   XHDMIPHY_DRU_REF_CLK_HZ);
+			if (err) {
+				dev_err(priv->dev,
+					"Cannot set rate : %d\n", err);
+				return err;
+			}
+			dru_clk_rate = clk_get_rate(priv->dru_clk);
+			dev_dbg(priv->dev,
+				"ref dru-clk rate = %lu\n", dru_clk_rate);
+		}
+	}
+
+	priv->conf.drpclk_freq = dru_clk_rate;
+	priv->conf.axilite_freq = clk_get_rate(priv->axi_lite_clk);
+
+	return 0;
+
+err_disable_tmds_clk:
+	clk_disable_unprepare(priv->tmds_clk);
+err_disable_axiclk:
+	clk_disable_unprepare(priv->axi_lite_clk);
+
+	return err;
+}
+
+static const struct of_device_id xhdmiphy_of_match[] = {
+	{ .compatible = "xlnx,v-hdmi-phy1-1.0" },
+	{},
+};
+
+MODULE_DEVICE_TABLE(of, xhdmiphy_of_match);
+
+static int xhdmiphy_probe(struct platform_device *pdev)
+{
+	struct device_node *child, *np = pdev->dev.of_node;
+	struct xhdmiphy_dev *priv;
+	struct phy_provider *provider;
+	struct xhdmiphy_lane *hdmiphy_lane;
+	struct platform_device *iface_pdev;
+	struct device_node *fnode;
+	struct resource *res;
+	struct phy *phy;
+	int index = 0, ret;
+
+	priv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+
+	priv->dev = &pdev->dev;
+
+	ret = xhdmiphy_parse_of(priv);
+	if (ret) {
+		dev_err(priv->dev, "Error parsing device tree\n");
+		return ret;
+	}
+
+	fnode = of_parse_phandle(np, "xlnx,hdmi-connector", 0);
+	if (!fnode) {
+		dev_err(&pdev->dev, "platform node not found\n");
+		of_node_put(fnode);
+	} else {
+		iface_pdev = of_find_device_by_node(fnode);
+		if (!iface_pdev) {
+			of_node_put(np);
+			return -ENODEV;
+		}
+		priv->data = dev_get_drvdata(&iface_pdev->dev);
+		if (!priv->data) {
+			dev_dbg(&pdev->dev,
+				"platform device not found -EPROBE_DEFER\n");
+			of_node_put(fnode);
+			return -EPROBE_DEFER;
+		}
+		of_node_put(fnode);
+	}
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	priv->phy_base = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(priv->phy_base))
+		return PTR_ERR(priv->phy_base);
+
+	mutex_init(&priv->hdmiphy_mutex);
+
+	for_each_child_of_node(np, child) {
+		if (index >= XHDMIPHY_MAX_LANES) {
+			dev_err(&pdev->dev,
+				"MAX 4 PHY Lanes are supported\n");
+			return -E2BIG;
+		}
+
+		phy = devm_phy_create(&pdev->dev, child, &xhdmiphy_phyops);
+		if (IS_ERR(phy)) {
+			dev_err(&pdev->dev, "failed to create HDMI PHY\n");
+			return PTR_ERR(phy);
+		}
+
+		hdmiphy_lane = devm_kzalloc(&pdev->dev, sizeof(*hdmiphy_lane),
+					    GFP_KERNEL);
+		if (!hdmiphy_lane)
+			return -ENOMEM;
+
+		hdmiphy_lane->lane = index;
+		hdmiphy_lane->share_laneclk = -1;
+		priv->lanes[index] = hdmiphy_lane;
+
+		priv->lanes[index]->phy = phy;
+		phy_set_drvdata(phy, priv->lanes[index]);
+		hdmiphy_lane->data = priv;
+		index++;
+	}
+
+	priv->irq = platform_get_irq(pdev, 0);
+	if (priv->irq > 0) {
+		ret = devm_request_threaded_irq(&pdev->dev,
+						priv->irq, xhdmiphy_irq_handler,
+						xhdmiphy_irq_thread,
+						IRQF_TRIGGER_HIGH,
+						dev_name(priv->dev),
+						priv);
+		if (ret)
+			return ret;
+	}
+
+	platform_set_drvdata(pdev, priv);
+
+	ret = xhdmiphy_clk_init(priv);
+	if (ret)
+		return ret;
+
+	provider = devm_of_phy_provider_register(&pdev->dev, xhdmiphy_xlate);
+	if (IS_ERR(provider)) {
+		dev_err(&pdev->dev, "registering provider failed\n");
+		ret = PTR_ERR(provider);
+		goto err_clk;
+	}
+	return 0;
+
+err_clk:
+	clk_disable_unprepare(priv->dru_clk);
+	clk_disable_unprepare(priv->tmds_clk);
+	clk_disable_unprepare(priv->axi_lite_clk);
+
+	return ret;
+}
+
+static int xhdmiphy_remove(struct platform_device *pdev)
+{
+	struct xhdmiphy_dev *priv = platform_get_drvdata(pdev);
+
+	clk_disable_unprepare(priv->dru_clk);
+	clk_disable_unprepare(priv->tmds_clk);
+	clk_disable_unprepare(priv->axi_lite_clk);
+
+	return 0;
+}
+
+static struct platform_driver xhdmiphy_driver = {
+	.probe = xhdmiphy_probe,
+	.remove = xhdmiphy_remove,
+	.driver = {
+		.name = "xilinx-hdmiphy",
+		.of_match_table	= xhdmiphy_of_match,
+	},
+};
+module_platform_driver(xhdmiphy_driver);
+
+MODULE_LICENSE("GPL v2");
+MODULE_AUTHOR("Rajesh Gugulothu <gugulothu.rajesh@xilinx.com");
+MODULE_DESCRIPTION("Xilinx HDMI PHY driver");
diff --git a/drivers/phy/xilinx/xhdmiphy.h b/drivers/phy/xilinx/xhdmiphy.h
new file mode 100644
index 000000000..73dcd73df
--- /dev/null
+++ b/drivers/phy/xilinx/xhdmiphy.h
@@ -0,0 +1,1115 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+
+#ifndef _XHDMIPHY_H_
+#define _XHDMIPHY_H_
+
+#include <linux/types.h>
+#include <linux/phy/phy.h>
+#include <linux/phy/phy-hdmi.h>
+#include <linux/mutex.h>
+
+/* HDMIPHY core registers: general registers. */
+#define XHDMIPHY_REFCLKSEL_REG			0x010
+#define XHDMIPHY_COMMON_INIT_REG		0x014
+#define XHDMIPHY_PLL_LOCK_STATUS_REG		0x018
+#define XHDMIPHY_TX_INIT_REG			0x01c
+#define XHDMIPHY_RX_INIT_REG			0x024
+#define XHDMIPHY_POWERDOWN_CONTROL_REG		0x030
+#define XHDMIPHY_DRP_CONTROL_CH1_REG		0x040
+#define XHDMIPHY_DRP_STATUS_CH1_REG		0x050
+#define XHDMIPHY_DRP_CONTROL_COMMON_REG		0x060
+#define XHDMIPHY_DRP_STATUS_COMMON_REG		0x064
+#define XHDMIPHY_DRP_CONTROL_TXMMCM_REG		0x124
+#define XHDMIPHY_DRP_STATUS_TXMMCM_REG		0x128
+#define XHDMIPHY_DRP_CONTROL_RXMMCM_REG		0x144
+#define XHDMIPHY_DRP_STATUS_RXMMCM_REG		0x148
+#define XHDMIPHY_CPLL_CAL_PERIOD_REG		0x068
+#define XHDMIPHY_CPLL_CAL_TOL_REG		0x06c
+#define XHDMIPHY_GT_DBG_GPI_REG			0x068
+#define XHDMIPHY_GT_DBG_GPO_REG			0x06c
+#define XHDMIPHY_TX_BUFFER_BYPASS_REG		0x074
+#define XHDMIPHY_TX_DRIVER_CH12_REG		0x07c
+#define XHDMIPHY_TX_DRIVER_CH34_REG		0x080
+#define XHDMIPHY_TX_DRIVER_EXT_REG		0x084
+#define XHDMIPHY_TX_RATE_CH12_REG		0x08c
+#define XHDMIPHY_TX_RATE_CH34_REG		0x090
+#define XHDMIPHY_RX_RATE_CH12_REG		0x98
+#define XHDMIPHY_RX_RATE_CH34_REG		0x9c
+#define XHDMIPHY_DRP_RXCDR_CFG(n)		(0x0e + (n))
+#define XHDMIPHY_RX_CONTROL_REG			0x100
+#define XHDMIPHY_RX_EQ_CDR_REG			0x108
+#define XHDMIPHY_INTR_EN_REG			0x110
+#define XHDMIPHY_INTR_DIS_REG			0x114
+#define XHDMIPHY_INTR_STS_REG			0x11c
+#define XHDMIPHY_MMCM_TXUSRCLK_CTRL_REG		0x0120
+#define XHDMIPHY_BUFGGT_TXUSRCLK_REG		0x0134
+#define XHDMIPHY_MISC_TXUSRCLK_REG		0x0138
+#define XHDMIPHY_MMCM_RXUSRCLK_CTRL_REG		0x0140
+#define XHDMIPHY_BUFGGT_RXUSRCLK_REG		0x0154
+#define XHDMIPHY_MISC_RXUSRCLK_REG		0x0158
+#define XHDMIPHY_CLKDET_CTRL_REG		0x0200
+#define XHDMIPHY_CLKDET_FREQ_TMR_TO_REG		0x0208
+#define XHDMIPHY_CLKDET_FREQ_TX_REG		0x020c
+#define XHDMIPHY_CLKDET_FREQ_RX_REG		0x0210
+#define XHDMIPHY_CLKDET_TMR_TX_REG		0x0214
+#define XHDMIPHY_CLKDET_TMR_RX_REG		0x0218
+#define XHDMIPHY_CLKDET_FREQ_DRU_REG		0x021c
+#define XHDMIPHY_DRU_CTRL_REG			0x0300
+#define XHDMIPHY_DRU_CFREQ_L_REG(ch)		(0x0308 + (12 * ((ch) - 1)))
+#define XHDMIPHY_DRU_CFREQ_H_REG(ch)		(0x030C + (12 * ((ch) - 1)))
+#define XHDMIPHY_PATGEN_CTRL_REG		0x0340
+
+#define XHDMIPHY_INTR_STS_ALL_MASK		0xffffffff
+#define XHDMIPHY_INTR_ALL_MASK		(XHDMIPHY_INTR_TXRESETDONE_MASK | \
+					XHDMIPHY_INTR_RXRESETDONE_MASK | \
+					XHDMIPHY_INTR_CPLL_LOCK_MASK | \
+					XHDMIPHY_INTR_QPLL_LOCK_MASK | \
+					XHDMIPHY_INTR_TXALIGNDONE_MASK | \
+					XHDMIPHY_INTR_QPLL1_LOCK_MASK | \
+					XHDMIPHY_INTR_TXFREQCHANGE_MASK | \
+					XHDMIPHY_INTR_RXFREQCHANGE_MASK | \
+					XHDMIPHY_INTR_TXMMCMUSRCLK_LOCK_MASK | \
+					XHDMIPHY_INTR_RXMMCMUSRCLK_LOCK_MASK | \
+					XHDMIPHY_INTR_TXTMRTIMEOUT_MASK | \
+					XHDMIPHY_INTR_RXTMRTIMEOUT_MASK)
+
+#define XHDMIPHY_DRU_REF_CLK_HZ		100000000
+#define XHDMIPHY_MAX_LANES		4
+#define VPHY_DEVICE_ID_BASE		256
+
+#define XHDMIPHY_GTHE4				5
+#define XHDMIPHY_GTYE4				6
+#define XHDMIPHY_GTYE5				7
+#define XHDMIPHY_REFCLKSEL_MAX			5
+
+/* linerate ranges */
+#define XHDMIPHY_LRATE_3400			3400
+
+/* pll operating ranges */
+#define XHDMIPHY_QPLL0_MIN			9800000000LL
+#define XHDMIPHY_QPLL0_MAX			16375000000LL
+#define XHDMIPHY_QPLL1_MIN			8000000000LL
+#define XHDMIPHY_QPLL1_MAX			13000000000LL
+#define XHDMIPHY_CPLL_MIN			2000000000LL
+#define XHDMIPHY_CPLL_MAX			6250000000LL
+#define XHDMIPHY_LCPLL_MIN_REFCLK		120000000LL
+#define XHDMIPHY_RPLL_MIN_REFCLK		120000000LL
+
+/* HDMI 2.1 GT linerates */
+#define XHDMIPHY_LRATE_3G			3000000000
+#define XHDMIPHY_LRATE_6G			6000000000
+#define XHDMIPHY_LRATE_8G			8000000000
+#define XHDMIPHY_LRATE_10G			10000000000
+#define XHDMIPHY_LRATE_12G			12000000000
+
+#define XHDMIPHY_HDMI14_REFCLK_RANGE1		119990000
+#define XHDMIPHY_HDMI14_REFCLK_RANGE2		204687500
+#define XHDMIPHY_HDMI14_REFCLK_RANGE3		298500000
+#define XHDMIPHY_HDMI20_REFCLK_RANGE1		59400000
+#define XHDMIPHY_HDMI20_REFCLK_RANGE2		84570000
+#define XHDMIPHY_HDMI20_REFCLK_RANGE3		99000000
+#define XHDMIPHY_HDMI20_REFCLK_RANGE4		102343750
+#define XHDMIPHY_HDMI20_REFCLK_RANGE5		124990000
+#define XHDMIPHY_HDMI20_REFCLK_RANGE6		149500000
+#define XHDMIPHY_HDMI20_REFCLK_RANGE7		340000000
+
+#define XHDMIPHY_HDMI_GTYE5_DRU_LRATE		2500000000U
+#define XHDMIPHY_HDMI_GTYE5_DRU_REFCLK		200000000LL
+#define XHDMIPHY_HDMI_GTYE5_DRU_REFCLK_MIN	199990000LL
+#define XHDMIPHY_HDMI_GTYE5_DRU_REFCLK_MAX	200010000LL
+#define XHDMIPHY_HDMI_GTYE5_DRU_REFCLK1		125000000LL
+#define XHDMIPHY_HDMI_GTYE5_DRU_REFCLK1_MIN	124990000LL
+#define XHDMIPHY_HDMI_GTYE5_DRU_REFCLK1_MAX	125010000LL
+#define XHDMIPHY_HDMI_GTYE5_DRU_REFCLK2		400000000LL
+#define XHDMIPHY_HDMI_GTYE5_DRU_REFCLK2_MIN	399990000LL
+#define XHDMIPHY_HDMI_GTYE5_DRU_REFCLK2_MAX	400010000LL
+#define XHDMIPHY_HDMI_GTYE5_LCPLL_REFCLK_MIN	120000000LL
+#define XHDMIPHY_HDMI_GTYE5_RPLL_REFCLK_MIN	120000000LL
+#define XHDMIPHY_HDMI_GTYE5_TX_MMCM_FVCO_MIN	2160000000U
+#define XHDMIPHY_HDMI_GTYE5_TX_MMCM_FVCO_MAX	4320000000U
+#define XHDMIPHY_HDMI_GTYE5_RX_MMCM_FVCO_MIN	2160000000U
+#define XHDMIPHY_HDMI_GTYE5_RX_MMCM_FVCO_MAX	4320000000U
+#define XHDMIPHY_HDMI_GTYE5_PLL_SCALE		1000
+#define XHDMIPHY_HDMI_DEFAULT_VS_VAL		0x1f
+#define XHDMIPHY_HDMI_DEFAULT_PC_PE_VAL		0x4
+#define XHDMIPHY_HDMI_GTYE5_RX_MMCM_SCALE	1
+#define XHDMIPHY_HDMI_GTYE5_TX_MMCM_SCALE	1
+
+#define XHDMIPHY_HDMI_GTYE4_DRU_LRATE		2500000000U
+#define XHDMIPHY_HDMI_GTYE4_DRU_REFCLK		156250000LL
+#define XHDMIPHY_HDMI_GTYE4_DRU_REFCLK_MIN	156240000LL
+#define XHDMIPHY_HDMI_GTYE4_DRU_REFCLK_MAX	156260000LL
+#define XHDMIPHY_HDMI_GTYE4_DRU_REFCLK2		400000000LL
+#define XHDMIPHY_HDMI_GTYE4_DRU_REFCLK2_MIN	399990000LL
+#define XHDMIPHY_HDMI_GTYE4_DRU_REFCLK2_MAX	400010000LL
+#define XHDMIPHY_HDMI_GTYE4_QPLL0_REFCLK_MIN	61250000LL
+#define XHDMIPHY_HDMI_GTYE4_QPLL1_REFCLK_MIN	50000000LL
+#define XHDMIPHY_HDMI_GTYE4_CPLL_REFCLK_MIN	50000000LL
+#define XHDMIPHY_HDMI_GTYE4_TX_MMCM_FVCO_MIN	800000000U
+#define XHDMIPHY_HDMI_GTYE4_TX_MMCM_FVCO_MAX	1600000000U
+#define XHDMIPHY_HDMI_GTYE4_RX_MMCM_FVCO_MIN	800000000U
+#define XHDMIPHY_HDMI_GTYE4_RX_MMCM_FVCO_MAX	1600000000U
+#define XHDMIPHY_HDMI_GTYE4_PLL_SCALE		1000
+#define XHDMIPHY_HDMI_GTYE4_RX_MMCM_SCALE	1
+#define XHDMIPHY_HDMI_GTYE4_TX_MMCM_SCALE	1
+
+#define XHDMIPHY_HDMI_GTHE4_DRU_LRATE		2500000000U
+#define XHDMIPHY_HDMI_GTHE4_DRU_REFCLK		156250000LL
+#define XHDMIPHY_HDMI_GTHE4_DRU_REFCLK_MIN	156240000LL
+#define XHDMIPHY_HDMI_GTHE4_DRU_REFCLK_MAX	156260000LL
+#define XHDMIPHY_HDMI_GTHE4_DRU_REFCLK2		400000000LL
+#define XHDMIPHY_HDMI_GTHE4_DRU_REFCLK2_MIN	399980000LL
+#define XHDMIPHY_HDMI_GTHE4_DRU_REFCLK2_MAX	400020000LL
+#define XHDMIPHY_HDMI_GTHE4_QPLL0_REFCLK_MIN	61250000LL
+#define XHDMIPHY_HDMI_GTHE4_QPLL1_REFCLK_MIN	50000000LL
+#define XHDMIPHY_HDMI_GTHE4_CPLL_REFCLK_MIN	50000000LL
+#define XHDMIPHY_HDMI_GTHE4_TX_MMCM_FVCO_MIN	800000000U
+#define XHDMIPHY_HDMI_GTHE4_TX_MMCM_FVCO_MAX	1600000000U
+#define XHDMIPHY_HDMI_GTHE4_RX_MMCM_FVCO_MIN	800000000U
+#define XHDMIPHY_HDMI_GTHE4_RX_MMCM_FVCO_MAX	1600000000U
+#define XHDMIPHY_HDMI21_FRL_REFCLK		400000000U
+#define XHDMIPHY_HDMI_GTHE4_DEFAULT_VS_VAL	0xb
+#define XHDMIPHY_HDMI_GTHE4_PLL_SCALE		1000
+#define XHDMIPHY_HDMI_GTHE4_RX_MMCM_SCALE	1
+#define XHDMIPHY_HDMI_GTHE4_TX_MMCM_SCALE	1
+
+/* 0x010: reference clock selections */
+#define XHDMIPHY_REFCLKSEL_QPLL0_MASK		0x0000000f
+#define XHDMIPHY_REFCLKSEL_CPLL_MASK		0x000000f0
+#define XHDMIPHY_REFCLKSEL_CPLL_SHIFT		4
+#define XHDMIPHY_REFCLKSEL_QPLL1_MASK		0x00000f00
+#define XHDMIPHY_REFCLKSEL_QPLL1_SHIFT		8
+#define XHDMIPHY_REFCLKSEL_SYSCLKSEL_MASK	0x0f000000
+#define XHDMIPHY_RXSYSCLKSEL_OUT_MASK(_G) ({ \
+		typeof(_G) (G) = (_G); \
+		((((G) == XHDMIPHY_GTTYPE_GTHE4) || \
+		 ((G) == XHDMIPHY_GTTYPE_GTYE4)) ? 0x03000000 : 0x02000000); })
+#define XHDMIPHY_TXSYSCLKSEL_OUT_MASK(_G) ({ \
+		typeof(_G) (G) = (_G); \
+		((((G) == XHDMIPHY_GTTYPE_GTHE4) || \
+		 ((G) == XHDMIPHY_GTTYPE_GTYE4)) ? 0x0C000000 : 0x08000000); })
+#define XHDMIPHY_RXSYSCLKSEL_DATA_MASK(_G) ({ \
+		typeof(_G) (G) = (_G); \
+		((((G) == XHDMIPHY_GTTYPE_GTHE4) || \
+		 ((G) == XHDMIPHY_GTTYPE_GTYE4)) ? 0x30000000 : 0x01000000); })
+#define XHDMIPHY_TXSYSCLKSEL_DATA_MASK(_G) ({ \
+		typeof(_G) (G) = (_G); \
+		((((G) == XHDMIPHY_GTTYPE_GTHE4) || \
+		 ((G) == XHDMIPHY_GTTYPE_GTYE4)) ? 0xC0000000 : 0x04000000); })
+#define XHDMIPHY_RXSYSCLKSEL_OUT_SHIFT(_G) ({ \
+		typeof(_G) (G) = (_G); \
+		((((G) == XHDMIPHY_GTTYPE_GTHE4) || \
+		 ((G) == XHDMIPHY_GTTYPE_GTYE4)) ? 24 : 25); })
+#define XHDMIPHY_TXSYSCLKSEL_OUT_SHIFT(_G) ({ \
+		typeof(_G) (G) = (_G); \
+		((((G) == XHDMIPHY_GTTYPE_GTHE4) || \
+		 ((G) == XHDMIPHY_GTTYPE_GTYE4)) ? 26 : 27); })
+#define XHDMIPHY_RXSYSCLKSEL_DATA_SHIFT(_G) ({ \
+		typeof(_G) (G) = (_G); \
+		((((G) == XHDMIPHY_GTTYPE_GTHE4) || \
+		 ((G) == XHDMIPHY_GTTYPE_GTYE4)) ? 28 : 24); })
+#define XHDMIPHY_TXSYSCLKSEL_DATA_SHIFT(_G) ({ \
+		typeof(_G) (G) = (_G); \
+		((((G) == XHDMIPHY_GTTYPE_GTHE4) || \
+		 ((G) == XHDMIPHY_GTTYPE_GTYE4)) ? 30 : 26); })
+
+/* 0x018: pll lock status */
+#define XHDMIPHY_PLL_LOCK_STATUS_CPLL_MASK(ch)		(0x01 << ((ch) - 1))
+#define XHDMIPHY_PLL_LOCK_STATUS_QPLL0_MASK		0x10
+#define XHDMIPHY_PLL_LOCK_STATUS_QPLL1_MASK		0x20
+#define XHDMIPHY_PLL_LOCK_STATUS_CPLL_ALL_MASK \
+		(XHDMIPHY_PLL_LOCK_STATUS_CPLL_MASK(XHDMIPHY_CHID_CH1) | \
+		 XHDMIPHY_PLL_LOCK_STATUS_CPLL_MASK(XHDMIPHY_CHID_CH2) | \
+		 XHDMIPHY_PLL_LOCK_STATUS_CPLL_MASK(XHDMIPHY_CHID_CH3) | \
+		 XHDMIPHY_PLL_LOCK_STATUS_CPLL_MASK(XHDMIPHY_CHID_CH4))
+#define XHDMIPHY_PLL_LOCK_STATUS_CPLL_HDMI_MASK \
+		(XHDMIPHY_PLL_LOCK_STATUS_CPLL_MASK(XHDMIPHY_CHID_CH1) | \
+		 XHDMIPHY_PLL_LOCK_STATUS_CPLL_MASK(XHDMIPHY_CHID_CH2) | \
+		 XHDMIPHY_PLL_LOCK_STATUS_CPLL_MASK(XHDMIPHY_CHID_CH3))
+#define XHDMIPHY_PLL_LOCK_STATUS_RPLL_MASK		0xc0
+#define XHDMIPHY_PLL_LOCK_STATUS_LCPLL_MASK		0x300
+/* 0x01C, 0x024: TX_INIT, RX_INIT */
+#define XHDMIPHY_TXRX_INIT_GTRESET_MASK(ch)	(0x01 << (8 * ((ch) - 1)))
+#define XHDMIPHY_TXRX_MSTRESET_MASK(ch)		(0x20 << (8 * ((ch) - 1)))
+#define XHDMIPHY_TXRX_INIT_PLLGTRESET_MASK(ch)	(0x80 << (8 * ((ch) - 1)))
+
+#define XHDMIPHY_TXRX_INIT_GTRESET_ALL_MASK \
+		(XHDMIPHY_TXRX_INIT_GTRESET_MASK(XHDMIPHY_CHID_CH1) | \
+		 XHDMIPHY_TXRX_INIT_GTRESET_MASK(XHDMIPHY_CHID_CH2) | \
+		 XHDMIPHY_TXRX_INIT_GTRESET_MASK(XHDMIPHY_CHID_CH3) | \
+		 XHDMIPHY_TXRX_INIT_GTRESET_MASK(XHDMIPHY_CHID_CH4))
+#define XHDMIPHY_TXRX_INIT_PLLGTRESET_ALL_MASK \
+		(XHDMIPHY_TXRX_INIT_PLLGTRESET_MASK(XHDMIPHY_CHID_CH1) | \
+		 XHDMIPHY_TXRX_INIT_PLLGTRESET_MASK(XHDMIPHY_CHID_CH2) | \
+		 XHDMIPHY_TXRX_INIT_PLLGTRESET_MASK(XHDMIPHY_CHID_CH3) | \
+		 XHDMIPHY_TXRX_INIT_PLLGTRESET_MASK(XHDMIPHY_CHID_CH4))
+#define XHDMIPHY_RXPCS_RESET_MASK			0x10101010
+#define XHDMIPHY_TXPCS_RESET_MASK			0x10101010
+
+/* 0x02C: IBUFDS_GTXX_CTRL */
+#define XHDMIPHY_IBUFDS_GTXX_CTRL_GTREFCLK0_CEB_MASK	0x1
+#define XHDMIPHY_IBUFDS_GTXX_CTRL_GTREFCLK1_CEB_MASK	0x2
+
+/* 0x030: power down control */
+#define XHDMIPHY_POWERDOWN_CONTROL_CPLLPD_MASK(ch)	(0x01 << (8 * ((ch) - 1)))
+#define XHDMIPHY_POWERDOWN_CONTROL_QPLL0PD_MASK(ch)	(0x02 << (8 * ((ch) - 1)))
+#define XHDMIPHY_POWERDOWN_CONTROL_QPLL1PD_MASK(ch)	(0x04 << (8 * ((ch) - 1)))
+
+/* 0x040, 0x044, 0x048, 0x04C, 0x060: DRP_CONTROL_CH[1-4], DRP_CONTROL_COMMON */
+#define XHDMIPHY_DRP_CONTROL_DRPADDR_MASK	0x00000ff
+#define XHDMIPHY_DRP_CONTROL_DRPEN_MASK		0x00001000
+#define XHDMIPHY_DRP_CONTROL_DRPWE_MASK		0x00002000
+#define XHDMIPHY_DRP_CONTROL_DRPDI_MASK		0xffff0000
+#define XHDMIPHY_DRP_CONTROL_DRPDI_SHIFT	16
+
+/* 0x050, 0x054, 0x058, 0x05C, 0x064: DRP_STATUS_CH[1-4], DRP_STATUS_COMMON */
+#define XHDMIPHY_DRP_STATUS_DRPO_MASK		0x0ffff
+#define XHDMIPHY_DRP_STATUS_DRPRDY_MASK		0x10000
+#define XHDMIPHY_DRP_STATUS_DRPBUSY_MASK	0x20000
+
+/* 0x068: cpll cal period */
+#define XHDMIPHY_CPLL_CAL_PERIOD_MASK		0x3ffff
+
+/* 0x06C: cpll cal tolerance */
+#define XHDMIPHY_CPLL_CAL_TOL_MASK		0x3ffff
+
+/* 0x068: gpi */
+#define XHDMIPHY_TX_GPI_MASK(ch)		(0x01 << ((ch) - 1))
+#define XHDMIPHY_RX_GPI_MASK(ch)		(0x10 << ((ch) - 1))
+
+/* 0x06C: gpo */
+#define XHDMIPHY_TX_GPO_MASK(ch)		(0x01 << ((ch) - 1))
+#define XHDMIPHY_TX_GPO_MASK_ALL(nch)		(((nch) == 3) ? 0x7 : 0xf)
+#define XHDMIPHY_TX_GPO_SHIFT			0
+
+#define XHDMIPHY_RX_GPO_MASK(ch)		(0x10 << ((ch) - 1))
+#define XHDMIPHY_RX_GPO_MASK_ALL(nch)		(((nch) == 3) ? 0x70 : 0xf0)
+#define XHDMIPHY_RX_GPO_SHIFT			4
+
+/* 0x074: Tx buffer bypass */
+#define XHDMIPHY_TX_BUFFER_BYPASS_TXPHDLYRESET_MASK(ch) \
+						(0x01 << (8 * ((ch) - 1)))
+#define XHDMIPHY_TX_BUFFER_BYPASS_TXPHALIGN_MASK(ch) \
+						(0x02 << (8 * ((ch) - 1)))
+
+/* 0x07c, 0x080: TX_DRIVER_CH12, TX_DRIVER_CH34 */
+#define XHDMIPHY_TX_TXDIFFCTRL_MASK	0xf
+#define XHDMIPHY_TX_DRIVER_TXDIFFCTRL_MASK(ch) \
+				(0x000F << (16 * (((ch) - 1) % 2)))
+#define XHDMIPHY_TX_DRIVER_TXDIFFCTRL_SHIFT(ch) \
+				(16 * (((ch) - 1) % 2))
+#define XHDMIPHY_TX_DRIVER_TXPOSTCURSOR_MASK(ch) \
+				(0x07C0 << (16 * (((ch) - 1) % 2)))
+#define XHDMIPHY_TX_DRIVER_TXPOSTCURSOR_SHIFT(ch) \
+				(6 + (16 * (((ch) - 1) % 2)))
+#define XHDMIPHY_TX_DRIVER_TXPRECURSOR_MASK(ch) \
+				(0xF800 << (16 * (((ch) - 1) % 2)))
+#define XHDMIPHY_TX_DRIVER_TXPRECURSOR_SHIFT(ch) \
+				(11 + (16 * (((ch) - 1) % 2)))
+
+/* 0x084: Tx driver exit */
+#define XHDMIPHY_TX_EXT_TXDIFFCTRL_MASK	0x10
+#define XHDMIPHY_TX_DRIVER_EXT_TXDIFFCTRL_MASK(ch) \
+						(0x0001 << (8 * ((ch) - 1)))
+#define XHDMIPHY_TX_DRIVER_EXT_TXDIFFCTRL_SHIFT(ch) \
+						(8 * ((ch) - 1))
+
+/* 0x08C, 0x090: tx rate ch12, tx rate ch34 */
+#define XHDMIPHY_TX_RATE_MASK(ch)	(0x00ff << (16 * (((ch) - 1) % 2)))
+#define XHDMIPHY_TX_RATE_SHIFT(ch)	(16 * (((ch) - 1) % 2))
+
+/* 0x098, 0x09C: rx rate ch12, rx rate ch34 */
+#define XHDMIPHY_RX_RATE_MASK(ch)	(0x00ff << (16 * (((ch) - 1) % 2)))
+#define XHDMIPHY_RX_RATE_SHIFT(ch)	(16 * (((ch) - 1) % 2))
+
+/* 0x104: rx eq cdr */
+#define XHDMIPHY_RX_CONTROL_RXLPMEN_MASK(ch)	(0x01 << (8 * ((ch) - 1)))
+#define XHDMIPHY_RX_STATUS_RXCDRHOLD_MASK(ch)	(0x02 << (8 * ((ch) - 1)))
+#define XHDMIPHY_RX_STATUS_RXOSOVRDEN_MASK(ch)	(0x04 << (8 * ((ch) - 1)))
+#define XHDMIPHY_RX_STATUS_RXLPMLFKLOVRDEN_MASK(ch) \
+						(0x08 << (8 * ((ch) - 1)))
+#define XHDMIPHY_RX_STATUS_RXLPMHFOVRDEN_MASK(ch) \
+						(0x10 << (8 * ((ch) - 1)))
+#define XHDMIPHY_RX_CONTROL_RXLPMEN_ALL_MASK \
+		(XHDMIPHY_RX_CONTROL_RXLPMEN_MASK(XHDMIPHY_CHID_CH1) | \
+		 XHDMIPHY_RX_CONTROL_RXLPMEN_MASK(XHDMIPHY_CHID_CH2) | \
+		 XHDMIPHY_RX_CONTROL_RXLPMEN_MASK(XHDMIPHY_CHID_CH3) | \
+		 XHDMIPHY_RX_CONTROL_RXLPMEN_MASK(XHDMIPHY_CHID_CH4))
+
+/* 0x110, 0x114, 0x118, 0x11c: INTR_EN, INTR_DIS, INTR_MASK, INTR_STS */
+#define XHDMIPHY_INTR_TXRESETDONE_MASK			BIT(0)
+#define XHDMIPHY_INTR_RXRESETDONE_MASK			BIT(1)
+#define XHDMIPHY_INTR_CPLL_LOCK_MASK			BIT(2)
+#define XHDMIPHY_INTR_QPLL0_LOCK_MASK			BIT(3)
+#define XHDMIPHY_INTR_LCPLL_LOCK_MASK			BIT(3)
+#define XHDMIPHY_INTR_TXALIGNDONE_MASK			BIT(4)
+#define XHDMIPHY_INTR_QPLL1_LOCK_MASK			BIT(5)
+#define XHDMIPHY_INTR_RPLL_LOCK_MASK			BIT(5)
+#define XHDMIPHY_INTR_TXFREQCHANGE_MASK			BIT(6)
+#define XHDMIPHY_INTR_RXFREQCHANGE_MASK			BIT(7)
+#define XHDMIPHY_INTR_TXMMCMUSRCLK_LOCK_MASK		BIT(9)
+#define XHDMIPHY_INTR_RXMMCMUSRCLK_LOCK_MASK		BIT(10)
+#define XHDMIPHY_INTR_TXGPO_RE_MASK			BIT(11)
+#define XHDMIPHY_INTR_RXGPO_RE_MASK			BIT(12)
+#define XHDMIPHY_INTR_TXTMRTIMEOUT_MASK			BIT(30)
+#define XHDMIPHY_INTR_RXTMRTIMEOUT_MASK			BIT(31)
+#define XHDMIPHY_INTR_QPLL_LOCK_MASK		XHDMIPHY_INTR_QPLL0_LOCK_MASK
+
+/* 0x120, 0x140: MMCM_TXUSRCLK_CTRL, MMCM_RXUSRCLK_CTRL */
+#define XHDMIPHY_MMCM_USRCLK_CTRL_RST_MASK		BIT(1)
+#define XHDMIPHY_MMCM_USRCLK_CTRL_LOCKED_MASK		BIT(9)
+#define XHDMIPHY_MMCM_USRCLK_CTRL_PWRDWN_MASK		BIT(10)
+#define XHDMIPHY_MMCM_USRCLK_CTRL_LOCKED_MASK_MASK	BIT(11)
+#define XHDMIPHY_MMCM_USRCLK_CTRL_CLKINSEL_MASK		BIT(12)
+
+#define XHDMIPHY_BUFGGT_XXUSRCLK_DIV_MASK		GENMASK(3, 1)
+#define XHDMIPHY_BUFGGT_XXUSRCLK_DIV_SHIFT		1
+
+/* 0x138, 0x158: MISC_TXUSRCLK_REG, MISC_RXUSERCLK_REG */
+#define XHDMIPHY_MISC_XXUSRCLK_CKOUT1_OEN_MASK		BIT(0)
+#define XHDMIPHY_MISC_XXUSRCLK_REFCLK_CEB_MASK		BIT(1)
+
+/* 0x200: clock detector control */
+#define XHDMIPHY_CLKDET_CTRL_RUN_MASK			BIT(0)
+#define XHDMIPHY_CLKDET_CTRL_TX_TMR_CLR_MASK		BIT(1)
+#define XHDMIPHY_CLKDET_CTRL_RX_TMR_CLR_MASK		BIT(2)
+#define XHDMIPHY_CLKDET_CTRL_RX_FREQ_RST_MASK		BIT(4)
+#define XHDMIPHY_CLKDET_CTRL_FREQ_LOCK_THRESH_SHIFT	5
+#define XHDMIPHY_CLKDET_CTRL_TX_FREQ_RST_MASK		0x8
+/* 0x300: dru control */
+#define XHDMIPHY_DRU_CTRL_RST_MASK(ch)			(0x01 << (8 * ((ch) - 1)))
+#define XHDMIPHY_DRU_CTRL_EN_MASK(ch)			(0x02 << (8 * ((ch) - 1)))
+/* 0x30C, 0x318, 0x324, 0x330: DRU_CFREQ_H_CH[1-4] */
+#define XHDMIPHY_DRU_CFREQ_H_MASK		0x1f
+
+/* 0x340 TMDS PATGEN */
+#define XHDMIPHY_PATGEN_CTRL_ENABLE_MASK	0x80000000
+#define XHDMIPHY_PATGEN_CTRL_RATIO_MASK		0x7
+
+#define XHDMIPHY_CH2IDX(id)		((id) - XHDMIPHY_CHID_CH1)
+#define XHDMIPHY_ISTXMMCM(id)		((id) == XHDMIPHY_CHID_TXMMCM)
+#define XHDMIPHY_ISRXMMCM(id)		((id) == XHDMIPHY_CHID_RXMMCM)
+
+#define xhdmiphy_is_tx_using_cpll(inst, chid) ({ \
+			(XHDMIPHY_PLL_CPLL == \
+			 xhdmiphy_get_pll_type(inst, XHDMIPHY_DIR_TX, chid)); })
+#define xhdmiphy_is_rx_using_cpll(inst, chid) ({ \
+			(XHDMIPHY_PLL_CPLL == \
+			 xhdmiphy_get_pll_type(inst, XHDMIPHY_DIR_RX, chid)); })
+
+/* Following Data is written in to the DRP addresses.
+ * To know the offsets, affected bit positions
+ * and other details, please refer GT Userguide
+ *
+ */
+
+/* masks and registers of GTHE4 DRP */
+#define XDRP_GTHE4_CHN_REG_0028		0x0028
+#define XDRP_GTHE4_CHN_REG_002A		0x002a
+#define XDRP_GTHE4_CHN_REG_00CB		0x00cb
+#define XDRP_GTHE4_CHN_REG_00CC		0x00cc
+#define XDRP_GTHE4_CHN_REG_00BC		0x00bc
+#define XDRP_GTHE4_CHN_REG_0063		0x0063
+#define XDRP_GTHE4_CHN_REG_006D		0x006d
+#define XDRP_GTHE4_CHN_REG_007A		0x007a
+#define XDRP_GTHE4_CHN_REG_007C		0x007c
+#define XDRP_GTHE4_CHN_REG_0011		0x0011
+#define XDRP_GTHE4_CHN_REG_00AF		0x00af
+#define XDRP_GTHE4_CHN_REG_0066		0x0066
+#define XDRP_GTHE4_CHN_REG_0003		0x0003
+#define XDRP_GTHE4_CHN_REG_0116		0x0116
+#define XDRP_GTHE4_CHN_REG_00FB		0x00fb
+#define XDRP_GTHE4_CHN_REG_009D		0x009d
+#define XDRP_GTHE4_CHN_REG_0100		0x0100
+#define XDRP_GTHE4_CHN_REG_003E		0x003e
+#define XDRP_GTHE4_CHN_REG_0085		0x0085
+#define XDRP_GTHE4_CHN_REG_0073		0x0073
+#define XDRP_GTHE4_CHN_REG_00FF		0x00ff
+#define XDRP_GTHE4_CHN_REG_009C		0x009c
+
+#define XDRP_GTHE4_CHN_REG_0063_RXOUT_DIV_MASK			0x07
+#define XDRP_GTHE4_CHN_REG_0063_FLD_RXOUT_DIV_MASK		0x7
+#define XDRP_GTHE4_CHN_REG_007C_TXOUT_DIV_MASK			0x700
+#define XDRP_GTHE4_CHN_REG_007C_FLD_TX_RXDETECT_REF_MASK	0x7
+#define XDRP_GTHE4_CHN_REG_0028_FLD_CPLL_FBDIV_MASK		0xff
+#define XDRP_GTHE4_CHN_REG_0028_FLD_CPLL_FBDIV_SHIFT		8
+#define XDRP_GTHE4_CHN_REG_0028_FLD_CPLL_FBDIV_45_MASK		0x1
+#define XDRP_GTHE4_CHN_REG_0028_FLD_CPLL_FBDIV_45_SHIFT		7
+#define XDRP_GTHE4_CHN_REG_002A_FLD_A_TXDIFFCTRL_MASK		0x1f
+#define XDRP_GTHE4_CHN_REG_002A_FLD_A_TXDIFFCTRL_SHIFT		11
+#define XDRP_GTHE4_CHN_REG_0028_CPLL_FBDIV_MASK			0xff80
+#define XDRP_GTHE4_CHN_REG_002A_CPLL_REFCLK_DIV_MASK		0xf800
+#define XDRP_GTHE4_CHN_REG_003E_DRP_VAL1			57442
+#define XDRP_GTHE4_CHN_REG_003E_DRP_VAL2			57415
+#define XDRP_GTHE4_CHN_REG_0066_RX_INT_DATAWIDTH_MASK		0xf
+#define XDRP_GTHE4_CHN_REG_0003_RX_DATAWIDTH_MASK		0x1e0
+#define XDRP_GTHE4_CHN_REG_0003_RX_DATAWIDTH_ENC_MASK		0xf
+#define XDRP_GTHE4_CHN_REG_0003_RX_DATAWIDTH_ENC_SHIFT		5
+#define XDRP_GTHE4_CHN_REG_0116_CH_RX_HSPMUX_MASK		0x00ff
+#define XDRP_GTHE4_CHN_REG_00FB_PREIQ_FREQ_BST_MASK		0x0030
+#define XDRP_GTHE4_CHN_REG_00FB_TXPI_BIASSET_MASK		0x0006
+#define XDRP_GTHE4_CHN_REG_009C_TXPI_CFG3_CFG4_MASK		0x0060
+#define XDRP_GTHE4_CHN_REG_0116_CH_TX_HSPMUX_MASK		0xff00
+#define XDRP_GTHE4_CHN_REG_007A_TXCLK25_MASK			0xf800
+#define XDRP_GTHE4_CHN_REG_007A_TXCLK25_SHIFT			11
+#define XDRP_GTHE4_CHN_REG_006D_RXCLK25_MASK			0x00f8
+#define XDRP_GTHE4_CHN_REG_0066_RX_WIDEMODE_CDR_MASK_VAL	0x3
+#define XDRP_GTHE4_CHN_REG_007A_TX_DATA_WIDTH_MASK		0xf
+#define XDRP_GTHE4_CHN_REG_0085_TX_INT_DATAWIDTH_MASK		0x3
+#define XDRP_GTHE4_CHN_REG_0085_TX_INT_DATAWIDTH_SHIFT		10
+#define XDRP_GTHE4_CHN_REG_00AF_RXCDR_CGF2_GEN2_MASK		0x3ff
+#define XDRP_GTHE4_CHN_REG_0011_RXCDR_CGF3_GEN2_MASK		0x3f
+#define XDRP_GTHE4_CHN_REG_0011_RXCDR_CGF3_GEN2_SHIFT		10
+#define XDRP_GTHE4_CHN_REG_0066_RX_WIDEMODE_CDR_MASK		0xc
+
+#define XDRP_GTHE4_CMN_REG_0014		0x0014
+#define XDRP_GTHE4_CMN_REG_0018		0x0018
+#define XDRP_GTHE4_CMN_REG_0094		0x0094
+#define XDRP_GTHE4_CMN_REG_0098		0x0098
+#define XDRP_GTHE4_CMN_REG_008D		0x008d
+#define XDRP_GTHE4_CMN_REG_0016		0x0016
+#define XDRP_GTHE4_CMN_REG_000D		0x000d
+#define XDRP_GTHE4_CMN_REG_0096		0x0096
+#define XDRP_GTHE4_CMN_REG_0019		0x0019
+#define XDRP_GTHE4_CMN_REG_0099		0x0099
+#define XDRP_GTHE4_CMN_REG_0030		0x0030
+#define XDRP_GTHE4_CMN_REG_00B0		0x00b0
+
+#define XDRP_GTHE4_CMN_REG_0014_FLD_QPLL0_INIT_CFG1_MASK	0xff
+#define XDRP_GTHE4_CMN_REG_0018_QPLLX_REFCLK_DIV_MASK		0xf80
+#define XDRP_GTHE4_CMN_REG_0018_QPLLX_REFCLK_DIV_MASK1		0x1f
+#define XDRP_GTHE4_CMN_REG_0018_QPLLX_REFCLK_DIV_SHIFT		6
+#define XDRP_GTHE4_CMN_REG_0018_QPLLX_REFCLK_DIV_SHIFT1		7
+#define XDRP_GTHE4_CMN_REG_000D_PPFX_CFG_MASK			0x0fc0
+#define XDRP_GTHE4_CMN_REG_0019_QPLLX_LPF_MASK			0x0003
+#define XDRP_GTHE4_CMN_REG_0030_QPLLX_CFG4_MASK			0x00e7
+
+#define XHDMIPHY_DRP_CPLL_VCO_RANGE1		3000
+#define XHDMIPHY_DRP_CPLL_VCO_RANGE2		4250
+#define XHDMIPHY_DRP_CPLL_CFG0_VAL1		0x01fa
+#define XHDMIPHY_DRP_CPLL_CFG0_VAL2		0x0ffa
+#define XHDMIPHY_DRP_CPLL_CFG0_VAL3		0x03fe
+#define XHDMIPHY_DRP_CPLL_CFG1_VAL1		0x0023
+#define XHDMIPHY_DRP_CPLL_CFG1_VAL2		0x0021
+#define XHDMIPHY_DRP_CPLL_CFG2_VAL1		0x0002
+#define XHDMIPHY_DRP_CPLL_CFG2_VAL2		0x0202
+#define XHDMIPHY_DRP_CPLL_CFG2_VAL3		0x0203
+#define XHDMIPHY_DRP_QPLL_VCO_RANGE1		15000
+#define XHDMIPHY_DRP_QPLL_VCO_RANGE2		13000
+#define XHDMIPHY_DRP_QPLL_VCO_RANGE3		11000
+#define XHDMIPHY_DRP_QPLL_VCO_RANGE4		7000
+#define XHDMIPHY_DRP_QPLL_NFBDIV		40
+#define XHDMIPHY_DRP_QPLL_CP_VAL1		0x007f
+#define XHDMIPHY_DRP_QPLL_CP_VAL2		0x03ff
+#define XHDMIPHY_DRP_QPLL_LPF_VAL1		0x3
+#define XHDMIPHY_DRP_QPLL_LPF_VAL2		0x1
+#define XHDMIPHY_DRP_QPLL_CLKOUT_RANGE1		7500
+#define XHDMIPHY_DRP_QPLL_CLKOUT_RANGE2		3500
+#define XHDMIPHY_DRP_QPLL_CLKOUT_RANGE3		5500
+#define XHDMIPHY_DRP_PPF_MUX_CRNT_CTRL0_VAL1	0x0e00
+#define XHDMIPHY_DRP_PPF_MUX_CRNT_CTRL0_VAL2	0x0800
+#define XHDMIPHY_DRP_PPF_MUX_CRNT_CTRL0_VAL3	0x0600
+#define XHDMIPHY_DRP_PPF_MUX_CRNT_CTRL0_VAL4	0x0400
+#define XHDMIPHY_DRP_PPF_MUX_TERM_CTRL0_VAL1	0x0100
+#define XHDMIPHY_DRP_PPF_MUX_TERM_CTRL0_VAL2	0x0000
+#define XHDMIPHY_DRP_Q_TERM_CLK_VAL1		0x2
+#define XHDMIPHY_DRP_Q_TERM_CLK_VAL2		0x0
+#define XHDMIPHY_DRP_Q_TERM_CLK_VAL3		0x6
+#define XHDMIPHY_DRP_Q_DCRNT_CLK_VAL1		0x5
+#define XHDMIPHY_DRP_Q_DCRNT_CLK_VAL2		0x4
+#define XHDMIPHY_DRP_Q_DCRNT_CLK_VAL3		0x3
+#define XHDMIPHY_DRP_Q_DCRNT_CLK_SHIFT		5
+#define XHDMIPHY_DRP_LINERATEKHZ_1		16400000
+#define XHDMIPHY_DRP_LINERATEKHZ_2		10400000
+#define XHDMIPHY_DRP_LINERATEKHZ_3		10000000
+#define XHDMIPHY_DRP_LINERATEKHZ_4		20000000
+#define XHDMIPHY_DRP_LINERATEKHZ_5		16375000
+#define XHDMIPHY_DRP_LINERATEKHZ_6		8000000
+#define XHDMIPHY_DRP_RXCDR_CFG_WORD3_VAL1	0x0010
+#define XHDMIPHY_DRP_RXCDR_CFG_WORD3_VAL2	0x0018
+#define XHDMIPHY_DRP_RXCDR_CFG_WORD3_VAL3	0x0012
+#define XHDMIPHY_DRP_PREIQ_FREQ_BST_VAL1	3
+#define XHDMIPHY_DRP_PREIQ_FREQ_BST_VAL2	2
+#define XHDMIPHY_DRP_PREIQ_FREQ_BST_VAL3	1
+#define XHDMIPHY_DRP_PREIQ_FREQ_BST_SHIFT	4
+#define XHDMIPHY_DRP_TXOUT_OFFSET		8
+
+#define XHDMIPHY_DRP_PLL_CLKOUT_RANGE1		7500
+#define XHDMIPHY_DRP_PLL_CLKOUT_RANGE2		3500
+#define XHDMIPHY_DRP_PLL_CLKOUT_RANGE3		5500
+#define XHDMIPHY_DRP_PLL_CLKOUT_RANGE4		14110
+#define XHDMIPHY_DRP_PLL_CLKOUT_RANGE5		14000
+#define XHDMIPHY_DRP_PLL_CLKOUT_RANGE8		7000
+#define XHDMIPHY_DRP_PLL_CLKOUT_RANGE9		6500
+#define XHDMIPHY_DRP_PLL_CLKOUT_RANGE10		5500
+#define XHDMIPHY_DRP_PLL_CLKOUT_RANGE11		5156
+#define XHDMIPHY_DRP_PLL_CLKOUT_RANGE12		4500
+#define XHDMIPHY_DRP_PLL_CLKOUT_RANGE13		4000
+#define XHDMIPHY_DRP_PLL_CLKOUT_RANGE14		3500
+#define XHDMIPHY_DRP_PLL_CLKOUT_RANGE15		3000
+#define XHDMIPHY_DRP_PLL_CLKOUT_RANGE16		2500
+#define XHDMIPHY_DRP_PLL_CLKOUT_RANGE17		7500
+#define XHDMIPHY_DRP_PLL_CLKOUT_RANGE18		2000
+
+#define XHDMIPHY_DRP_RXPI_CFG0_VAL1		0x0004
+#define XHDMIPHY_DRP_RXPI_CFG0_VAL2		0x0104
+#define XHDMIPHY_DRP_RXPI_CFG0_VAL3		0x2004
+#define XHDMIPHY_DRP_RXPI_CFG0_VAL4		0x0002
+#define XHDMIPHY_DRP_RXPI_CFG0_VAL5		0x0102
+#define XHDMIPHY_DRP_RXPI_CFG0_VAL6		0x2102
+#define XHDMIPHY_DRP_RXPI_CFG0_VAL7		0x2202
+#define XHDMIPHY_DRP_RXPI_CFG0_VAL8		0x0200
+#define XHDMIPHY_DRP_RXPI_CFG0_VAL9		0x1300
+#define XHDMIPHY_DRP_RXPI_CFG0_VAL10		0x3300
+#define XHDMIPHY_DRP_RXPI_CFG1_VAL1		0x0000
+#define XHDMIPHY_DRP_RXPI_CFG1_VAL2		0x0015
+#define XHDMIPHY_DRP_RXPI_CFG1_VAL3		0x0045
+#define XHDMIPHY_DRP_RXPI_CFG1_VAL4		0x00fd
+#define XHDMIPHY_DRP_RXPI_CFG1_VAL5		0x00ff
+#define XHDMIPHY_DRP_TXPH_CFG_VAL1		0x0723
+#define XHDMIPHY_DRP_TXPH_CFG_VAL2		0x0323
+
+#define XHDMIPHY_DRP_TX_DATAWIDTH_VAL1		40
+#define XHDMIPHY_DRP_TX_DATAWIDTH_VAL2		20
+#define XHDMIPHY_DRP_TX_OUTDIV_VAL1		1
+#define XHDMIPHY_DRP_TX_OUTDIV_VAL2		2
+
+#define XHDMIPHY_DRP_TXPI_CFG_VAL1		0x0000
+#define XHDMIPHY_DRP_TXPI_CFG_VAL2		0x0054
+#define XHDMIPHY_DRP_TXPI_CFG_VAL3		0x03df
+#define XHDMIPHY_DRP_TXPI_CFG3_CFG4_VAL1	0x0
+#define XHDMIPHY_DRP_TXPI_CFG3_CFG4_VAL2	0x1
+#define XHDMIPHY_DRP_TXPI_CFG3_CFG4_VAL3	0x2
+#define XHDMIPHY_DRP_TXPI_CFG3_CFG4_VAL4	0x3
+#define XHDMIPHY_DRP_TXPI_CFG3_CFG4_SHIFT	5
+#define XHDMIPHY_DRP_TXPI_BIASSET_VAL1		3
+#define XHDMIPHY_DRP_TXPI_BIASSET_VAL2		2
+#define XHDMIPHY_DRP_TXPI_BIASSET_VAL3		1
+#define XHDMIPHY_DRP_TXPI_BIASSET_SHIFT		1
+#define XHDMIPHY_DRP_CH_HSPMUX_VAL1		0x68
+#define XHDMIPHY_DRP_CH_HSPMUX_VAL2		0x44
+#define XHDMIPHY_DRP_CH_HSPMUX_VAL3		0x24
+#define XHDMIPHY_DRP_CH_HSPMUX_VAL4		0x3c
+#define XHDMIPHY_DRP_CH_HSPMUX_SHIFT		8
+#define XHDMIPHY_DRP_PLL_CLKOUT_DIV_VAL1	2
+#define XHDMIPHY_DRP_PLL_CLKOUT_DIV_VAL2	1
+#define XHDMIPHY_DRP_PLLX_CLKOUT_VAL1		0x68
+#define XHDMIPHY_DRP_PLLX_CLKOUT_VAL2		0x44
+#define XHDMIPHY_DRP_PLLX_CLKOUT_VAL3		0x24
+#define XHDMIPHY_DRP_PLLX_CLKOUT_VAL4		0x3c
+
+#define XHDMIPHY_DRP_RX_DATAWIDTH_80		80
+#define XHDMIPHY_DRP_RX_DATAWIDTH_64		64
+#define XHDMIPHY_DRP_RX_DATAWIDTH_40		40
+#define XHDMIPHY_DRP_RX_DATAWIDTH_32		32
+#define XHDMIPHY_RX_WIDEMODE_CDR_ENC_VAL1	0x2
+#define XHDMIPHY_RX_WIDEMODE_CDR_ENC_VAL2	0x1
+#define XHDMIPHY_RX_WIDEMODE_CDR_ENC_VAL3	0x0
+#define XHDMIPHY_RX_WIDEMODE_CDR_ENC_SHIFT	2
+#define XHDMIPHY_RXCDR_CFG_WORD0		0x0000
+#define XHDMIPHY_RXCDR_CFG_WORD1		0x0000
+#define XHDMIPHY_RXCDR_CFG_WORD2		0x0262
+#define XHDMIPHY_RXCDR_CFG_WORD3		0x0000
+#define XHDMIPHY_RXCDR_CFG_WORD4		0x0000
+#define XHDMIPHY_RXCDR_CFG_WORD2_RXDIV		0x10
+#define XHDMIPHY_DRP_RXCDR_CFG_GEN3(n)		(0xa2 + (n))
+#define XHDMIPHY_DRP_RXCDR_CFG_WORD3		0x11
+
+/* masks and registers of mmcme4 DRP */
+#define XHDMIPHY_MMCM4_CLKOUT0_REG1		0x08
+#define XHDMIPHY_MMCM4_CLKOUT0_REG2		0x09
+#define XHDMIPHY_MMCM4_CLKOUT1_REG1		0x0a
+#define XHDMIPHY_MMCM4_CLKOUT1_REG2		0x0b
+#define XHDMIPHY_MMCM4_CLKOUT2_REG1		0x0c
+#define XHDMIPHY_MMCM4_CLKOUT2_REG2		0x0d
+#define XHDMIPHY_MMCM4_CLKFBOUT_REG1		0x14
+#define XHDMIPHY_MMCM4_CLKFBOUT_REG2		0x15
+#define XHDMIPHY_MMCM4_DIVCLK_DIV_REG		0x16
+#define XHDMIPHY_MMCM4_DRP_LOCK_REG1		0x18
+#define XHDMIPHY_MMCM4_DRP_LOCK_REG2		0x19
+#define XHDMIPHY_MMCM4_DRP_LOCK_REG3		0x1a
+#define XHDMIPHY_MMCM4_DRP_FILTER_REG1		0x4e
+#define XHDMIPHY_MMCM4_DRP_FILTER_REG2		0x4f
+#define XHDMIPHY_MMCM4_PWR_REG			0x27
+#define XHDMIPHY_MMCM4_WRITE_VAL		0xffff
+
+/* registers and masks of mmcme5 DRP */
+#define XHDMIPHY_MMCM5_DRP_CLKFBOUT_1_REG	0x0c
+#define XHDMIPHY_MMCM5_DRP_CLKFBOUT_2_REG	0x0d
+#define XHDMIPHY_MMCM5_DRP_DIVCLK_DIVIDE_REG	0x21
+#define XHDMIPHY_MMCM5_DRP_DESKEW_REG		0x20
+#define XHDMIPHY_MMCM5_DRP_CLKOUT0_REG1		0x0e
+#define XHDMIPHY_MMCM5_DRP_CLKOUT0_REG2		0x0f
+#define XHDMIPHY_MMCM5_DRP_CLKOUT1_REG1		0x10
+#define XHDMIPHY_MMCM5_DRP_CLKOUT1_REG2		0x11
+#define XHDMIPHY_MMCM5_DRP_CLKOUT2_REG1		0x12
+#define XHDMIPHY_MMCM5_DRP_CLKOUT2_REG2		0x13
+#define XHDMIPHY_MMCM5_DRP_CP_REG1		0x1e
+#define XHDMIPHY_MMCM5_DRP_RES_REG1		0x2a
+#define XHDMIPHY_MMCM5_DRP_LOCK_REG1		0x27
+#define XHDMIPHY_MMCM5_DRP_LOCK_REG2		0x28
+#define XHDMIPHY_MMCM5_WRITE_VAL		0xFFFF
+#define XHDMIPHY_MMCM5_CP_RES_MASK		0xf
+#define XHDMIPHY_MMCM5_RES_MASK			0x1e
+#define XHDMIPHY_MMCM5_LOCK1_MASK1		0x8000
+#define XHDMIPHY_MMCM5_LOCK1_MASK2		0x7fff
+
+enum color_depth {
+	XVIDC_BPC_6 = 6,
+	XVIDC_BPC_8 = 8,
+	XVIDC_BPC_10 = 10,
+	XVIDC_BPC_12 = 12,
+	XVIDC_BPC_14 = 14,
+	XVIDC_BPC_16 = 16,
+};
+
+enum ppc {
+	XVIDC_PPC_1 = 1,
+	XVIDC_PPC_2 = 2,
+	XVIDC_PPC_4 = 4,
+	XVIDC_PPC_8 = 8,
+};
+
+enum color_fmt {
+	/* streaming video formats */
+	XVIDC_CSF_RGB = 0,
+	XVIDC_CSF_YCRCB_444 = 1,
+	XVIDC_CSF_YCRCB_422 = 2,
+	XVIDC_CSF_YCRCB_420 = 3,
+	XVIDC_CSF_YONLY = 4,
+	XVIDC_CSF_RGBA = 5,
+	XVIDC_CSF_YCRCBA_444 = 6,
+};
+
+enum gt_type {
+	XHDMIPHY_GTTYPE_GTHE4 = 5,
+	XHDMIPHY_GTTYPE_GTYE4 = 6,
+	XHDMIPHY_GTTYPE_GTYE5 = 7,
+};
+
+enum prot_type {
+	XHDMIPHY_PROT_HDMI = 1,
+	XHDMIPHY_PROT_HDMI21 = 2,
+	XHDMIPHY_PROT_NONE = 3
+};
+
+enum dir {
+	XHDMIPHY_DIR_RX = 0,
+	XHDMIPHY_DIR_TX = 1,
+	XHDMIPHY_DIR_NONE = 2
+};
+
+enum pll_type {
+	XHDMIPHY_PLL_CPLL = 1,
+	XHDMIPHY_PLL_QPLL = 2,
+	XHDMIPHY_PLL_QPLL0 = 3,
+	XHDMIPHY_PLL_QPLL1 = 4,
+	XHDMIPHY_PLL_LCPLL = 5,
+	XHDMIPHY_PLL_RPLL = 6,
+	XHDMIPHY_PLL_UNKNOWN = 7,
+};
+
+enum chid {
+	XHDMIPHY_CHID_CH1 = 1,
+	XHDMIPHY_CHID_CH2 = 2,
+	XHDMIPHY_CHID_CH3 = 3,
+	XHDMIPHY_CHID_CH4 = 4,
+	XHDMIPHY_CHID_CMN0 = 5, /* QPLL, QPLL0, LCPLL */
+	XHDMIPHY_CHID_CMN1 = 6, /* QPLL1, RPLL */
+	XHDMIPHY_CHID_CHA = 7,
+	XHDMIPHY_CHID_CMNA = 8,
+	XHDMIPHY_CHID_TXMMCM = 9,
+	XHDMIPHY_CHID_RXMMCM = 10,
+	XHDMIPHY_CHID_CMN = XHDMIPHY_CHID_CMN0,
+};
+
+enum refclk_sel {
+	XHDMIPHY_PLL_REFCLKSEL_GTREFCLK0 = 1,
+	XHDMIPHY_PLL_REFCLKSEL_GTREFCLK1 = 2,
+	XHDMIPHY_PLL_REFCLKSEL_GTNORTHREFCLK0 = 3,
+	XHDMIPHY_PLL_REFCLKSEL_GTNORTHREFCLK1 = 4,
+	XHDMIPHY_PLL_REFCLKSEL_GTSOUTHREFCLK0 = 5,
+	XHDMIPHY_PLL_REFCLKSEL_GTSOUTHREFCLK1 = 6,
+	XHDMIPHY_PLL_REFCLKSEL_GTEASTREFCLK0 = 3,
+	XHDMIPHY_PLL_REFCLKSEL_GTEASTREFCLK1 = 4,
+	XHDMIPHY_PLL_REFCLKSEL_GTWESTREFCLK0 = 5,
+	XHDMIPHY_PLL_REFCLKSEL_GTWESTREFCLK1 = 6,
+	XHDMIPHY_PLL_REFCLKSEL_GTGREFCLK = 7,
+};
+
+enum sysclk_data_sel {
+	XHDMIPHY_SYSCLKSELDATA_PLL0_OUTCLK = 0,
+	XHDMIPHY_SYSCLKSELDATA_PLL1_OUTCLK = 1,
+	XHDMIPHY_SYSCLKSELDATA_CPLL_OUTCLK = 0,
+	XHDMIPHY_SYSCLKSELDATA_QPLL_OUTCLK = 1,
+	XHDMIPHY_SYSCLKSELDATA_QPLL0_OUTCLK = 3,
+	XHDMIPHY_SYSCLKSELDATA_QPLL1_OUTCLK = 2,
+};
+
+enum sysclk_outsel {
+	XHDMIPHY_SYSCLKSELOUT_CPLL_REFCLK = 0,
+	XHDMIPHY_SYSCLKSELOUT_QPLL_REFCLK = 1,
+	XHDMIPHY_SYSCLKSELOUT_QPLL0_REFCLK = 2,
+	XHDMIPHY_SYSCLKSELOUT_QPLL1_REFCLK = 3,
+	XHDMIPHY_SYSCLKSELOUT_PLL0_REFCLK = 0,
+	XHDMIPHY_SYSCLKSELOUT_PLL1_REFCLK = 1
+};
+
+enum outclk_sel {
+	XHDMIPHY_OUTCLKSEL_TYPE_OUTCLKPCS = 1,
+	XHDMIPHY_OUTCLKSEL_TYPE_OUTCLKPMA = 2,
+	XHDMIPHY_OUTCLKSEL_TYPE_PLLREFCLK_DIV1 = 3,
+	XHDMIPHY_OUTCLKSEL_TYPE_PLLREFCLK_DIV2 = 4,
+	XHDMIPHY_OUTCLKSEL_TYPE_PROGDIVCLK = 5
+};
+
+enum gt_state {
+	XHDMIPHY_GT_STATE_IDLE = 0,		/* idle state. */
+	XHDMIPHY_GT_STATE_GPO_RE = 1,	/* GPO RE state. */
+	XHDMIPHY_GT_STATE_LOCK = 2,		/* lock state. */
+	XHDMIPHY_GT_STATE_RESET = 3,	/* reset state. */
+	XHDMIPHY_GT_STATE_ALIGN = 4,	/* align state. */
+	XHDMIPHY_GT_STATE_READY = 5,	/* ready state. */
+};
+
+enum mmcm_divs {
+	XHDMIPHY_MMCM_CLKFBOUT_MULT_F = 0,	/* M */
+	XHDMIPHY_MMCM_DIVCLK_DIVIDE = 1,	/* D */
+	XHDMIPHY_MMCM_CLKOUT_DIVIDE = 2	/* On */
+};
+
+enum mmcmclk_insel {
+	XHDMIPHY_MMCM_CLKINSEL_CLKIN1 = 1,
+	XHDMIPHY_MMCM_CLKINSEL_CLKIN2 = 0,
+};
+
+enum tx_patgen {
+	XHDMIPHY_patgen_ratio_10 = 0x1,	/* LR:clock Ratio = 10 */
+	XHDMIPHY_patgen_ratio_20 = 0x2,	/* LR:clock Ratio = 20 */
+	XHDMIPHY_patgen_ratio_30 = 0x3,	/* LR:clock Ratio = 30 */
+	XHDMIPHY_patgen_ratio_40 = 0x4,	/* LR:clock Ratio = 40 */
+	XHDMIPHY_patgen_ratio_50 = 0x5,	/* LR:clock Ratio = 50 */
+};
+
+enum prbs_pat {
+	XHDMIPHY_PRBSSEL_STD_MODE = 0x0,	/* PCattern gen/mon OFF */
+	XHDMIPHY_PRBSSEL_PRBS7 = 0x1,		/* PCRBS-7 */
+	XHDMIPHY_PRBSSEL_PRBS9 = 0x2,		/* PCRBS-9 */
+	XHDMIPHY_PRBSSEL_PRBS15 = 0x3,		/* PCRBS-15 */
+	XHDMIPHY_PRBSSEL_PRBS23 = 0x4,		/* PCRBS-23 */
+	XHDMIPHY_PRBSSEL_PRBS31 = 0x5,		/* PRBS-31 */
+	XHDMIPHY_PRBSSEL_PCIE = 0x8,		/* PCIE compliance pattern */
+	XHDMIPHY_PRBSSEL_SQUARE_2UI = 0x9,	/* square wave with 2 UI */
+	XHDMIPHY_PRBSSEL_SQUARE_16UI = 0xA,	/* square wave with 16 UI */
+};
+
+enum xhdmiphy_mode {
+	tmds_mode = 0,
+	frl_mode = 1,
+};
+
+struct pll_param {
+	u8 m_refclk_div;
+	union {
+		u8 nfb_divs[2];
+		u8 nfb_div;
+		struct {
+			u8 n1fb_div;
+			u8 n2fb_div;
+		};
+	};
+	u16 cdr[5];
+	u8 is_lowerband;
+};
+
+struct channel {
+	u64 linerate;
+	union {
+		struct pll_param qpll_param;
+		struct pll_param cpll_param;
+		struct pll_param pll_param;
+		u16 linerate_cfg;
+	};
+	union {
+		enum refclk_sel cpll_refclk;
+		enum refclk_sel pll_refclk;
+	};
+	union {
+		struct {
+			u8 rx_outdiv;
+			u8 tx_outdiv;
+		};
+		u8 outdiv[2];
+	};
+	union {
+		struct {
+			enum gt_state rx_state;
+			enum gt_state tx_state;
+		};
+		enum gt_state gt_state[2];
+	};
+	union {
+		struct {
+			enum prot_type rx_protocol;
+			enum prot_type tx_protocol;
+		};
+		enum prot_type protocol[2];
+	};
+	union {
+		struct {
+			enum sysclk_data_sel rx_data_refclk;
+			enum sysclk_data_sel tx_data_refclk;
+		};
+		enum sysclk_data_sel data_refclk[2];
+	};
+	union {
+		struct {
+			enum sysclk_outsel rx_outrefclk;
+			enum sysclk_outsel tx_outrefclk;
+		};
+		enum sysclk_outsel out_refclk[2];
+	};
+	 union {
+		struct {
+			enum outclk_sel rx_outlck;
+			enum outclk_sel tx_outclk;
+		};
+		enum outclk_sel outclk_sel[2];
+	};
+	union {
+		struct {
+			u8 rx_dly_bypass;
+			u8 tx_dly_bypass;
+		};
+		u8 dly_bypass;
+	};
+
+	u8 rx_data_width;
+	u8 rx_intdata_width;
+	u8 tx_data_width;
+	u8 tx_intdata_width;
+};
+
+struct xhdmiphy_mmcm {
+	u32 index;
+	u16 clkfbout_mult;
+	u16 divclk_divide;
+	u16 clkout0_div;
+	u16 clkout1_div;
+	u16 clkout2_div;
+};
+
+struct quad {
+	union {
+		struct {
+			struct xhdmiphy_mmcm rx_mmcm;
+			struct xhdmiphy_mmcm tx_mmcm;
+		};
+		struct xhdmiphy_mmcm mmcm[2];
+	};
+	union {
+		struct {
+			struct channel ch1;
+			struct channel ch2;
+			struct channel ch3;
+			struct channel ch4;
+			union {
+				struct channel cmn0;
+				struct channel lcpll;
+			};
+			union {
+				struct channel cmn1;
+				struct channel rpll;
+			};
+		};
+		struct channel plls[6];
+	};
+	union {
+		struct {
+			u32 gt_refclk0;
+			u32 gt_refclk1;
+			u32 gt_nrefclk0;
+			u32 gt_nrefclk1;
+			u32 gt_srefclk0;
+			u32 gt_srefclk1;
+			u32 gt_grefclk;
+		};
+	u32 refclk[7];
+	};
+};
+
+struct hdmi21_cfg {
+	u64 linerate;
+	u8 nchannels;
+	u8 is_en;
+};
+
+struct clk_config {
+	int (*sel_mux)(u8 direction, u8 clksrc);
+	int (*set_linerate)(u8 direction, u8 mode, u64 lrate);
+};
+
+struct xhdmiphy_conf {
+	u8 tx_channels;
+	u8 rx_channels;
+	enum gt_type gt_type;
+	enum prot_type tx_protocol;
+	enum prot_type rx_protocol;
+	enum refclk_sel tx_refclk_sel;		/* tx refclk selection. */
+	enum refclk_sel rx_refclk_sel;		/* rx refclk selection. */
+	enum refclk_sel tx_frl_refclk_sel;	/* tx frl refclk selection. */
+	enum refclk_sel rx_frl_refclk_sel;	/* rx frl refclk selection. */
+	enum sysclk_data_sel tx_pllclk_sel;	/* tx sysclk selection. */
+	enum sysclk_data_sel rx_pllclk_sel;	/* rx sysclk selectino. */
+	u8 dru_present;
+	enum refclk_sel dru_refclk_sel;		/* DRU REFCLK selection. */
+	enum ppc ppc;
+	u8 tx_buff_bypass;
+	u8 fast_switch;
+	u8 transceiver_width;
+	u32 err_irq;		/* Error IRQ is enalbed in design */
+	u32 axilite_freq;
+	u32 drpclk_freq;
+	u8 gt_as_tx_tmdsclk;	/* use 4th GT channel as tx TMDS clock */
+	u8 rx_maxrate;
+	u8 tx_maxrate;
+};
+
+struct xhdmiphy_dev {
+	struct device *dev;
+	void __iomem *phy_base;
+	struct hdmiphy_callback phycb[TX_READY_CB];
+	int irq;
+	struct mutex hdmiphy_mutex;	/* protecting phy operations */
+	struct xhdmiphy_lane *lanes[4];
+	struct clk_config *data;
+	struct clk *axi_lite_clk;
+	struct clk *dru_clk;
+	struct clk *tmds_clk;
+	struct xhdmiphy_conf conf;
+	const struct gt_conf *gt_adp;
+	struct hdmi21_cfg tx_hdmi21_cfg;
+	struct hdmi21_cfg rx_hdmi21_cfg;
+	struct quad quad;
+	struct gpio_desc *rxch4_gpio;
+	u32 rx_refclk_hz;
+	u32 tx_refclk_hz;
+	u8 bpc;
+	u32 color_fmt;
+	u8 rx_tmdsclock_ratio;
+	u8 tx_samplerate;
+	u8 rx_dru_enabled;
+	u8 qpll_present;
+};
+
+void xhdmiphy_set_clr(struct xhdmiphy_dev *inst, u32 addr, u32 reg_val,
+		      u32 mask_val, u8 set_clr);
+void xhdmiphy_ch2ids(struct xhdmiphy_dev *inst, enum chid chid, u8 *id0,
+		     u8 *id1);
+u32 xhdmiphy_pll_cal(struct xhdmiphy_dev *inst, enum chid chid, enum dir dir,
+		     u32 pllclk_infreq_hz);
+void xhdmiphy_write_refclksel(struct xhdmiphy_dev *inst);
+void xhdmiphy_pll_refclk_sel(struct xhdmiphy_dev *inst, enum chid chid,
+			     enum refclk_sel refclk_sel);
+void xhdmiphy_sysclk_data_sel(struct xhdmiphy_dev *inst, enum dir dir,
+			      enum sysclk_data_sel sysclk_datasel);
+void xhdmiphy_sysclk_out_sel(struct xhdmiphy_dev *inst, enum dir dir,
+			     enum sysclk_outsel sysclk_outsel);
+u32 xhdmiphy_get_quad_refclk(struct xhdmiphy_dev *inst,
+			     enum refclk_sel refclk_type);
+bool xhdmiphy_check_linerate_cfg(struct xhdmiphy_dev *inst, enum chid chid,
+				 enum dir dir);
+void xhdmiphy_set_gpi(struct xhdmiphy_dev *inst, enum chid chid, enum dir dir,
+		      u8 set);
+u8 xhdmiphy_get_gpo(struct xhdmiphy_dev *inst, enum chid chid, enum dir dir);
+void xhdmiphy_mmcm_reset(struct xhdmiphy_dev *inst, enum dir dir, u8 hold);
+void xhdmiphy_mmcm_lock_en(struct xhdmiphy_dev *inst, enum dir dir, u8 en);
+
+void xhdmiphy_set_bufgtdiv(struct xhdmiphy_dev *inst, enum dir dir, u8 div);
+void xhdmiphy_powerdown_gtpll(struct xhdmiphy_dev *inst, enum chid chid, u8 hold);
+
+void xhdmiphy_intr_en(struct xhdmiphy_dev *inst, u32 intr);
+void xhdmiphy_intr_dis(struct xhdmiphy_dev *inst, u32 intr);
+
+u64 xhdmiphy_get_pll_vco_freq(struct xhdmiphy_dev *inst, enum chid chid,
+			      enum dir dir);
+bool xhdmiphy_is_hdmi(struct xhdmiphy_dev *inst, enum dir dir);
+bool xhdmiphy_is_ch(enum chid chid);
+bool xhdmiphy_is_cmn(enum chid chid);
+bool xhdmiphy_is_using_qpll(struct xhdmiphy_dev *inst, enum chid chid,
+			    enum dir dir);
+u32 xhdmiphy_qpll_param(struct xhdmiphy_dev *inst, enum chid chid, enum dir dir);
+u32 xhdmiphy_cpll_param(struct xhdmiphy_dev *inst, enum chid chid, enum dir dir);
+
+void xhdmiphy_gt_handler(struct xhdmiphy_dev *inst, u32 event_ack, u32 event);
+void xhdmiphy_clkdet_handler(struct xhdmiphy_dev *inst, u32 event_ack, u32 event);
+void xhdmiphy_cfg_init(struct xhdmiphy_dev *inst);
+void xhdmiphy_pll_init(struct xhdmiphy_dev *inst, enum chid chid,
+		       enum refclk_sel qpll_refclk_sel,
+		       enum refclk_sel cpll_refclk_sel,
+		       enum pll_type txpll_sel, enum pll_type rxpll_sel);
+void xhdmiphy_cfg_linerate(struct xhdmiphy_dev *inst, enum chid chid,
+			   u64 linerate);
+u32 xhdmiphy_get_pll_type(struct xhdmiphy_dev *inst, enum dir dir,
+			  enum chid chid);
+u64 xhdmiphy_get_linerate(struct xhdmiphy_dev *inst, enum chid chid);
+void xhdmiphy_set_tx_vs(struct xhdmiphy_dev *inst, enum chid chid, u8 vs);
+void xhdmiphy_set_tx_pe(struct xhdmiphy_dev *inst, enum chid chid, u8 pe);
+void xhdmiphy_set_tx_pc(struct xhdmiphy_dev *inst, enum chid chid, u8 pc);
+void xhdmiphy_set_rxlpm(struct xhdmiphy_dev *inst, enum chid chid,
+			enum dir dir, u8 en);
+u32 xhdmiphy_drpwr(struct xhdmiphy_dev *inst, enum chid chid, u16 addr,
+		   u16 val);
+u32 xhdmiphy_drprd(struct xhdmiphy_dev *inst, enum chid chid, u16 addr,
+		   u16 *reg_val);
+void xhdmiphy_mmcm_pwr_down(struct xhdmiphy_dev *inst, enum dir dir, u8 hold);
+void xhdmiphy_mmcm_start(struct xhdmiphy_dev *inst, enum dir dir);
+void xhdmiphy_mmcm_param(struct xhdmiphy_dev *inst, enum dir dir);
+void xhdmiphy_ibufds_en(struct xhdmiphy_dev *inst, enum dir dir, u8 en);
+void xhdmiphy_clkout1_obuftds_en(struct xhdmiphy_dev *inst, enum dir dir, u8 en);
+void xhdmiphy_rst_gt_txrx(struct xhdmiphy_dev *inst, enum chid chid,
+			  enum dir dir, u8 hold);
+u32 xhdmiphy_init_phy(struct xhdmiphy_dev *inst);
+u32 xhdmiphy_set_tx_param(struct xhdmiphy_dev *inst, enum chid chid,
+			  enum ppc ppc, enum color_depth bpc,
+			  enum color_fmt fmt);
+u32 xhdmiphy_cal_mmcm_param(struct xhdmiphy_dev *inst, enum chid chid,
+			    enum dir dir, enum ppc ppc, enum color_depth bpc);
+u32 xhdmiphy_get_dru_refclk(struct xhdmiphy_dev *inst);
+void xhdmiphy_hdmi20_conf(struct xhdmiphy_dev *inst, enum dir dir);
+u32 xhdmiphy_hdmi21_conf(struct xhdmiphy_dev *inst, enum dir dir, u64 linerate, u8 nchannels);
+void xhdmiphy_clkdet_freq_reset(struct xhdmiphy_dev *inst, enum dir dir);
+u32 xhdmiphy_read(struct xhdmiphy_dev *inst, u32 addr);
+void xhdmiphy_write(struct xhdmiphy_dev *inst, u32 addr, u32 val);
+
+struct gtpll_divs {
+	const u8 *m;
+	const u8 *n1;
+	const u8 *n2;
+	const u8 *d;
+};
+
+struct gt_conf {
+	bool (*cfg_set_cdr)(struct xhdmiphy_dev *inst, enum chid);
+	bool (*check_pll_oprange)(struct xhdmiphy_dev *inst, enum chid,
+				  u64 pllclk_out_freq);
+	u32 (*outdiv_ch_reconf)(struct xhdmiphy_dev *inst, enum chid, enum dir);
+	u32 (*clk_ch_reconf)(struct xhdmiphy_dev *inst, enum chid);
+	u32 (*clk_cmn_reconf)(struct xhdmiphy_dev *inst, enum chid);
+	u32 (*rxch_reconf)(struct xhdmiphy_dev *inst, enum chid);
+	u32 (*txch_reconf)(struct xhdmiphy_dev *inst, enum chid);
+	struct gtpll_divs cpll_divs;
+	struct gtpll_divs qpll_divs;
+};
+
+u32 xhdmiphy_outdiv_ch_reconf(struct xhdmiphy_dev *instinst, enum chid chid,
+			      enum dir dir);
+u32 xhdmiphy_clk_ch_reconf(struct xhdmiphy_dev *instinst, enum chid chid);
+u32 xhdmiphy_clk_cmn_reconf(struct xhdmiphy_dev *instinst, enum chid chid);
+u32 xhdmiphy_rxch_reconf(struct xhdmiphy_dev *instinst, enum chid chid);
+u32 xhdmiphy_txch_reconf(struct xhdmiphy_dev *instinst, enum chid chid);
+
+extern const struct gt_conf gthe4_conf;
+extern const struct gt_conf gtye5_conf;
+#endif /* XHDMIPHY_H_ */
+/** @} */
diff --git a/drivers/phy/xilinx/xhdmiphy_core.c b/drivers/phy/xilinx/xhdmiphy_core.c
new file mode 100644
index 000000000..5f0352248
--- /dev/null
+++ b/drivers/phy/xilinx/xhdmiphy_core.c
@@ -0,0 +1,1108 @@
+// SPDX-License-Identifier: GPL-2.0-only
+
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <linux/iopoll.h>
+#include <linux/string.h>
+#include "xhdmiphy.h"
+
+u32 xhdmiphy_read(struct xhdmiphy_dev *inst, u32 addr)
+{
+	return ioread32(inst->phy_base + addr);
+}
+
+void xhdmiphy_write(struct xhdmiphy_dev *inst, u32 addr, u32 value)
+{
+	iowrite32(value, inst->phy_base + addr);
+}
+
+void xhdmiphy_set_clr(struct xhdmiphy_dev *inst, u32 addr, u32 reg_val,
+		      u32 mask_val, u8 set_clr)
+{
+	if (set_clr)
+		reg_val |= mask_val;
+	else
+		reg_val &= ~mask_val;
+
+	xhdmiphy_write(inst, addr, reg_val);
+}
+
+/**
+ * xhdmiphy_cfg_set_cdr - This function is a transceiver adaptor to set the
+ * clock and data recovery (CDR) values for a given channel.
+ *
+ * @inst:	inst is a pointer to the xhdmiphy core instance
+ * @chid:	chid is the channel id to operate on
+ *
+ * @return:	- 0 if the configuration was successful
+ *		- 1 otherwise
+ */
+static bool xhdmiphy_cfg_set_cdr(struct xhdmiphy_dev *inst, enum chid chid)
+{
+	return inst->gt_adp->cfg_set_cdr(inst, chid);
+}
+
+/**
+ * xhdmiphy_check_pll_oprange - This function is a transceiver adaptor to check
+ * if a given PLL output frequency is within the operating range of the PLL for
+ * the GT type.
+ *
+ * @inst:		inst is a pointer to the xhdmiphy core instance
+ * @chid:		chid is the channel ID to operate on
+ * @pllclk_out_freq:	pllclk_out_freq is the frequency to check
+ *
+ * @return:	- 0 if the frequency resides within the PLL's range
+ *		- 1 otherwise
+ */
+static bool xhdmiphy_check_pll_oprange(struct xhdmiphy_dev *inst, enum chid chid,
+				       u64 pllclk_out_freq)
+{
+	return inst->gt_adp->check_pll_oprange(inst, chid, pllclk_out_freq);
+}
+
+u32 xhdmiphy_outdiv_ch_reconf(struct xhdmiphy_dev *inst, enum chid chid,
+			      enum dir dir)
+{
+	return inst->gt_adp->outdiv_ch_reconf(inst, chid, dir);
+}
+
+u32 xhdmiphy_clk_ch_reconf(struct xhdmiphy_dev *inst, enum chid chid)
+{
+	return inst->gt_adp->clk_ch_reconf(inst, chid);
+}
+
+u32 xhdmiphy_clk_cmn_reconf(struct xhdmiphy_dev *inst, enum chid chid)
+{
+	return inst->gt_adp->clk_cmn_reconf(inst, chid);
+}
+
+u32 xhdmiphy_rxch_reconf(struct xhdmiphy_dev *inst, enum chid chid)
+{
+	return inst->gt_adp->rxch_reconf(inst, chid);
+}
+
+u32 xhdmiphy_txch_reconf(struct xhdmiphy_dev *inst, enum chid chid)
+{
+	return inst->gt_adp->txch_reconf(inst, chid);
+}
+
+/**
+ * xhdmiphy_is_hdmi - This function checks if Instance is HDMI 2.0 or HDMI 2.1
+ *
+ * @inst:	inst is a pointer to the HDMIPHY instance
+ * @dir:	dir is an indicator for RX or TX
+ *
+ * @return:	true if HDMI 2.0 or 2.1 else false
+ */
+bool xhdmiphy_is_hdmi(struct xhdmiphy_dev *inst, enum dir dir)
+{
+	if (dir == XHDMIPHY_DIR_TX) {
+		if (inst->conf.tx_protocol == XHDMIPHY_PROT_HDMI ||
+		    inst->conf.tx_protocol == XHDMIPHY_PROT_HDMI21)
+			return true;
+	} else {
+		if (inst->conf.rx_protocol == XHDMIPHY_PROT_HDMI ||
+		    inst->conf.rx_protocol == XHDMIPHY_PROT_HDMI21)
+			return true;
+	}
+
+	return false;
+}
+
+bool xhdmiphy_is_using_qpll(struct xhdmiphy_dev *inst, enum chid chid,
+			    enum dir dir)
+{
+	enum pll_type pll_type;
+
+	pll_type = xhdmiphy_get_pll_type(inst, dir, chid);
+
+	if (pll_type == XHDMIPHY_PLL_QPLL || pll_type == XHDMIPHY_PLL_QPLL0 ||
+	    pll_type == XHDMIPHY_PLL_QPLL1)
+		return 1;
+
+	return 0;
+}
+
+bool xhdmiphy_is_cmn(enum chid chid)
+{
+	return (chid == XHDMIPHY_CHID_CMNA ||
+		(chid >= XHDMIPHY_CHID_CMN0 &&
+		chid <= XHDMIPHY_CHID_CMN1));
+}
+
+bool xhdmiphy_is_ch(enum chid chid)
+{
+	return (chid == XHDMIPHY_CHID_CHA ||
+		(chid >= XHDMIPHY_CHID_CH1 &&
+		chid <= XHDMIPHY_CHID_CH4));
+}
+
+/**
+ * xhdmiphy_ch2ids - This function will set the channel id's to correspond with
+ * the supplied channel ID based on the protocol. HDMI uses 3 channels; This ID
+ * translation is done to allow other functions to operate iteratively over
+ * multiple channels.
+ *
+ * @inst:	inst is a pointer to the xhdmiphy core instance
+ * @chid:	chid is the channel ID used to determine the indices
+ * @id0:	Id0 is a pointer to the start channel ID to set
+ * @id1:	Id1 is a pointer to the end channel ID to set
+ */
+void xhdmiphy_ch2ids(struct xhdmiphy_dev *inst, enum chid chid, u8 *id0,
+		     u8 *id1)
+{
+	u8 channels;
+
+	if (chid == XHDMIPHY_CHID_CHA) {
+		*id0 = XHDMIPHY_CHID_CH1;
+		if ((xhdmiphy_is_hdmi(inst, XHDMIPHY_DIR_TX)) ||
+		    (xhdmiphy_is_hdmi(inst, XHDMIPHY_DIR_RX))) {
+			if (inst->conf.tx_protocol == XHDMIPHY_PROT_HDMI21 ||
+			    inst->conf.rx_protocol == XHDMIPHY_PROT_HDMI21)
+				*id1 = XHDMIPHY_CHID_CH4;
+			else if ((inst->conf.tx_protocol == XHDMIPHY_PROT_HDMI) &&
+				 inst->conf.gt_as_tx_tmdsclk)
+				*id1 = XHDMIPHY_CHID_CH4;
+			else
+				*id1 = XHDMIPHY_CHID_CH3;
+
+		} else {
+			channels = ((inst->conf.tx_channels >=
+				inst->conf.rx_channels) ?
+				inst->conf.tx_channels :
+				inst->conf.rx_channels);
+
+			if (channels == 1)
+				*id1 = XHDMIPHY_CHID_CH1;
+			else if (channels == 2)
+				*id1 = XHDMIPHY_CHID_CH2;
+			else if (channels == 3)
+				*id1 = XHDMIPHY_CHID_CH3;
+			else
+				*id1 = XHDMIPHY_CHID_CH4;
+		}
+	} else if (chid == XHDMIPHY_CHID_CMNA) {
+		*id0 = XHDMIPHY_CHID_CMN0;
+		if (inst->conf.gt_type == XHDMIPHY_GTTYPE_GTHE4 ||
+		    inst->conf.gt_type == XHDMIPHY_GTTYPE_GTYE4)
+			*id1 = XHDMIPHY_CHID_CMN1;
+		else
+			*id1 = XHDMIPHY_CHID_CMN0;
+	} else {
+		*id0 = *id1 = chid;
+	}
+}
+
+/**
+ * xhdmiphy_pll_refclk_sel - configure the PLL reference clock selection for the
+ * specified channel(s). This is applied to both direction to the software
+ * configuration only.
+ *
+ * @inst:	inst is a pointer to the xhdmiphy core instance
+ * @chid:	chid is the channel ID to operate on
+ * @refclk_sel:	refclk_sel is the reference clock selection to configure
+ */
+void xhdmiphy_pll_refclk_sel(struct xhdmiphy_dev *inst, enum chid chid,
+			     enum refclk_sel refclk_sel)
+{
+	u8 id, id0, id1;
+
+	xhdmiphy_ch2ids(inst, chid, &id0, &id1);
+	for (id = id0; id <= id1; id++)
+		inst->quad.plls[XHDMIPHY_CH2IDX(id)].pll_refclk = refclk_sel;
+}
+
+/**
+ * xhdmiphy_sysclk_data_sel - configure the SYSCLKDATA reference clock
+ * selection for the direction. Same configuration applies to all channels in
+ * the quad. This is applied to the software configuration only.
+ *
+ * @inst:	inst is a pointer to the xhdmiphy core instance
+ * @dir:	dir is an indicator for TX or RX
+ * @sys_clk_data_sel: sys_clk_data_sel is reference clock selection to configure
+ */
+void xhdmiphy_sysclk_data_sel(struct xhdmiphy_dev *inst, enum dir dir,
+			      enum sysclk_data_sel sys_clk_data_sel)
+{
+	struct channel *ch_ptr;
+	u8 id, id0, id1;
+
+	xhdmiphy_ch2ids(inst, XHDMIPHY_CHID_CHA, &id0, &id1);
+
+	/* select in software - same for all channels */
+	for (id = id0; id <= id1; id++) {
+		ch_ptr = &inst->quad.plls[XHDMIPHY_CH2IDX(id)];
+		ch_ptr->data_refclk[dir] = sys_clk_data_sel;
+	}
+}
+
+/**
+ * xhdmiphy_sysclk_out_sel - configure the SYSCLKOUT reference clock selection
+ * for the direction. Same configuration applies to all channels in the quad.
+ * This is applied to the software configuration only.
+ *
+ * @inst:	inst is a pointer to the xhdmiphy core instance
+ * @dir:	dir is an indicator for TX or RX
+ * @sys_clkout_sel:	sys_clkout_sel is reference clock selection to configure
+ */
+void xhdmiphy_sysclk_out_sel(struct xhdmiphy_dev *inst, enum dir dir,
+			     enum sysclk_outsel sys_clkout_sel)
+{
+	struct channel *ch_ptr;
+	u8 id, id0, id1;
+
+	xhdmiphy_ch2ids(inst, XHDMIPHY_CHID_CHA, &id0, &id1);
+
+	/* select in software - same for all channels */
+	for (id = id0; id <= id1; id++) {
+		ch_ptr = &inst->quad.plls[XHDMIPHY_CH2IDX(id)];
+		ch_ptr->out_refclk[dir] = sys_clkout_sel;
+	}
+}
+
+void xhdmiphy_cfg_init(struct xhdmiphy_dev *inst)
+{
+	u8 sel;
+
+	if (inst->conf.gt_type == XHDMIPHY_GTHE4)
+		inst->gt_adp = &gthe4_conf;
+	else if (inst->conf.gt_type == XHDMIPHY_GTYE5)
+		inst->gt_adp = &gtye5_conf;
+
+	if (inst->conf.gt_type != XHDMIPHY_GTYE5) {
+		const enum sysclk_data_sel sysclk[7][2] = {
+			{0, XHDMIPHY_SYSCLKSELDATA_CPLL_OUTCLK},
+			{1, XHDMIPHY_SYSCLKSELDATA_QPLL0_OUTCLK},
+			{2, XHDMIPHY_SYSCLKSELDATA_QPLL1_OUTCLK},
+			{3, XHDMIPHY_SYSCLKSELDATA_QPLL_OUTCLK},
+			{4, XHDMIPHY_SYSCLKSELDATA_PLL0_OUTCLK},
+			{5, XHDMIPHY_SYSCLKSELDATA_PLL1_OUTCLK},
+			{6, XHDMIPHY_SYSCLKSELDATA_QPLL0_OUTCLK},
+		};
+
+		for (sel = 0; sel < 7; sel++) {
+			if (inst->conf.tx_pllclk_sel == sysclk[sel][0])
+				inst->conf.tx_pllclk_sel = sysclk[sel][1];
+			if (inst->conf.rx_pllclk_sel == sysclk[sel][0])
+				inst->conf.rx_pllclk_sel = sysclk[sel][1];
+		}
+
+		inst->conf.tx_refclk_sel = inst->conf.tx_refclk_sel +
+					   XHDMIPHY_PLL_REFCLKSEL_GTREFCLK0;
+		inst->conf.rx_refclk_sel = inst->conf.rx_refclk_sel +
+					   XHDMIPHY_PLL_REFCLKSEL_GTREFCLK0;
+		inst->conf.tx_frl_refclk_sel = inst->conf.tx_frl_refclk_sel +
+					       XHDMIPHY_PLL_REFCLKSEL_GTREFCLK0;
+		inst->conf.rx_frl_refclk_sel = inst->conf.rx_frl_refclk_sel +
+					       XHDMIPHY_PLL_REFCLKSEL_GTREFCLK0;
+		inst->conf.dru_refclk_sel = inst->conf.dru_refclk_sel +
+					    XHDMIPHY_PLL_REFCLKSEL_GTREFCLK0;
+	}
+}
+
+static unsigned int xhdmiphy_pll2sysclk_data(enum pll_type pll_sel)
+{
+	if (pll_sel == XHDMIPHY_PLL_CPLL)
+		return XHDMIPHY_SYSCLKSELDATA_CPLL_OUTCLK;
+	else if (pll_sel == XHDMIPHY_PLL_QPLL)
+		return XHDMIPHY_SYSCLKSELDATA_QPLL_OUTCLK;
+	else if (pll_sel == XHDMIPHY_PLL_QPLL0)
+		return XHDMIPHY_SYSCLKSELDATA_QPLL0_OUTCLK;
+
+	return XHDMIPHY_SYSCLKSELDATA_QPLL1_OUTCLK;
+}
+
+static unsigned short xhdmiphy_pll2sysclk_out(enum pll_type pll_sel)
+{
+	if (pll_sel == XHDMIPHY_PLL_CPLL)
+		return XHDMIPHY_SYSCLKSELOUT_CPLL_REFCLK;
+	else if (pll_sel == XHDMIPHY_PLL_QPLL)
+		return XHDMIPHY_SYSCLKSELOUT_QPLL_REFCLK;
+	else if (pll_sel == XHDMIPHY_PLL_QPLL0)
+		return XHDMIPHY_SYSCLKSELOUT_QPLL0_REFCLK;
+
+	return XHDMIPHY_SYSCLKSELOUT_QPLL1_REFCLK;
+}
+
+void xhdmiphy_write_refclksel(struct xhdmiphy_dev *inst)
+{
+	struct channel *ch_ptr;
+	enum gt_type gt_type = inst->conf.gt_type;
+	u32 reg_val = 0;
+
+	/* point to the first channel since settings apply to all channels */
+	ch_ptr = &inst->quad.ch1;
+
+	/* pll_refclk */
+	reg_val &= ~XHDMIPHY_REFCLKSEL_QPLL0_MASK;
+	reg_val = inst->quad.cmn0.pll_refclk;
+
+	reg_val &= ~XHDMIPHY_REFCLKSEL_CPLL_MASK;
+	reg_val |= (ch_ptr->cpll_refclk << XHDMIPHY_REFCLKSEL_CPLL_SHIFT);
+	if (gt_type == XHDMIPHY_GTTYPE_GTHE4 ||
+	    gt_type == XHDMIPHY_GTTYPE_GTYE4) {
+		reg_val &= ~XHDMIPHY_REFCLKSEL_QPLL1_MASK;
+		reg_val |= (inst->quad.cmn1.pll_refclk <<
+				XHDMIPHY_REFCLKSEL_QPLL1_SHIFT);
+	}
+
+	/* sys_clk_data_sel. PLLCLKSEL */
+	reg_val &= ~XHDMIPHY_REFCLKSEL_SYSCLKSEL_MASK;
+	/* TXSYSCLKSEL[0].TXPLLCLKSEL */
+	reg_val |= (ch_ptr->tx_data_refclk <<
+		    XHDMIPHY_TXSYSCLKSEL_DATA_SHIFT(gt_type)) &
+		   XHDMIPHY_TXSYSCLKSEL_DATA_MASK(gt_type);
+
+	/* RXSYSCLKSEL[0].RXPLLCLKSEL */
+	reg_val |= (ch_ptr->rx_data_refclk <<
+		    XHDMIPHY_RXSYSCLKSEL_DATA_SHIFT(gt_type)) &
+		   XHDMIPHY_RXSYSCLKSEL_DATA_MASK(gt_type);
+
+	/* sys_clkout_sel */
+	reg_val |= (ch_ptr->tx_outrefclk <<
+		    XHDMIPHY_TXSYSCLKSEL_OUT_SHIFT(gt_type)) &
+		   XHDMIPHY_TXSYSCLKSEL_OUT_MASK(gt_type);
+
+	reg_val |= (ch_ptr->rx_outrefclk <<
+		    XHDMIPHY_RXSYSCLKSEL_OUT_SHIFT(gt_type)) &
+		   XHDMIPHY_RXSYSCLKSEL_OUT_MASK(gt_type);
+
+	xhdmiphy_write(inst, XHDMIPHY_REFCLKSEL_REG, reg_val);
+}
+
+/**
+ * xhdmiphy_pll_init - This function will initialize the PLL selection for a
+ * given channel.
+ *
+ * @inst:		inst is a pointer to the xhdmiphy core instance
+ * @chid:		chid is the channel ID to operate on
+ * @qpll_refclk_sel:	qpll_refclk_sel is the QPLL reference clock selection
+ *			for the quad
+ * @cpll_refclk_sel:	cpll_refclk_sel is the CPLL reference clock selection
+ *			for the quad
+ * @txpll_sel:		txpll_sel is the reference clock selection for the
+ *			quad's TX PLL dividers
+ * @rxpll_sel:		rxpll_sel is the reference clock selection for the
+ *			quad's RX PLL dividers
+ */
+void xhdmiphy_pll_init(struct xhdmiphy_dev *inst, enum chid chid,
+		       enum refclk_sel qpll_refclk_sel,
+		       enum refclk_sel cpll_refclk_sel,
+		       enum pll_type txpll_sel, enum pll_type rxpll_sel)
+{
+	xhdmiphy_pll_refclk_sel(inst, XHDMIPHY_CHID_CMNA, qpll_refclk_sel);
+	xhdmiphy_pll_refclk_sel(inst, XHDMIPHY_CHID_CHA, cpll_refclk_sel);
+	xhdmiphy_sysclk_data_sel(inst, XHDMIPHY_DIR_TX,
+				 xhdmiphy_pll2sysclk_data(txpll_sel));
+	xhdmiphy_sysclk_data_sel(inst, XHDMIPHY_DIR_RX,
+				 xhdmiphy_pll2sysclk_data(rxpll_sel));
+	xhdmiphy_sysclk_out_sel(inst, XHDMIPHY_DIR_TX,
+				xhdmiphy_pll2sysclk_out(txpll_sel));
+	xhdmiphy_sysclk_out_sel(inst, XHDMIPHY_DIR_RX,
+				xhdmiphy_pll2sysclk_out(rxpll_sel));
+
+	xhdmiphy_write_refclksel(inst);
+}
+
+/**
+ * xhdmiphy_cfg_linerate - confure the channel's line rate. This is a software
+ * only configuration and this value is used in the PLL calculator.
+ *
+ * @inst:		inst is a pointer to the xhdmiphy core instance
+ * @chid:		chid is the channel ID to operate on
+ * @linkrate_freq:	LineRate is the line rate to configure software
+ */
+void xhdmiphy_cfg_linerate(struct xhdmiphy_dev *inst, enum chid chid,
+			   u64 linkrate_freq)
+{
+	u8 id, id0, id1;
+
+	xhdmiphy_ch2ids(inst, chid, &id0, &id1);
+	for (id = id0; id <= id1; id++)
+		inst->quad.plls[XHDMIPHY_CH2IDX(id)].linerate = linkrate_freq;
+}
+
+/**
+ * xhdmiphy_get_sysclk_datasel - obtain the current [RT]XSYSCLKSEL[0]
+ * configuration.
+ *
+ * @inst:	inst is a pointer to the xhdmiphy core instance.
+ * @dir:	dir is an indicator for TX or RX
+ * @chid:	chId is the channel ID which to operate on
+ *
+ * @return:	The current [RT]XSYSCLKSEL[0] selection
+ */
+static unsigned int xhdmiphy_get_sysclk_datasel(struct xhdmiphy_dev *inst,
+						enum dir dir, enum chid chid)
+{
+	u32 sel, reg_val, gt_type;
+
+	reg_val = xhdmiphy_read(inst, XHDMIPHY_REFCLKSEL_REG);
+	gt_type = inst->conf.gt_type;
+
+	/* synchronize software configuration to hardware */
+	if (dir == XHDMIPHY_DIR_TX) {
+		sel = reg_val & XHDMIPHY_TXSYSCLKSEL_DATA_MASK(gt_type);
+		sel >>= XHDMIPHY_TXSYSCLKSEL_DATA_SHIFT(gt_type);
+	} else {
+		sel = reg_val & XHDMIPHY_RXSYSCLKSEL_DATA_MASK(gt_type);
+		sel >>= XHDMIPHY_RXSYSCLKSEL_DATA_SHIFT(gt_type);
+	}
+
+	return sel;
+}
+
+/**
+ * xhdmiphy_get_sysclk_outsel - obtain the current [RT]XSYSCLKSEL[1]
+ * configuration.
+ *
+ * @inst:	inst is a pointer to the xhdmiphy core instance
+ * @dir:	dir is an indicator for TX or RX
+ * @chid:	chid is the channel ID which to operate on
+ *
+ * @return:	The current [RT]XSYSCLKSEL[1] selection
+ */
+static u32 xhdmiphy_get_sysclk_outsel(struct xhdmiphy_dev *inst,
+				      enum dir dir, enum chid chid)
+{
+	u32 sel, reg_val, gt_type;
+
+	reg_val = xhdmiphy_read(inst, XHDMIPHY_REFCLKSEL_REG);
+	gt_type = inst->conf.gt_type;
+
+	/* synchronize software configuration to hardware */
+	if (dir == XHDMIPHY_DIR_TX) {
+		sel = reg_val & XHDMIPHY_TXSYSCLKSEL_OUT_MASK(gt_type);
+		sel >>= XHDMIPHY_TXSYSCLKSEL_OUT_SHIFT(gt_type);
+	} else {
+		sel = reg_val & XHDMIPHY_RXSYSCLKSEL_OUT_MASK(gt_type);
+		sel >>= XHDMIPHY_RXSYSCLKSEL_OUT_SHIFT(gt_type);
+	}
+
+	return sel;
+}
+
+/**
+ * xhdmiphy_get_pll_type - obtain the channel's PLL reference clock selection.
+ *
+ * @inst:	inst is a pointer to the xhdmiphy core instance
+ * @dir:	dir is an indicator for TX or RX
+ * @chid:	chid is the channel ID which to operate on
+ *
+ * @return:	The PLL type being used by the channel
+ */
+u32 xhdmiphy_get_pll_type(struct xhdmiphy_dev *inst, enum dir dir,
+			  enum chid chid)
+{
+	enum pll_type pll_type;
+	enum sysclk_data_sel sysclk_data_sel;
+	enum sysclk_outsel sysclk_out_sel;
+
+	if (inst->conf.gt_type != XHDMIPHY_GTYE5) {
+		sysclk_data_sel = xhdmiphy_get_sysclk_datasel(inst, dir, chid);
+		sysclk_out_sel = xhdmiphy_get_sysclk_outsel(inst, dir, chid);
+
+		if (sysclk_data_sel == XHDMIPHY_SYSCLKSELDATA_CPLL_OUTCLK &&
+		    sysclk_out_sel == XHDMIPHY_SYSCLKSELOUT_CPLL_REFCLK)
+			pll_type = XHDMIPHY_PLL_CPLL;
+		else if ((sysclk_data_sel == XHDMIPHY_SYSCLKSELDATA_QPLL_OUTCLK) &&
+			 (sysclk_out_sel == XHDMIPHY_SYSCLKSELOUT_QPLL_REFCLK))
+			pll_type = XHDMIPHY_PLL_QPLL;
+		else if ((sysclk_data_sel == XHDMIPHY_SYSCLKSELDATA_QPLL0_OUTCLK) &&
+			 (sysclk_out_sel == XHDMIPHY_SYSCLKSELOUT_QPLL0_REFCLK))
+			pll_type = XHDMIPHY_PLL_QPLL0;
+		else if ((sysclk_data_sel == XHDMIPHY_SYSCLKSELDATA_QPLL1_OUTCLK) &&
+			 (sysclk_out_sel == XHDMIPHY_SYSCLKSELOUT_QPLL1_REFCLK))
+			pll_type = XHDMIPHY_PLL_QPLL1;
+		else
+			pll_type = XHDMIPHY_PLL_UNKNOWN;
+
+	} else {
+		if (dir == XHDMIPHY_DIR_TX)
+			pll_type = inst->conf.tx_pllclk_sel - 2;
+		else if (dir == XHDMIPHY_DIR_RX)
+			pll_type = inst->conf.rx_pllclk_sel - 2;
+		else
+			pll_type = XHDMIPHY_PLL_UNKNOWN;
+	}
+
+	return pll_type;
+}
+
+u64 xhdmiphy_get_linerate(struct xhdmiphy_dev *inst, enum chid chid)
+{
+	enum chid ch_id = chid;
+
+	if (chid == XHDMIPHY_CHID_CHA)
+		ch_id = XHDMIPHY_CHID_CH1;
+	else if (chid == XHDMIPHY_CHID_CMNA)
+		ch_id = XHDMIPHY_CHID_CMN0;
+
+	return inst->quad.plls[ch_id - XHDMIPHY_CHID_CH1].linerate;
+}
+
+/**
+ * xhdmiphy_set_tx_vs - This function will set the TX voltage swing value for
+ * a given channel.
+ *
+ * @inst:	inst is a pointer to the xhdmiphy core instance
+ * @chid:	chid is the channel ID to operate on
+ * @vs:		vs is the voltage swing value to write
+ */
+void xhdmiphy_set_tx_vs(struct xhdmiphy_dev *inst, enum chid chid, u8 vs)
+{
+	u32 reg_val, mask_val, reg_off;
+
+	if (chid == XHDMIPHY_CHID_CH1 || chid == XHDMIPHY_CHID_CH2)
+		reg_off = XHDMIPHY_TX_DRIVER_CH12_REG;
+	else
+		reg_off = XHDMIPHY_TX_DRIVER_CH34_REG;
+
+	reg_val = xhdmiphy_read(inst, reg_off);
+	mask_val = XHDMIPHY_TX_DRIVER_TXDIFFCTRL_MASK(chid);
+
+	reg_val &= ~mask_val;
+	reg_val |= ((vs & XHDMIPHY_TX_TXDIFFCTRL_MASK) <<
+		    XHDMIPHY_TX_DRIVER_TXDIFFCTRL_SHIFT(chid));
+	xhdmiphy_write(inst, reg_off, reg_val);
+
+	reg_val = xhdmiphy_read(inst, XHDMIPHY_TX_DRIVER_EXT_REG);
+	mask_val = XHDMIPHY_TX_DRIVER_EXT_TXDIFFCTRL_MASK(chid);
+
+	reg_val &= ~mask_val;
+	reg_val |= ((vs & XHDMIPHY_TX_EXT_TXDIFFCTRL_MASK) <<
+		    XHDMIPHY_TX_DRIVER_EXT_TXDIFFCTRL_SHIFT(chid));
+
+	xhdmiphy_write(inst, XHDMIPHY_TX_DRIVER_EXT_REG, reg_val);
+}
+
+/**
+ * xhdmiphy_set_tx_pe - This function will set the TX pre-emphasis value for
+ * a given channel.
+ *
+ * @inst:	inst is a pointer to the xhdmiphy core instance
+ * @chid:	chid is the channel ID to operate on
+ * @pe:		pe is the pre-emphasis value to write
+ */
+void xhdmiphy_set_tx_pe(struct xhdmiphy_dev *inst, enum chid chid, u8 pe)
+{
+	u32 reg_val, mask_val, reg_off;
+
+	if (chid == XHDMIPHY_CHID_CH1 || chid == XHDMIPHY_CHID_CH2)
+		reg_off = XHDMIPHY_TX_DRIVER_CH12_REG;
+	else
+		reg_off = XHDMIPHY_TX_DRIVER_CH34_REG;
+
+	reg_val = xhdmiphy_read(inst, reg_off);
+
+	mask_val = XHDMIPHY_TX_DRIVER_TXPRECURSOR_MASK(chid);
+	reg_val &= ~mask_val;
+	reg_val |= (pe << XHDMIPHY_TX_DRIVER_TXPRECURSOR_SHIFT(chid));
+	xhdmiphy_write(inst, reg_off, reg_val);
+}
+
+/**
+ * xhdmiphy_set_tx_pc - This function will set the TX post-curosr value for a
+ * given channel.
+ *
+ * @inst:	inst is a pointer to the xhdmiphy core instance
+ * @chid:	chid is the channel ID to operate on
+ * @pc:		pc is the post-curosr value to write
+ */
+void xhdmiphy_set_tx_pc(struct xhdmiphy_dev *inst, enum chid chid, u8 pc)
+{
+	u32 reg_val, mask_val, reg_off;
+
+	if (chid == XHDMIPHY_CHID_CH1 || chid == XHDMIPHY_CHID_CH2)
+		reg_off = XHDMIPHY_TX_DRIVER_CH12_REG;
+	else
+		reg_off = XHDMIPHY_TX_DRIVER_CH34_REG;
+
+	reg_val = xhdmiphy_read(inst, reg_off);
+
+	mask_val = XHDMIPHY_TX_DRIVER_TXPOSTCURSOR_MASK(chid);
+	reg_val &= ~mask_val;
+	reg_val |= (pc << XHDMIPHY_TX_DRIVER_TXPOSTCURSOR_SHIFT(chid));
+	xhdmiphy_write(inst, reg_off, reg_val);
+}
+
+void xhdmiphy_set_rxlpm(struct xhdmiphy_dev *inst, enum chid chid, enum dir dir,
+			u8 enable)
+{
+	u32 reg_val, mask_val;
+
+	reg_val = xhdmiphy_read(inst, XHDMIPHY_RX_EQ_CDR_REG);
+
+	if (chid == XHDMIPHY_CHID_CHA)
+		mask_val = XHDMIPHY_RX_CONTROL_RXLPMEN_ALL_MASK;
+	else
+		mask_val = XHDMIPHY_RX_CONTROL_RXLPMEN_MASK(chid);
+
+	xhdmiphy_set_clr(inst, XHDMIPHY_RX_EQ_CDR_REG, reg_val, mask_val,
+			 enable);
+}
+
+static unsigned int xhdmiphy_drp_access(struct xhdmiphy_dev *inst,
+					enum chid chid, enum dir dir, u16 addr,
+					u16 *val)
+{
+	u32 reg_off_ctrl, reg_off_sts, reg_val, err;
+
+	/* determine which DRP registers to use based on channel */
+	if (xhdmiphy_is_cmn(chid)) {
+		reg_off_ctrl = XHDMIPHY_DRP_CONTROL_COMMON_REG;
+		reg_off_sts = XHDMIPHY_DRP_STATUS_COMMON_REG;
+	} else if (XHDMIPHY_ISTXMMCM(chid)) {
+		reg_off_ctrl = XHDMIPHY_DRP_CONTROL_TXMMCM_REG;
+		reg_off_sts = XHDMIPHY_DRP_STATUS_TXMMCM_REG;
+	} else if (XHDMIPHY_ISRXMMCM(chid)) {
+		reg_off_ctrl = XHDMIPHY_DRP_CONTROL_RXMMCM_REG;
+		reg_off_sts = XHDMIPHY_DRP_STATUS_RXMMCM_REG;
+	} else {
+		reg_off_ctrl = XHDMIPHY_DRP_CONTROL_CH1_REG +
+			(4 * XHDMIPHY_CH2IDX(chid));
+		reg_off_sts = XHDMIPHY_DRP_STATUS_CH1_REG +
+			(4 * (XHDMIPHY_CH2IDX(chid)));
+	}
+
+	err = readl_poll_timeout(inst->phy_base + reg_off_sts, reg_val,
+				 !(reg_val & XHDMIPHY_DRP_STATUS_DRPBUSY_MASK),
+				 1, 100);
+	if (err == -ETIMEDOUT) {
+		dev_err(inst->dev, "drp busy timeout\n");
+		return err;
+	}
+
+	/* write the command to the channel's DRP */
+	reg_val = (addr & XHDMIPHY_DRP_CONTROL_DRPADDR_MASK);
+	reg_val |= XHDMIPHY_DRP_CONTROL_DRPEN_MASK;
+	if (dir == XHDMIPHY_DIR_TX) {
+		reg_val |= XHDMIPHY_DRP_CONTROL_DRPWE_MASK;
+		reg_val |= ((*val << XHDMIPHY_DRP_CONTROL_DRPDI_SHIFT) &
+			    XHDMIPHY_DRP_CONTROL_DRPDI_MASK);
+	}
+	xhdmiphy_write(inst, reg_off_ctrl, reg_val);
+
+	err = readl_poll_timeout(inst->phy_base + reg_off_sts, reg_val,
+				 (reg_val & XHDMIPHY_DRP_STATUS_DRPRDY_MASK),
+				 1, 100);
+	if (err == -ETIMEDOUT) {
+		dev_err(inst->dev, "drp ready timeout\n");
+		return err;
+	}
+
+	if (dir == XHDMIPHY_DIR_RX) {
+		reg_val &= XHDMIPHY_DRP_STATUS_DRPO_MASK;
+		*val = reg_val;
+	}
+
+	return 0;
+}
+
+/**
+ * xhdmiphy_drpwr - This function will initiate a write drp transaction. It is
+ * a wrapper around xhdmiphy_drp_access.
+ *
+ * @inst:	inst is a pointer to the xhdmiphy core instance
+ * @chid:	chid is the channel id on which to direct the DRP access
+ * @addr:	Addr is the DRP address to issue the DRP access to
+ * @val:	val is the value to write to the DRP address
+ *
+ * @return:	- 0 if the DRP access was successful
+ *		- -ETIMEDOUT otherwise, if the busy bit did not go low, or if
+ *			the ready bit did not go high
+ */
+u32 xhdmiphy_drpwr(struct xhdmiphy_dev *inst, enum chid chid, u16 addr, u16 val)
+{
+	return xhdmiphy_drp_access(inst, chid, XHDMIPHY_DIR_TX, addr, &val);
+}
+
+/**
+ * xhdmiphy_drprd - This function will initiate a read DRP transaction. It is
+ * a wrapper around xhdmiphy_drp_access.
+ *
+ * @inst:	inst is a pointer to the xhdmiphy core instance
+ * @chid:	chid is the channel ID on which to direct the DRP access
+ * @addr:	addr is the DRP address to issue the DRP access to
+ * @ret_val:	ret_val is the DRP read_value returned implicitly
+ *
+ * @return:	- 0 if the DRP access was successful
+ *		- -ETIMEDOUT otherwise, if the busy bit did not go low, or if
+ *		the ready bit did not go high
+ */
+u32 xhdmiphy_drprd(struct xhdmiphy_dev *inst, enum chid chid, u16 addr,
+		   u16 *ret_val)
+{
+	return xhdmiphy_drp_access(inst, chid, XHDMIPHY_DIR_RX, addr, ret_val);
+}
+
+void xhdmiphy_ibufds_en(struct xhdmiphy_dev *inst, enum dir dir, u8 enable)
+{
+	enum refclk_sel *type_ptr, *dru_typ_ptr, dru_type_dummy;
+	u32 reg_val, reg_addr, mask_val = 0;
+
+	dru_type_dummy = XHDMIPHY_PLL_REFCLKSEL_GTGREFCLK;
+	dru_typ_ptr = &dru_type_dummy;
+
+	if (inst->conf.gt_type != XHDMIPHY_GTYE5) {
+		if (dir == XHDMIPHY_DIR_TX) {
+			type_ptr = &inst->conf.tx_refclk_sel;
+		} else {
+			type_ptr = &inst->conf.rx_refclk_sel;
+			if (inst->conf.dru_present)
+				dru_typ_ptr = &inst->conf.dru_refclk_sel;
+		}
+
+		if ((*type_ptr == XHDMIPHY_PLL_REFCLKSEL_GTREFCLK0) ||
+		    (inst->conf.dru_present &&
+		     (*dru_typ_ptr == XHDMIPHY_PLL_REFCLKSEL_GTREFCLK0))) {
+			mask_val = XHDMIPHY_IBUFDS_GTXX_CTRL_GTREFCLK0_CEB_MASK;
+		} else if ((*type_ptr == XHDMIPHY_PLL_REFCLKSEL_GTREFCLK1) ||
+			   (inst->conf.dru_present &&
+			    (*dru_typ_ptr == XHDMIPHY_PLL_REFCLKSEL_GTREFCLK1))) {
+			mask_val = XHDMIPHY_IBUFDS_GTXX_CTRL_GTREFCLK1_CEB_MASK;
+		}
+	}
+
+	if (dir == XHDMIPHY_DIR_TX)
+		reg_addr = XHDMIPHY_MISC_TXUSRCLK_REG;
+	else
+		reg_addr = XHDMIPHY_MISC_RXUSRCLK_REG;
+
+	mask_val = XHDMIPHY_MISC_XXUSRCLK_REFCLK_CEB_MASK;
+	reg_val = xhdmiphy_read(inst, reg_addr);
+
+	if (inst->conf.gt_type != XHDMIPHY_GTYE5)
+		xhdmiphy_set_clr(inst, reg_addr, reg_val, mask_val, !enable);
+	else
+		xhdmiphy_set_clr(inst, reg_addr, reg_val, mask_val, enable);
+}
+
+/**
+ * xhdmiphy_clkout1_obuftds_en - This function enables the tx or rx clkout1
+ * obuftds peripheral.
+ *
+ * @inst:	inst is a pointer to the xhdmiphy core instance
+ * @dir:	dir is an indicator for TX or RX
+ * @enable:	enable specifies true/false value to either enable or disable
+ *		the obuftds, respectively
+ */
+void xhdmiphy_clkout1_obuftds_en(struct xhdmiphy_dev *inst, enum dir dir,
+				 u8 enable)
+{
+	u32 reg_val, reg_off, mask;
+
+	if (dir == XHDMIPHY_DIR_TX)
+		reg_off = XHDMIPHY_MISC_TXUSRCLK_REG;
+	else
+		reg_off = XHDMIPHY_MISC_RXUSRCLK_REG;
+
+	/* read XXUSRCLK MISC register */
+	reg_val = xhdmiphy_read(inst, reg_off);
+	mask = XHDMIPHY_MISC_XXUSRCLK_CKOUT1_OEN_MASK;
+	/* write new value to XXUSRCLK MISC register */
+	xhdmiphy_set_clr(inst, reg_off, reg_val, mask, enable);
+}
+
+/**
+ * xhdmiphy_get_quad_refclk - obtain the current reference clock frequency for
+ * the quad based on the reference clock type.
+ *
+ * @inst:	inst is a pointer to the xhdmiphy core instance
+ * @refclk_type:	refclk_type is the type to obtain the clock selection for
+ *
+ * @return:	The current reference clock frequency for the quad for the
+ *		specified type selection
+ */
+u32 xhdmiphy_get_quad_refclk(struct xhdmiphy_dev *inst,
+			     enum refclk_sel refclk_type)
+{
+	u32 freq;
+	u8 index = refclk_type - XHDMIPHY_PLL_REFCLKSEL_GTREFCLK0;
+
+	freq = (refclk_type > XHDMIPHY_PLL_REFCLKSEL_GTGREFCLK) ? 0 :
+		inst->quad.refclk[index];
+
+	return freq;
+}
+
+/**
+ * xhdmiphy_set_gpi - This function will set the GPI ports to the GT Wizard
+ *
+ * @inst:	inst is a pointer to the xhdmiphy core instance
+ * @chid:	chid is the channel ID to operate on
+ * @dir:	dir is an indicator for TX or RX
+ * @set:	set Set=true; Clear=false
+ */
+void xhdmiphy_set_gpi(struct xhdmiphy_dev *inst, enum chid chid, enum dir dir,
+		      u8 set)
+{
+	u32 reg_val, mask_val = 0;
+	u8 id, id0, id1;
+
+	/* read GPI register */
+	reg_val = xhdmiphy_read(inst, XHDMIPHY_GT_DBG_GPI_REG);
+
+	xhdmiphy_ch2ids(inst, chid, &id0, &id1);
+	for (id = id0; id <= id1; id++) {
+		if (dir == XHDMIPHY_DIR_TX)
+			mask_val |= XHDMIPHY_TX_GPI_MASK(id);
+		else
+			mask_val |= XHDMIPHY_RX_GPI_MASK(id);
+	}
+
+	xhdmiphy_set_clr(inst, XHDMIPHY_GT_DBG_GPI_REG, reg_val, mask_val, set);
+}
+
+/**
+ * xhdmiphy_get_gpo - This function will get the GPO ports value from the GT
+ * Wizard
+ *
+ * @inst:	inst is a pointer to the xhdmiphy core instance
+ * @chid:	chid is the channel ID to operate on
+ * @dir:	dir is an indicator for TX or RX
+ *
+ * @return:	- This will return the GPO port value.
+ */
+u8 xhdmiphy_get_gpo(struct xhdmiphy_dev *inst, enum chid chid, enum dir dir)
+{
+	u32 reg_val;
+
+	/* Read GPI register */
+	reg_val = xhdmiphy_read(inst, XHDMIPHY_GT_DBG_GPO_REG);
+
+	if (dir == XHDMIPHY_DIR_TX) {
+		return ((reg_val &
+			XHDMIPHY_TX_GPO_MASK_ALL(inst->conf.tx_channels)) >>
+			XHDMIPHY_TX_GPO_SHIFT);
+	}
+
+	return ((reg_val &
+		XHDMIPHY_RX_GPO_MASK_ALL(inst->conf.rx_channels)) >>
+		XHDMIPHY_RX_GPO_SHIFT);
+}
+
+/**
+ * xhdmiphy_set_bufgtdiv - This function obtains the divider value of the
+ * BUFG_GT peripheral.
+ *
+ * @inst:	inst is a pointer to the xhdmiphy core instance
+ * @dir:	dir is an indicator for TX or RX
+ * @div:	div 3-bit divider value
+ */
+void xhdmiphy_set_bufgtdiv(struct xhdmiphy_dev *inst, enum dir dir, u8 div)
+{
+	u32 reg_val, reg_off;
+
+	if (div == 0)
+		div = 1;
+	else
+		div = div - 1;
+
+	if (dir == XHDMIPHY_DIR_TX)
+		reg_off = XHDMIPHY_BUFGGT_TXUSRCLK_REG;
+	else
+		reg_off = XHDMIPHY_BUFGGT_RXUSRCLK_REG;
+
+	/* read BUFG_GT register */
+	reg_val = xhdmiphy_read(inst, reg_off);
+	reg_val &= ~XHDMIPHY_BUFGGT_XXUSRCLK_DIV_MASK;
+
+	/* shift divider value to correct position */
+	div <<= XHDMIPHY_BUFGGT_XXUSRCLK_DIV_SHIFT;
+	div &= XHDMIPHY_BUFGGT_XXUSRCLK_DIV_MASK;
+	reg_val |= div;
+
+	/* write new value to BUFG_GT ctrl register */
+	xhdmiphy_write(inst, reg_off, reg_val);
+}
+
+/**
+ * xhdmiphy_powerdown_gtpll - This function will power down the specified GT PLL.
+ *
+ * @inst:	inst is a pointer to the xhdmiphy core instance
+ * @chid:	chid is the channel ID to power down the PLL for
+ * @hold:	hold is an indicator whether to "hold" the power down if set
+ *		to 1. If set to 0: power down, then power back up
+ */
+void xhdmiphy_powerdown_gtpll(struct xhdmiphy_dev *inst, enum chid chid, u8 hold)
+{
+	u32 mask_val = 0, reg_val;
+	u8 id, id0, id1;
+
+	if (xhdmiphy_is_ch(chid))
+		xhdmiphy_ch2ids(inst, chid, &id0, &id1);
+	else
+		xhdmiphy_ch2ids(inst, XHDMIPHY_CHID_CHA, &id0, &id1);
+
+	for (id = id0; id <= id1; id++) {
+		if (chid == XHDMIPHY_CHID_CMN0) {
+			mask_val |= XHDMIPHY_POWERDOWN_CONTROL_QPLL0PD_MASK(id);
+		} else if (chid == XHDMIPHY_CHID_CMN1) {
+			mask_val |= XHDMIPHY_POWERDOWN_CONTROL_QPLL1PD_MASK(id);
+		} else if (chid == XHDMIPHY_CHID_CMNA) {
+			mask_val |= XHDMIPHY_POWERDOWN_CONTROL_QPLL0PD_MASK(id) |
+				   XHDMIPHY_POWERDOWN_CONTROL_QPLL1PD_MASK(id);
+		} else {
+			mask_val |= XHDMIPHY_POWERDOWN_CONTROL_CPLLPD_MASK(id);
+		}
+	}
+
+	reg_val = xhdmiphy_read(inst, XHDMIPHY_POWERDOWN_CONTROL_REG);
+	reg_val |= mask_val;
+	xhdmiphy_write(inst, XHDMIPHY_POWERDOWN_CONTROL_REG, reg_val);
+
+	if (!hold) {
+		reg_val &= ~mask_val;
+		xhdmiphy_write(inst, XHDMIPHY_POWERDOWN_CONTROL_REG, reg_val);
+	}
+}
+
+/**
+ * xhdmiphy_mmcm_reset - This function will reset the mixed-mode clock manager
+ * (MMCM) core.
+ *
+ * @inst:	inst is a pointer to the xhdmiphy core instance
+ * @dir:	dir is an indicator for TX or RX
+ * @hold:	Hold is an indicator whether to "hold" the reset if set to 1
+ *		If set to 0: reset, then enable
+ */
+void xhdmiphy_mmcm_reset(struct xhdmiphy_dev *inst, enum dir dir, u8 hold)
+{
+	u32 reg_off, reg_val;
+
+	if (dir == XHDMIPHY_DIR_TX)
+		reg_off = XHDMIPHY_MMCM_TXUSRCLK_CTRL_REG;
+	else
+		reg_off = XHDMIPHY_MMCM_RXUSRCLK_CTRL_REG;
+
+	/* assert reset */
+	reg_val = xhdmiphy_read(inst, reg_off);
+	reg_val |= XHDMIPHY_MMCM_USRCLK_CTRL_RST_MASK;
+	xhdmiphy_write(inst, reg_off, reg_val);
+
+	if (!hold) {
+		/* de-assert reset */
+		reg_val &= ~XHDMIPHY_MMCM_USRCLK_CTRL_RST_MASK;
+		xhdmiphy_write(inst, reg_off, reg_val);
+	}
+}
+
+u64 xhdmiphy_get_pll_vco_freq(struct xhdmiphy_dev *inst, enum chid chid,
+			      enum dir dir)
+{
+	struct channel *pll_ptr = &inst->quad.plls[XHDMIPHY_CH2IDX(chid)];
+	struct pll_param pll_prm;
+	u64 pll_vco_rate, pll_refclk;
+	u32 qrefclk;
+
+	pll_prm = inst->quad.plls[XHDMIPHY_CH2IDX(chid)].pll_param;
+	qrefclk = xhdmiphy_get_quad_refclk(inst, pll_ptr->pll_refclk);
+
+	if (dir == XHDMIPHY_DIR_TX) {
+		if (xhdmiphy_is_hdmi(inst, XHDMIPHY_DIR_TX))
+			pll_refclk = inst->tx_refclk_hz;
+		else
+			pll_refclk = qrefclk;
+	} else {
+		if (xhdmiphy_is_hdmi(inst, XHDMIPHY_DIR_RX)) {
+			if (inst->rx_dru_enabled)
+				pll_refclk = xhdmiphy_get_dru_refclk(inst);
+			else
+				pll_refclk = inst->rx_refclk_hz;
+		} else {
+			pll_refclk = qrefclk;
+		}
+	}
+
+	pll_vco_rate = (u64)(pll_refclk * pll_prm.n1fb_div * pll_prm.n2fb_div) /
+			     pll_prm.m_refclk_div;
+
+	return pll_vco_rate;
+}
+
+/**
+ * xhdmiphy_pll_cal - This function will try to find the necessary PLL divisor
+ * values to produce the configured line rate given the specified PLL input
+ * frequency.
+ *
+ * @inst:	inst is a pointer to the xhdmiphy core instance
+ * @chid:	chid is the channel ID to calculate the PLL values for
+ * @dir:	dir is an indicator for TX or RX
+ * @pll_clkin_freq:
+ *		pll_clkin_freq is the PLL input frequency on which to base the
+ *		calculations on. A value of 0 indicates to use the currently
+ *		configured quad PLL reference clock. A non-zero value indicates
+ *		to ignore what is currently configured in SW, and use a custom
+ *		frequency instead.
+ *
+ * @return:	- 0 if valid PLL values were found to satisfy the constraints
+ *		- 1 otherwise
+ */
+u32 xhdmiphy_pll_cal(struct xhdmiphy_dev *inst, enum chid chid, enum dir dir,
+		     u32 pll_clkin_freq)
+{
+	const struct gtpll_divs *gtpll_divs;
+	struct channel *pll_ptr = &inst->quad.plls[XHDMIPHY_CH2IDX(chid)];
+	u64 pllclk_out_freq, linerate_freq;
+	u64 pll_clkin_freqin = pll_clkin_freq;
+	u32 status;
+	const u8 *m, *n1, *n2, *d;
+	u8 id, id0, id1;
+
+	if (!pll_clkin_freqin)
+		pll_clkin_freqin =
+			xhdmiphy_get_quad_refclk(inst, pll_ptr->pll_refclk);
+
+	/* select PLL value table offsets */
+	if (xhdmiphy_is_ch(chid))
+		gtpll_divs = &inst->gt_adp->cpll_divs;
+	else
+		gtpll_divs = &inst->gt_adp->qpll_divs;
+
+	for (n2 = gtpll_divs->n2; *n2 != 0; n2++) {
+		for (n1 = gtpll_divs->n1; *n1 != 0; n1++) {
+			for (m = gtpll_divs->m; *m != 0; m++) {
+				pllclk_out_freq = (pll_clkin_freqin * *n1 * *n2) / *m;
+				/* Test if the calculated PLL clock is in the VCO range */
+				status = xhdmiphy_check_pll_oprange(inst, chid,
+								    pllclk_out_freq);
+				if (status != 0)
+					continue;
+
+				if ((xhdmiphy_is_ch(chid)))
+					pllclk_out_freq *= 2;
+
+				/* Apply TX/RX divisor */
+				for (d = gtpll_divs->d; *d != 0; d++) {
+					linerate_freq = pllclk_out_freq / *d;
+					if (linerate_freq == pll_ptr->linerate)
+						goto calc_done;
+				}
+			}
+		}
+	}
+	/* Calculation failed, don't change divisor settings */
+	return 1;
+
+calc_done:
+	/* Found the multiplier and divisor values for requested line rate */
+	pll_ptr->pll_param.m_refclk_div = *m;
+	pll_ptr->pll_param.nfb_div = *n1;
+	pll_ptr->pll_param.n2fb_div = *n2;
+	pll_ptr->pll_param.is_lowerband = 1;
+
+	if (xhdmiphy_is_cmn(chid)) {
+		/* Same divisor value for all channels if using a QPLL */
+		chid = XHDMIPHY_CHID_CHA;
+	}
+
+	xhdmiphy_ch2ids(inst, chid, &id0, &id1);
+	for (id = id0; id <= id1; id++) {
+		inst->quad.plls[XHDMIPHY_CH2IDX(id)].outdiv[dir] = *d;
+		if (dir == XHDMIPHY_DIR_RX)
+			xhdmiphy_cfg_set_cdr(inst, (enum chid)id);
+	}
+
+	return 0;
+}
diff --git a/drivers/phy/xilinx/xhdmiphy_gt_helper.c b/drivers/phy/xilinx/xhdmiphy_gt_helper.c
new file mode 100644
index 000000000..c3e96f33c
--- /dev/null
+++ b/drivers/phy/xilinx/xhdmiphy_gt_helper.c
@@ -0,0 +1,1398 @@
+// SPDX-License-Identifier: GPL-2.0-only
+
+#include <linux/device.h>
+#include "xhdmiphy.h"
+
+static const u8 gthe4_cpll_divs_m[] = {1, 2, 0};
+static const u8 gthe4_cpll_divs_n1[] = {4, 5, 0};
+static const u8 gthe4_cpll_divs_n2[] = {1, 2, 3, 4, 5, 8, 0};
+static const u8 gthe4_cpll_divs_d[] = {1, 2, 4, 8, 0};
+
+static const u8 gthe4_qpll_divs_m[] = {1, 2, 3, 4, 0};
+static const u8 gthe4_qpll_divs_n1[] = {16, 20, 25, 30, 32, 40, 60, 64, 66, 75,
+					80, 84, 90, 96, 100, 112, 120, 125, 150,
+					160, 0};
+static const u8 gthe4_qpll_divs_n2[] = {1, 0};
+static const u8 gthe4_qpll_divs_d[] = {1, 2, 4, 8, 16, 0};
+
+/**
+ * xhdmiphy_gt_mst_rst - This function will set the (TX|RX) MSTRESET port of
+ * the GT
+ *
+ * @inst:	inst is a pointer to the xhdmiphy core instance
+ * @chid:	chid is the channel ID to operate on
+ * @dir:	dir is an indicator for TX or RX
+ * @rst:	rst set=true; Clear=false
+ */
+static void xhdmiphy_gt_mst_rst(struct xhdmiphy_dev *inst, enum chid chid,
+				enum dir dir, u8 rst)
+{
+	u32 reg_off, reg_val, mask_val = 0;
+	u8 id, id0, id1;
+
+	xhdmiphy_ch2ids(inst, chid, &id0, &id1);
+
+	for (id = id0; id <= id1; id++)
+		mask_val |=  XHDMIPHY_TXRX_MSTRESET_MASK(id);
+
+	if (dir == XHDMIPHY_DIR_TX)
+		reg_off = XHDMIPHY_TX_INIT_REG;
+	else
+		reg_off = XHDMIPHY_RX_INIT_REG;
+
+	reg_val = xhdmiphy_read(inst, reg_off);
+
+	xhdmiphy_set_clr(inst, reg_off, reg_val, mask_val, rst);
+}
+
+ /**
+  * This function will translate the configured QPLL's M or CPLL's M or N2
+  * values to DRP encoding.
+  *
+  * @attr_enc:	attribute to encode
+  *
+  * @return:	encoded value
+  *
+  * @note: For more details about DRP encoding values , refer GT user guide
+  */
+static u8 xhdmiphy_drpenc_qpll_mcpll_mn2(u8 attr_enc)
+{
+	u8 drp_enc;
+
+	switch (attr_enc) {
+	case 1:
+		drp_enc = 16;
+		break;
+	case 6:
+		drp_enc = 5;
+		break;
+	case 10:
+		drp_enc = 7;
+		break;
+	case 12:
+		drp_enc = 13;
+		break;
+	case 20:
+		drp_enc = 15;
+		break;
+	case 2: case 3: case 4:
+	case 5: case 8: case 16:
+		drp_enc = (attr_enc - 2);
+		break;
+	default:
+		drp_enc = 0xf;
+	break;
+	}
+
+	return drp_enc;
+}
+
+/* This function translates the configured CPLL's N1 value to DRP encoding */
+static u8 xhdmiphy_drpenc_cpll_n1(u8 attr_enc)
+{
+	return (attr_enc - 4) & 0x1;
+}
+
+/* This function translates the configured QPLL's N value to DRP encoding */
+static u16 xhdmiphy_drpenc_qpll_n(u8 attr_enc)
+{
+	u16 drp_enc;
+
+	if (attr_enc >= 16 && attr_enc <= 160)
+		drp_enc = attr_enc - 2;
+	else
+		drp_enc = 0xff;
+
+	return drp_enc;
+}
+
+/* This function translates the configured CPLL's D values to DRP encoding */
+
+static u8 xhdmiphy_drpenc_cpll_txrx_d(u8 attr_enc)
+{
+	u8 drp_enc;
+
+	switch (attr_enc) {
+	case 1:
+		drp_enc = 0;
+		break;
+	case 2:
+		drp_enc = 1;
+		break;
+	case 4:
+		drp_enc = 2;
+		break;
+	case 8:
+		drp_enc = 3;
+		break;
+	case 16:
+		drp_enc = 4;
+		break;
+	default:
+		drp_enc = 0x4;
+		break;
+	}
+
+	return drp_enc;
+}
+
+/* This function translates the configured Rx data width to DRP encoding */
+static u8 xhdmiphy_drpenc_datawidth(u8 attr_enc)
+{
+	u8 drp_enc;
+
+	switch (attr_enc) {
+	case 16:
+		drp_enc = 2;
+		break;
+	case 20:
+		drp_enc = 3;
+		break;
+	case 32:
+		drp_enc = 4;
+		break;
+	case 40:
+		drp_enc = 5;
+		break;
+	case 64:
+		drp_enc = 6;
+		break;
+	case 80:
+		drp_enc = 7;
+		break;
+	case 128:
+		drp_enc = 8;
+		break;
+	case 160:
+		drp_enc = 9;
+		break;
+	default:
+		drp_enc = 0xf;
+		break;
+	}
+
+	return drp_enc;
+}
+
+/* This function translates the configured RXINTDATAWIDTH to DRP encoding */
+static u8 xhdmiphy_drpenc_int_datawidth(u8 attr_enc)
+{
+	u8 drp_enc;
+
+	switch (attr_enc) {
+	case 2:
+		drp_enc = 0;
+		break;
+	case 4:
+		drp_enc = 1;
+		break;
+	default:
+		drp_enc = 2;
+		break;
+	}
+
+	return drp_enc;
+}
+
+/* This function will translate the configured CLK25 to DRP encoding */
+static u16 xhdmiphy_drpenc_clk25(u32 refclk_hz)
+{
+	u16 drp_enc;
+	u32 refclk_mhz = refclk_hz / 1000000;
+
+	drp_enc = ((refclk_mhz / 25) +
+		   (((refclk_mhz % 25) > 0) ? 1 : 0)) - 1;
+
+	return (drp_enc & 0x1f);
+}
+
+/**
+ * xhdmiphy_cpll_cal_counttol - This function configures the cpll Calibration
+ * period and the count tolerance registers.
+ * cpll_cal_period = ((fPLLClkin * N1 * N2) / (20 * M)) /
+ *                       (16000 / (4 * fFreeRunClk))
+ * cpll_cal_tol = cpll_cal_period * 0.10
+ *
+ * @inst:		inst is a pointer to the xhdmiphy core instance
+ * @chid:		chid is the channel ID to operate on
+ * @dir:		dir is an indicator for TX or RX
+ * @freerun_clk:	freerun_clk is the freerunning clock freq in Hz
+ *			driving the GT Wiz instance
+ *
+ * @return:		returns 0 on successful configuration or else returns 1
+ */
+static bool xhdmiphy_cpll_cal_counttol(struct xhdmiphy_dev *inst, enum chid chid,
+				       enum dir dir, u32 freerun_clk)
+{
+	u64 cpll_cal_period;
+	u64 cpll_cal_tol;
+	u64 pll_vco_freq;
+	u32 reg_val;
+
+	if (!xhdmiphy_is_ch(chid))
+		return false;
+
+	pll_vco_freq = xhdmiphy_get_pll_vco_freq(inst, chid, dir);
+	cpll_cal_period = pll_vco_freq * 200 / (u64)freerun_clk;
+	if (cpll_cal_period % 10)
+		cpll_cal_tol = (cpll_cal_period / 10) + 1;
+	else
+		cpll_cal_tol = cpll_cal_period / 10;
+
+	/* read cpll calibration period value */
+	reg_val = xhdmiphy_read(inst, XHDMIPHY_CPLL_CAL_PERIOD_REG) &
+				~XHDMIPHY_CPLL_CAL_PERIOD_MASK;
+	reg_val |= cpll_cal_period & XHDMIPHY_CPLL_CAL_PERIOD_MASK;
+
+	/* write new cpll calibration period value */
+	xhdmiphy_write(inst, XHDMIPHY_CPLL_CAL_PERIOD_REG, reg_val);
+	/* read cpll calibration tolerance value */
+	reg_val = xhdmiphy_read(inst, XHDMIPHY_CPLL_CAL_TOL_REG) &
+				~XHDMIPHY_CPLL_CAL_TOL_MASK;
+
+	reg_val |= cpll_cal_tol & XHDMIPHY_CPLL_CAL_TOL_MASK;
+	xhdmiphy_write(inst, XHDMIPHY_CPLL_CAL_TOL_REG, reg_val);
+
+	return false;
+}
+
+/**
+ * xhdmiphy_m_drpenc - This function will translate the configured M value to
+ * DRP encoding.
+ *
+ * @inst:	inst is a pointer to the xhdmiphy core instance
+ * @chid:	chid is the channel ID to operate on
+ *
+ * @return:	The DRP encoding for M
+ */
+static u8 xhdmiphy_m_drpenc(struct xhdmiphy_dev *inst, enum chid chid)
+{
+	struct pll_param pll_prm;
+	u8 m_refclk_div;
+
+	pll_prm = inst->quad.plls[XHDMIPHY_CH2IDX(chid)].pll_param;
+
+	if (chid >= XHDMIPHY_CHID_CH1 && chid <= XHDMIPHY_CHID_CH4)
+		m_refclk_div = pll_prm.m_refclk_div;
+	else if (chid == XHDMIPHY_CHID_CMN0 || chid == XHDMIPHY_CHID_CMN1)
+		m_refclk_div = pll_prm.m_refclk_div;
+	else
+		m_refclk_div = 0;
+
+	return xhdmiphy_drpenc_qpll_mcpll_mn2(m_refclk_div);
+}
+
+/**
+ * xhdmiphy_gthe4_set_cdr - This function will set the clock and data recovery
+ * (CDR) values for a given channel.
+ *
+ * @inst:	inst is a pointer to the xhdmiphy core instance
+ * @chid:	chid is the channel ID to operate on
+ *
+ * @return:	- 0 if the configuration was successful
+ *		- 1 otherwise
+ */
+static bool xhdmiphy_gthe4_set_cdr(struct xhdmiphy_dev *inst, enum chid chid)
+{
+	struct channel *ch_ptr;
+	u8 rx_outdiv;
+
+	if (chid < XHDMIPHY_CHID_CH1 || chid > XHDMIPHY_CHID_CH4)
+		return true;
+
+	ch_ptr = &inst->quad.plls[XHDMIPHY_CH2IDX(chid)];
+	rx_outdiv = ch_ptr->rx_outdiv;
+
+	ch_ptr->pll_param.cdr[0] = XHDMIPHY_RXCDR_CFG_WORD0;
+	ch_ptr->pll_param.cdr[1] = XHDMIPHY_RXCDR_CFG_WORD1;
+	ch_ptr->pll_param.cdr[3] = XHDMIPHY_RXCDR_CFG_WORD3;
+	ch_ptr->pll_param.cdr[4] = XHDMIPHY_RXCDR_CFG_WORD4;
+
+	if (xhdmiphy_is_hdmi(inst, XHDMIPHY_DIR_RX)) {
+		/*
+		 * rx_outdiv = 1 => cdr[2] = 0x0262
+		 * rx_outdiv = 2 => cdr[2] = 0x0252
+		 * rx_outdiv = 4 => cdr[2] = 0x0242
+		 * rx_outdiv = 8 => cdr[2] = 0x0232
+		 * rx_outdiv = 16 => cdr[2] = 0x0222
+		 */
+		ch_ptr->pll_param.cdr[2] = XHDMIPHY_RXCDR_CFG_WORD2;
+
+		while (rx_outdiv >>= 1)
+			ch_ptr->pll_param.cdr[2] -=
+						XHDMIPHY_RXCDR_CFG_WORD2_RXDIV;
+
+	} else {
+		return true;
+	}
+
+	return false;
+}
+
+/**
+ * xhdmiphy_gthe4_check_pll_oprange - This function will check if a given PLL
+ * output frequency is within the operating range of the PLL for the GT type.
+ *
+ * @inst:		inst is a pointer to the xhdmiphy core instance
+ * @chid:		chid is the channel ID to operate on
+ * @pll_clkout_freq:	pll_clkout_freq is the frequency to check
+ *
+ * @return:		- 0 if the frequency resides within the PLL's range
+ *			- 1 otherwise
+ */
+static bool xhdmiphy_gthe4_check_pll_oprange(struct xhdmiphy_dev *inst, enum chid chid,
+					     u64 pll_clkout_freq)
+{
+	if ((chid == XHDMIPHY_CHID_CMN0 &&
+	     pll_clkout_freq >= XHDMIPHY_QPLL0_MIN &&
+	     pll_clkout_freq <= XHDMIPHY_QPLL0_MAX) ||
+	    (chid == XHDMIPHY_CHID_CMN1 &&
+	     pll_clkout_freq >= XHDMIPHY_QPLL1_MIN &&
+	     pll_clkout_freq <= XHDMIPHY_QPLL1_MAX) ||
+	    (chid >= XHDMIPHY_CHID_CH1 &&
+	     chid <= XHDMIPHY_CHID_CH4 &&
+	     pll_clkout_freq >= XHDMIPHY_CPLL_MIN &&
+	     pll_clkout_freq <= XHDMIPHY_CPLL_MAX)) {
+		return false;
+	}
+
+	return true;
+}
+
+/**
+ * xhdmiphy_d_drpenc - This function will translate the configured D value to
+ * DRP encoding.
+ *
+ * @inst:	inst is a pointer to the xhdmiphy core instance
+ * @chid:	chid is the channel ID to operate on
+ * @dir:	dir is an indicator for RX or TX
+ *
+ * @return:	The DRP encoding for D
+ */
+static u8 xhdmiphy_d_drpenc(struct xhdmiphy_dev *inst, enum chid chid,
+			    enum dir dir)
+{
+	u8 out_div;
+
+	out_div = inst->quad.plls[XHDMIPHY_CH2IDX(chid)].outdiv[dir];
+
+	return xhdmiphy_drpenc_cpll_txrx_d(out_div);
+}
+
+/**
+ * xhdmiphy_gthe4_outdiv_chreconf - This function will set the output divider
+ * logic for a given channel.
+ *
+ * @inst:	inst is a pointer to the xhdmiphy core instance
+ * @chid:	chid is the channel ID to operate on
+ * @dir:	dir is an indicator for RX or TX
+ *
+ * @return:	- 0 if the configuration was successful
+ *		- 1 otherwise
+ */
+static u32 xhdmiphy_gthe4_outdiv_chreconf(struct xhdmiphy_dev *inst,
+					  enum chid chid, enum dir dir)
+{
+	u32 status = 0;
+	u16 drp_val, write_val;
+
+	if (dir == XHDMIPHY_DIR_RX) {
+		status |= xhdmiphy_drprd(inst, chid, XDRP_GTHE4_CHN_REG_0063,
+					 &drp_val);
+		/* Mask out RXOUT_DIV */
+		drp_val &= ~XDRP_GTHE4_CHN_REG_0063_RXOUT_DIV_MASK;
+		/* Set RXOUT_DIV */
+		write_val = (xhdmiphy_d_drpenc(inst, chid, XHDMIPHY_DIR_RX) &
+			    XDRP_GTHE4_CHN_REG_0063_FLD_RXOUT_DIV_MASK);
+		drp_val |= write_val;
+		status |= xhdmiphy_drpwr(inst, chid, XDRP_GTHE4_CHN_REG_0063,
+					 drp_val);
+	} else {
+		status |= xhdmiphy_drprd(inst, chid, XDRP_GTHE4_CHN_REG_007C,
+					 &drp_val);
+		/* mask out TXOUT_DIV */
+		drp_val &= ~XDRP_GTHE4_CHN_REG_007C_TXOUT_DIV_MASK;
+		/* Set TXOUT_DIV */
+		write_val = (xhdmiphy_d_drpenc(inst, chid, XHDMIPHY_DIR_TX) &
+			     XDRP_GTHE4_CHN_REG_007C_FLD_TX_RXDETECT_REF_MASK);
+		drp_val |= (write_val << XHDMIPHY_DRP_TXOUT_OFFSET);
+		status |= xhdmiphy_drpwr(inst, chid, XDRP_GTHE4_CHN_REG_007C,
+					 drp_val);
+	}
+
+	return status;
+}
+
+/**
+ * xhdmiphy_n_drpenc - This function will translate the configured N1/N2 value
+ * to DRP encoding.
+ *
+ * @inst:	inst is a pointer to the xhdmiphy core instance
+ * @chid:	chid is the channel ID to operate on
+ * @nid:	NId specified to operate on N1 (if == 1) or N2 (if == 2)
+ *
+ * @return:	The DRP encoding for N1/N2
+ */
+static u16 xhdmiphy_n_drpenc(struct xhdmiphy_dev *inst, enum chid chid, u8 nid)
+{
+	struct pll_param pll_prm;
+	u16 drp_enc;
+	u8 nfb_div;
+
+	pll_prm = inst->quad.plls[XHDMIPHY_CH2IDX(chid)].pll_param;
+
+	if (chid == XHDMIPHY_CHID_CMN0 || chid == XHDMIPHY_CHID_CMN1) {
+		nfb_div = pll_prm.nfb_div;
+		drp_enc = xhdmiphy_drpenc_qpll_n(nfb_div);
+	} else if (nid == 1) {
+		nfb_div = pll_prm.n1fb_div;
+		drp_enc = xhdmiphy_drpenc_cpll_n1(nfb_div);
+	} else {
+		nfb_div = pll_prm.n2fb_div;
+		drp_enc = xhdmiphy_drpenc_qpll_mcpll_mn2(nfb_div);
+	}
+
+	return drp_enc;
+}
+
+/**
+ * xhdmiphy_gthe4_clkch_reconf - This function will configure the channel clock
+ * settings.
+ *
+ * @inst:	inst is a pointer to the xhdmiphy core instance
+ * @chid:	chid is the channel ID to operate on
+ *
+ * @return:	- 0 if the configuration was successful
+ *		- 1 otherwise
+ */
+static u32 xhdmiphy_gthe4_clkch_reconf(struct xhdmiphy_dev *inst,
+				       enum chid chid)
+{
+	u32 cpll_vco_mhz, status = 0;
+	u16 drp_val, write_val;
+
+	/* Obtain current DRP register value for PLL dividers */
+	status |= xhdmiphy_drprd(inst, chid, XDRP_GTHE4_CHN_REG_0028, &drp_val);
+	/* Mask out clock divider bits */
+	drp_val &= ~(XDRP_GTHE4_CHN_REG_0028_CPLL_FBDIV_MASK);
+	/* Set CPLL_FBDIV */
+	write_val = (xhdmiphy_n_drpenc(inst, chid, 2) &
+		     XDRP_GTHE4_CHN_REG_0028_FLD_CPLL_FBDIV_MASK);
+	drp_val |= (write_val << XDRP_GTHE4_CHN_REG_0028_FLD_CPLL_FBDIV_SHIFT);
+	/* Set CPLL_FBDIV_45 */
+	write_val = (xhdmiphy_n_drpenc(inst, chid, 1) &
+		     XDRP_GTHE4_CHN_REG_0028_FLD_CPLL_FBDIV_45_MASK);
+	drp_val |= (write_val << XDRP_GTHE4_CHN_REG_0028_FLD_CPLL_FBDIV_45_SHIFT);
+	/* write new DRP register value for PLL dividers */
+	status |= xhdmiphy_drpwr(inst, chid, XDRP_GTHE4_CHN_REG_0028, drp_val);
+	/* write CPLL Ref Clk Div */
+	status |= xhdmiphy_drprd(inst, chid, XDRP_GTHE4_CHN_REG_002A, &drp_val);
+	/* Mask out clock divider bits */
+	drp_val &= ~(XDRP_GTHE4_CHN_REG_002A_CPLL_REFCLK_DIV_MASK);
+	/* Set CPLL_REFCLKDIV */
+	write_val = (xhdmiphy_m_drpenc(inst, chid) &
+		     XDRP_GTHE4_CHN_REG_002A_FLD_A_TXDIFFCTRL_MASK);
+	drp_val |= (write_val << XDRP_GTHE4_CHN_REG_002A_FLD_A_TXDIFFCTRL_SHIFT);
+	/* write new DRP register value for PLL dividers */
+	status |= xhdmiphy_drpwr(inst, chid, XDRP_GTHE4_CHN_REG_002A, drp_val);
+
+	cpll_vco_mhz =
+	xhdmiphy_get_pll_vco_freq(inst, chid,
+				  xhdmiphy_is_tx_using_cpll(inst, chid) ?
+				  XHDMIPHY_DIR_TX : XHDMIPHY_DIR_RX) / 1000000;
+	/* CPLL_CFG0 */
+	if (cpll_vco_mhz <= XHDMIPHY_DRP_CPLL_VCO_RANGE1)
+		drp_val = XHDMIPHY_DRP_CPLL_CFG0_VAL1;
+	else if (cpll_vco_mhz <= XHDMIPHY_DRP_CPLL_VCO_RANGE2)
+		drp_val = XHDMIPHY_DRP_CPLL_CFG0_VAL2;
+	else
+		drp_val = XHDMIPHY_DRP_CPLL_CFG0_VAL3;
+
+	status |= xhdmiphy_drpwr(inst, chid, XDRP_GTHE4_CHN_REG_00CB, drp_val);
+	/* CPLL_CFG1 */
+	if (cpll_vco_mhz <= XHDMIPHY_DRP_CPLL_VCO_RANGE1)
+		drp_val = XHDMIPHY_DRP_CPLL_CFG1_VAL1;
+	else
+		drp_val = XHDMIPHY_DRP_CPLL_CFG1_VAL2;
+
+	status |= xhdmiphy_drpwr(inst, chid, XDRP_GTHE4_CHN_REG_00CC, drp_val);
+	/* CPLL_CFG2 */
+	if (cpll_vco_mhz <= XHDMIPHY_DRP_CPLL_VCO_RANGE1)
+		drp_val = XHDMIPHY_DRP_CPLL_CFG2_VAL1;
+	else if (cpll_vco_mhz <= XHDMIPHY_DRP_CPLL_VCO_RANGE2)
+		drp_val = XHDMIPHY_DRP_CPLL_CFG2_VAL2;
+	else
+		drp_val = XHDMIPHY_DRP_CPLL_CFG2_VAL3;
+
+	status |= xhdmiphy_drpwr(inst, chid, XDRP_GTHE4_CHN_REG_00BC, drp_val);
+	/* configure CPLL Calibration Registers */
+	xhdmiphy_cpll_cal_counttol(inst, chid,
+				   (xhdmiphy_is_tx_using_cpll(inst, chid) ?
+				   XHDMIPHY_DIR_TX : XHDMIPHY_DIR_RX),
+				   inst->conf.drpclk_freq);
+
+	return status;
+}
+
+static u8 xhdmiphy_get_refclk_src_cnt(struct xhdmiphy_dev *inst)
+{
+	enum refclk_sel refclk_sel[XHDMIPHY_REFCLKSEL_MAX];
+	enum refclk_sel refclk_sel_tmp[XHDMIPHY_REFCLKSEL_MAX];
+	u8 i, j, match, refclk_num = 0;
+
+	refclk_sel[0] = (inst->conf.tx_protocol != XHDMIPHY_PROT_NONE) ?
+			 inst->conf.tx_refclk_sel : 99;
+	refclk_sel[1] = (inst->conf.rx_protocol != XHDMIPHY_PROT_NONE) ?
+			 inst->conf.rx_refclk_sel : 99;
+	refclk_sel[2] = (inst->conf.dru_present) ?
+			 inst->conf.dru_refclk_sel : 99;
+	refclk_sel[3] = (inst->conf.tx_protocol == XHDMIPHY_PROT_HDMI21) ?
+			 inst->conf.tx_frl_refclk_sel : 99;
+	refclk_sel[4] = (inst->conf.rx_protocol == XHDMIPHY_PROT_HDMI21) ?
+			 inst->conf.rx_frl_refclk_sel : 99;
+
+	/* initialize Unique refclock holder */
+	for (i = 0; i < XHDMIPHY_REFCLKSEL_MAX; i++)
+		refclk_sel_tmp[i] = 99;
+
+	i = 0;
+	do {
+		if (refclk_sel[i] != 99) {
+			match = 0;
+			j = 0;
+			/* Check if refclk_sel is already in unique holder array */
+			do {
+				if (refclk_sel_tmp[j] == refclk_sel[i])
+					match |= 1;
+				j++;
+			} while (j < refclk_num);
+
+			/* register in unique holder if new RefClk is detected */
+			if (match == 0) {
+				refclk_sel_tmp[refclk_num] = refclk_sel[i];
+				/* increment refclk counter */
+				refclk_num++;
+			}
+		}
+		i++;
+	} while (i < XHDMIPHY_REFCLKSEL_MAX);
+
+	return refclk_num;
+}
+
+/**
+ * xhdmiphy_gthe4_clkcmn_reconf - This function will configure the common
+ * channel clock settings.
+ *
+ * @inst:	inst is a pointer to the xhdmiphy core instance
+ * @cmn_id:	cmn_id is the common channel ID to operate on
+ *
+ * @return:	- 0 if the configuration was successful
+ *		- 1 otherwise
+ */
+static u32 xhdmiphy_gthe4_clkcmn_reconf(struct xhdmiphy_dev *inst,
+					enum chid cmn_id)
+{
+	u32 qpll_vco_mhz, qpll_clkout_mhz, status = 0;
+	u16 drp_val, write_val;
+	u8 nfb_div;
+
+	nfb_div = inst->quad.plls[XHDMIPHY_CH2IDX(cmn_id)].pll_param.nfb_div;
+
+	/* Obtain current DRP register value for QPLL_FBDIV */
+	status |= xhdmiphy_drprd(inst, XHDMIPHY_CHID_CMN,
+		  (cmn_id == XHDMIPHY_CHID_CMN0) ? XDRP_GTHE4_CMN_REG_0014 :
+			     XDRP_GTHE4_CMN_REG_0094, &drp_val);
+	/* Mask out QPLL_FBDIV */
+	drp_val &= ~(XDRP_GTHE4_CMN_REG_0014_FLD_QPLL0_INIT_CFG1_MASK);
+	/* Set QPLL_FBDIV */
+	write_val = (xhdmiphy_n_drpenc(inst, cmn_id, 0) &
+		    XDRP_GTHE4_CMN_REG_0014_FLD_QPLL0_INIT_CFG1_MASK);
+	drp_val |= write_val;
+	/* write new DRP register value for QPLL_FBDIV */
+	status |= xhdmiphy_drpwr(inst, XHDMIPHY_CHID_CMN,
+				 (cmn_id == XHDMIPHY_CHID_CMN0) ?
+				 XDRP_GTHE4_CMN_REG_0014 :
+				 XDRP_GTHE4_CMN_REG_0094, drp_val);
+
+	/* Obtain current DRP register value for QPLL_REFCLK_DIV */
+	status |= xhdmiphy_drprd(inst, XHDMIPHY_CHID_CMN,
+				 (cmn_id == XHDMIPHY_CHID_CMN0) ?
+				 XDRP_GTHE4_CMN_REG_0018 :
+				 XDRP_GTHE4_CMN_REG_0098, &drp_val);
+	/* Mask out QPLL_REFCLK_DIV */
+	drp_val &= ~(XDRP_GTHE4_CMN_REG_0018_QPLLX_REFCLK_DIV_MASK);
+	if (xhdmiphy_get_refclk_src_cnt(inst) > 1)
+		drp_val |= (1 << XDRP_GTHE4_CMN_REG_0018_QPLLX_REFCLK_DIV_SHIFT);
+
+	write_val = (xhdmiphy_m_drpenc(inst, cmn_id) &
+		    XDRP_GTHE4_CMN_REG_0018_QPLLX_REFCLK_DIV_MASK1);
+	drp_val |= (write_val <<
+		    XDRP_GTHE4_CMN_REG_0018_QPLLX_REFCLK_DIV_SHIFT1);
+
+	status |= xhdmiphy_drpwr(inst, XHDMIPHY_CHID_CMN,
+				 (cmn_id == XHDMIPHY_CHID_CMN0) ?
+				 XDRP_GTHE4_CMN_REG_0018 :
+				 XDRP_GTHE4_CMN_REG_0098, drp_val);
+	if ((xhdmiphy_is_hdmi(inst, XHDMIPHY_DIR_TX)) ||
+	    (xhdmiphy_is_hdmi(inst, XHDMIPHY_DIR_RX))) {
+		qpll_vco_mhz =
+		xhdmiphy_get_pll_vco_freq(inst, cmn_id,
+					  xhdmiphy_is_using_qpll(inst, cmn_id, XHDMIPHY_DIR_TX) ?
+					  XHDMIPHY_DIR_TX : XHDMIPHY_DIR_RX) / 1000000;
+		qpll_clkout_mhz = qpll_vco_mhz / 2;
+
+		status |= xhdmiphy_drprd(inst, XHDMIPHY_CHID_CMN,
+					 (cmn_id == XHDMIPHY_CHID_CMN0) ?
+					 XDRP_GTHE4_CMN_REG_000D :
+					 XDRP_GTHE4_CMN_REG_008D, &drp_val);
+
+		drp_val &= ~(XDRP_GTHE4_CMN_REG_000D_PPFX_CFG_MASK);
+		if (qpll_vco_mhz >= XHDMIPHY_DRP_QPLL_VCO_RANGE1)
+			drp_val |= XHDMIPHY_DRP_PPF_MUX_CRNT_CTRL0_VAL1;
+		else if (qpll_vco_mhz >= XHDMIPHY_DRP_QPLL_VCO_RANGE3)
+			drp_val |= XHDMIPHY_DRP_PPF_MUX_CRNT_CTRL0_VAL2;
+		else if (qpll_vco_mhz >= XHDMIPHY_DRP_QPLL_VCO_RANGE4)
+			drp_val |= XHDMIPHY_DRP_PPF_MUX_CRNT_CTRL0_VAL3;
+		else
+			drp_val |= XHDMIPHY_DRP_PPF_MUX_CRNT_CTRL0_VAL4;
+
+		if (qpll_vco_mhz >= XHDMIPHY_DRP_QPLL_VCO_RANGE2)
+			drp_val |= XHDMIPHY_DRP_PPF_MUX_TERM_CTRL0_VAL1;
+		else
+			drp_val |= XHDMIPHY_DRP_PPF_MUX_TERM_CTRL0_VAL2;
+
+		/* write new DRP register value for PPFx_CFG */
+		status |= xhdmiphy_drpwr(inst, XHDMIPHY_CHID_CMN,
+					 (cmn_id == XHDMIPHY_CHID_CMN0) ?
+					 XDRP_GTHE4_CMN_REG_000D :
+					 XDRP_GTHE4_CMN_REG_008D, drp_val);
+		/* QPLL_CP */
+		if (nfb_div <= XHDMIPHY_DRP_QPLL_NFBDIV)
+			drp_val = XHDMIPHY_DRP_QPLL_CP_VAL1;
+		else
+			drp_val = XHDMIPHY_DRP_QPLL_CP_VAL2;
+
+		/* write new DRP register value for QPLL_CP */
+		status |= xhdmiphy_drpwr(inst, XHDMIPHY_CHID_CMN,
+					 (cmn_id == XHDMIPHY_CHID_CMN0) ?
+					 XDRP_GTHE4_CMN_REG_0016 :
+					 XDRP_GTHE4_CMN_REG_0096, drp_val);
+		/* QPLL_LPF */
+		status |= xhdmiphy_drprd(inst, XHDMIPHY_CHID_CMN,
+					 (cmn_id == XHDMIPHY_CHID_CMN0) ?
+					 XDRP_GTHE4_CMN_REG_0019 :
+					 XDRP_GTHE4_CMN_REG_0099, &drp_val);
+		drp_val &= ~(XDRP_GTHE4_CMN_REG_0019_QPLLX_LPF_MASK);
+		if (nfb_div <= XHDMIPHY_DRP_QPLL_NFBDIV)
+			drp_val |= XHDMIPHY_DRP_QPLL_LPF_VAL1;
+		else
+			drp_val |= XHDMIPHY_DRP_QPLL_LPF_VAL2;
+
+		status |= xhdmiphy_drpwr(inst, XHDMIPHY_CHID_CMN,
+					 (cmn_id == XHDMIPHY_CHID_CMN0) ?
+					 XDRP_GTHE4_CMN_REG_0019 :
+					 XDRP_GTHE4_CMN_REG_0099, drp_val);
+		status |= xhdmiphy_drprd(inst, XHDMIPHY_CHID_CMN,
+					 (cmn_id == XHDMIPHY_CHID_CMN0) ?
+					 XDRP_GTHE4_CMN_REG_0030 :
+					 XDRP_GTHE4_CMN_REG_00B0, &drp_val);
+		drp_val &= ~(XDRP_GTHE4_CMN_REG_0030_QPLLX_CFG4_MASK);
+
+		if (qpll_clkout_mhz >= XHDMIPHY_DRP_QPLL_CLKOUT_RANGE1)
+			drp_val |= XHDMIPHY_DRP_Q_TERM_CLK_VAL1 <<
+				   XHDMIPHY_DRP_Q_DCRNT_CLK_SHIFT;
+		else if (qpll_clkout_mhz >= XHDMIPHY_DRP_QPLL_CLKOUT_RANGE2)
+			drp_val |= XHDMIPHY_DRP_Q_TERM_CLK_VAL2 <<
+				   XHDMIPHY_DRP_Q_DCRNT_CLK_SHIFT;
+		else
+			drp_val |= XHDMIPHY_DRP_Q_TERM_CLK_VAL3 <<
+				   XHDMIPHY_DRP_Q_DCRNT_CLK_SHIFT;
+
+		if (qpll_clkout_mhz >= XHDMIPHY_DRP_QPLL_CLKOUT_RANGE1)
+			drp_val |= XHDMIPHY_DRP_Q_DCRNT_CLK_VAL1;
+		else if (qpll_clkout_mhz >= XHDMIPHY_DRP_QPLL_CLKOUT_RANGE3)
+			drp_val |= XHDMIPHY_DRP_Q_DCRNT_CLK_VAL2;
+		else
+			drp_val |= XHDMIPHY_DRP_Q_DCRNT_CLK_VAL3;
+
+		/* write new DRP register value for QPLL_CFG4 */
+		status |= xhdmiphy_drpwr(inst, XHDMIPHY_CHID_CMN,
+					 (cmn_id == XHDMIPHY_CHID_CMN0) ?
+					 XDRP_GTHE4_CMN_REG_0030 :
+					 XDRP_GTHE4_CMN_REG_00B0, drp_val);
+	}
+
+	return status;
+}
+
+/**
+ * xhdmiphy_gthe4_rxpll_div1_reconf - This function will configure the
+ * channel's RX CLKDIV1 settings.
+ *
+ * @inst:	inst is a pointer to the xhdmiphy core instance
+ * @chid:	chid is the channel ID to operate on
+ *
+ * @return:	- 0 if the configuration was successful
+ *		- 1 otherwise
+ */
+static bool xhdmiphy_gthe4_rxpll_div1_reconf(struct xhdmiphy_dev *inst,
+					     enum chid chid)
+{
+	struct channel *pll_ptr = &inst->quad.plls[XHDMIPHY_CH2IDX(chid)];
+	u32 rx_refclk, status = 0;
+	u16 drp_val;
+
+	if (xhdmiphy_is_hdmi(inst, XHDMIPHY_DIR_RX))
+		rx_refclk = inst->rx_refclk_hz;
+	else
+		rx_refclk = xhdmiphy_get_quad_refclk(inst, pll_ptr->pll_refclk);
+
+	status |= xhdmiphy_drprd(inst, chid, XDRP_GTHE4_CHN_REG_006D, &drp_val);
+	drp_val &= ~XDRP_GTHE4_CHN_REG_006D_RXCLK25_MASK;
+	drp_val |= xhdmiphy_drpenc_clk25(rx_refclk) << 3;
+	status |= xhdmiphy_drpwr(inst, chid, XDRP_GTHE4_CHN_REG_006D, drp_val);
+
+	return status;
+}
+
+/**
+ * xhdmiphy_gthe4_rxch_reconf - This function will configure the channel's RX
+ * settings.
+ *
+ * @inst:	inst is a pointer to the xhdmiphy core instance
+ * @chid:	chid is the channel ID to operate on
+ *
+ * @return:	- 0 if the configuration was successful
+ *		- 1 otherwise
+ */
+static u32 xhdmiphy_gthe4_rxch_reconf(struct xhdmiphy_dev *inst, enum chid chid)
+{
+	struct channel *ch_ptr;
+	enum chid chid_pll;
+	enum pll_type pll_type;
+	u64 linkrate;
+	u32 xvcorate_mhz, pll_clkout_mhz, pll_clkout_div, status = 0;
+	u16 drp_val, write_val;
+	u8 i;
+
+	ch_ptr = &inst->quad.plls[XHDMIPHY_CH2IDX(chid)];
+
+	for (i = 0; i < 5; i++) {
+		drp_val = ch_ptr->pll_param.cdr[i];
+		if (!drp_val) {
+			/* don't modify RX_CDR configuration */
+			continue;
+		}
+		status |= xhdmiphy_drpwr(inst, chid, XHDMIPHY_DRP_RXCDR_CFG(i),
+					 drp_val);
+		if (i == 2) {
+			status |= xhdmiphy_drpwr(inst, chid,
+				  XHDMIPHY_DRP_RXCDR_CFG_GEN3(i), drp_val);
+		}
+	}
+
+	if (xhdmiphy_is_hdmi(inst, XHDMIPHY_DIR_RX)) {
+		pll_type = xhdmiphy_get_pll_type(inst, XHDMIPHY_DIR_RX, chid);
+		switch (pll_type) {
+		case XHDMIPHY_PLL_QPLL:
+		case XHDMIPHY_PLL_QPLL0:
+			chid_pll = XHDMIPHY_CHID_CMN0;
+			pll_clkout_div = XHDMIPHY_DRP_PLL_CLKOUT_DIV_VAL1;
+			break;
+		case XHDMIPHY_PLL_QPLL1:
+			chid_pll = XHDMIPHY_CHID_CMN1;
+			pll_clkout_div = XHDMIPHY_DRP_PLL_CLKOUT_DIV_VAL1;
+			break;
+		default:
+			chid_pll = chid;
+			pll_clkout_div = XHDMIPHY_DRP_PLL_CLKOUT_DIV_VAL2;
+			break;
+		}
+
+		linkrate = xhdmiphy_get_linerate(inst, chid_pll) / 1000;
+		/* RXCDR_CFG3 & RXCDR_CFG3_GEN3 */
+		if (linkrate > XHDMIPHY_DRP_LINERATEKHZ_1)
+			drp_val = XHDMIPHY_DRP_RXCDR_CFG_WORD3_VAL1;
+		else if ((linkrate > XHDMIPHY_DRP_LINERATEKHZ_2) &&
+			 (ch_ptr->rx_data_width == XHDMIPHY_DRP_RX_DATAWIDTH_64))
+			drp_val = XHDMIPHY_DRP_RXCDR_CFG_WORD3_VAL2;
+		else if (linkrate > XHDMIPHY_DRP_LINERATEKHZ_3)
+			drp_val = XHDMIPHY_DRP_RXCDR_CFG_WORD3_VAL1;
+		else
+			drp_val = XHDMIPHY_DRP_RXCDR_CFG_WORD3_VAL3;
+
+		/* write RXCDR_CFG3 Value */
+		status |= xhdmiphy_drpwr(inst, chid, XDRP_GTHE4_CHN_REG_0011,
+					 drp_val);
+		/* write RXCDR_CFG3_GEN3 Value */
+		status |= xhdmiphy_drpwr(inst, chid,
+					 XHDMIPHY_DRP_RXCDR_CFG_GEN3(3),
+					 drp_val);
+		/* RXCDR_CFG2_GEN2 & RXCDR_CFG3_GEN2 */
+		/* Get [15:10] from RXCDR_CFG3[5:0] */
+		drp_val = (drp_val &
+			  XDRP_GTHE4_CHN_REG_0011_RXCDR_CGF3_GEN2_MASK) <<
+			  XDRP_GTHE4_CHN_REG_0011_RXCDR_CGF3_GEN2_SHIFT;
+		/* Get [9:0] from RXCDR_CFG2[9:0] */
+		drp_val &= ~XDRP_GTHE4_CHN_REG_00AF_RXCDR_CGF2_GEN2_MASK;
+		drp_val |= ch_ptr->pll_param.cdr[2] &
+			   XDRP_GTHE4_CHN_REG_00AF_RXCDR_CGF2_GEN2_MASK;
+		/* write RXCDR_CFG2_GEN2 & RXCDR_CFG3_GEN2 value */
+		status |= xhdmiphy_drpwr(inst, chid, XDRP_GTHE4_CHN_REG_00AF,
+					 drp_val);
+
+		/* RX_WIDEMODE_CDR Encoding */
+		switch (ch_ptr->rx_data_width) {
+		case XHDMIPHY_DRP_RX_DATAWIDTH_80:
+			if (linkrate > XHDMIPHY_DRP_LINERATEKHZ_4)
+				write_val = XHDMIPHY_RX_WIDEMODE_CDR_ENC_VAL1 <<
+					    XHDMIPHY_RX_WIDEMODE_CDR_ENC_SHIFT;
+			else
+				write_val = XHDMIPHY_RX_WIDEMODE_CDR_ENC_VAL2 <<
+					    XHDMIPHY_RX_WIDEMODE_CDR_ENC_SHIFT;
+			break;
+		case XHDMIPHY_DRP_RX_DATAWIDTH_64:
+			if (linkrate > XHDMIPHY_DRP_LINERATEKHZ_5)
+				write_val = XHDMIPHY_RX_WIDEMODE_CDR_ENC_VAL1 <<
+					    XHDMIPHY_RX_WIDEMODE_CDR_ENC_SHIFT;
+			else
+				write_val = XHDMIPHY_RX_WIDEMODE_CDR_ENC_VAL2 <<
+					    XHDMIPHY_RX_WIDEMODE_CDR_ENC_SHIFT;
+			break;
+		case XHDMIPHY_DRP_RX_DATAWIDTH_40:
+			if (linkrate > XHDMIPHY_DRP_LINERATEKHZ_3)
+				write_val = XHDMIPHY_RX_WIDEMODE_CDR_ENC_VAL2 <<
+					    XHDMIPHY_RX_WIDEMODE_CDR_ENC_SHIFT;
+			else
+				write_val = XHDMIPHY_RX_WIDEMODE_CDR_ENC_VAL3;
+			break;
+		case XHDMIPHY_DRP_RX_DATAWIDTH_32:
+			if (linkrate > XHDMIPHY_DRP_LINERATEKHZ_6)
+				write_val = XHDMIPHY_RX_WIDEMODE_CDR_ENC_VAL2 <<
+					    XHDMIPHY_RX_WIDEMODE_CDR_ENC_SHIFT;
+			else
+				write_val = XHDMIPHY_RX_WIDEMODE_CDR_ENC_VAL3;
+			break;
+		default:
+			write_val = XHDMIPHY_RX_WIDEMODE_CDR_ENC_VAL3;
+			break;
+		}
+
+		/* RX_INT_DATAWIDTH & RX_WIDEMODE_CDR */
+		status |= xhdmiphy_drprd(inst, chid, XDRP_GTHE4_CHN_REG_0066,
+					 &drp_val);
+		drp_val &= ~(XDRP_GTHE4_CHN_REG_0066_RX_INT_DATAWIDTH_MASK);
+		/* Update RX_WIDEMODE_CDR Value */
+		drp_val |= write_val & XDRP_GTHE4_CHN_REG_0066_RX_WIDEMODE_CDR_MASK;
+		write_val = (xhdmiphy_drpenc_int_datawidth(ch_ptr->rx_intdata_width) &
+			    XDRP_GTHE4_CHN_REG_0066_RX_WIDEMODE_CDR_MASK_VAL);
+
+		drp_val |= write_val;
+		status |= xhdmiphy_drpwr(inst, chid, XDRP_GTHE4_CHN_REG_0066,
+					 drp_val);
+		/* RX_DATA_WIDTH */
+		status |= xhdmiphy_drprd(inst, chid, XDRP_GTHE4_CHN_REG_0003,
+					 &drp_val);
+		drp_val &= ~(XDRP_GTHE4_CHN_REG_0003_RX_DATAWIDTH_MASK);
+		write_val = (xhdmiphy_drpenc_datawidth(ch_ptr->rx_data_width) &
+			    XDRP_GTHE4_CHN_REG_0003_RX_DATAWIDTH_ENC_MASK);
+		write_val <<= XDRP_GTHE4_CHN_REG_0003_RX_DATAWIDTH_ENC_SHIFT;
+		drp_val |= write_val;
+		status |= xhdmiphy_drpwr(inst, chid, XDRP_GTHE4_CHN_REG_0003,
+					 drp_val);
+		xvcorate_mhz = xhdmiphy_get_pll_vco_freq(inst, chid_pll,
+							 XHDMIPHY_DIR_RX) / 1000000;
+		pll_clkout_mhz = xvcorate_mhz / pll_clkout_div;
+		/* CH_HSPMUX_RX */
+		status |= xhdmiphy_drprd(inst, chid, XDRP_GTHE4_CHN_REG_0116,
+					 &drp_val);
+		drp_val &= ~(XDRP_GTHE4_CHN_REG_0116_CH_RX_HSPMUX_MASK);
+
+		if (pll_clkout_mhz >= XHDMIPHY_DRP_PLL_CLKOUT_RANGE1)
+			drp_val |= XHDMIPHY_DRP_PLLX_CLKOUT_VAL1;
+		else if (pll_clkout_mhz >= XHDMIPHY_DRP_PLL_CLKOUT_RANGE3)
+			drp_val |= XHDMIPHY_DRP_PLLX_CLKOUT_VAL2;
+		else if (pll_clkout_mhz >= XHDMIPHY_DRP_PLL_CLKOUT_RANGE2)
+			drp_val |= XHDMIPHY_DRP_PLLX_CLKOUT_VAL3;
+		else
+			drp_val |= XHDMIPHY_DRP_PLLX_CLKOUT_VAL4;
+
+		status |= xhdmiphy_drpwr(inst, chid, XDRP_GTHE4_CHN_REG_0116,
+					 drp_val);
+		status |= xhdmiphy_drprd(inst, chid, XDRP_GTHE4_CHN_REG_00FB,
+					 &drp_val);
+		drp_val &= ~(XDRP_GTHE4_CHN_REG_00FB_PREIQ_FREQ_BST_MASK);
+
+		if (pll_clkout_mhz > XHDMIPHY_DRP_PLL_CLKOUT_RANGE4)
+			drp_val |= XHDMIPHY_DRP_PREIQ_FREQ_BST_VAL1 <<
+				   XHDMIPHY_DRP_PREIQ_FREQ_BST_SHIFT;
+		else if (pll_clkout_mhz >= XHDMIPHY_DRP_PLL_CLKOUT_RANGE5)
+			drp_val |= XHDMIPHY_DRP_PREIQ_FREQ_BST_VAL2 <<
+				   XHDMIPHY_DRP_PREIQ_FREQ_BST_SHIFT; /* LPM mode */
+		else if (pll_clkout_mhz >= 10000)
+			drp_val |= XHDMIPHY_DRP_PREIQ_FREQ_BST_VAL2 <<
+				   XHDMIPHY_DRP_PREIQ_FREQ_BST_SHIFT;
+		else if (pll_clkout_mhz >= 6000)
+			drp_val |= XHDMIPHY_DRP_PREIQ_FREQ_BST_VAL3 <<
+				   XHDMIPHY_DRP_PREIQ_FREQ_BST_SHIFT;
+
+		/* write new DRP register value for PREIQ_FREQ_BST */
+		status |= xhdmiphy_drpwr(inst, chid, XDRP_GTHE4_CHN_REG_00FB,
+					 drp_val);
+
+		/* RXPI_CFG0 */
+		if (pll_clkout_mhz > XHDMIPHY_DRP_PLL_CLKOUT_RANGE8)
+			drp_val = XHDMIPHY_DRP_RXPI_CFG0_VAL1;
+		else if (pll_clkout_mhz >= XHDMIPHY_DRP_PLL_CLKOUT_RANGE9)
+			drp_val = XHDMIPHY_DRP_RXPI_CFG0_VAL2;
+		else if (pll_clkout_mhz >= XHDMIPHY_DRP_PLL_CLKOUT_RANGE10)
+			drp_val = XHDMIPHY_DRP_RXPI_CFG0_VAL3;
+		else if (pll_clkout_mhz >= XHDMIPHY_DRP_PLL_CLKOUT_RANGE11)
+			drp_val = XHDMIPHY_DRP_RXPI_CFG0_VAL4;
+		else if (pll_clkout_mhz >= XHDMIPHY_DRP_PLL_CLKOUT_RANGE12)
+			drp_val = XHDMIPHY_DRP_RXPI_CFG0_VAL5;
+		else if (pll_clkout_mhz >= XHDMIPHY_DRP_PLL_CLKOUT_RANGE13)
+			drp_val = XHDMIPHY_DRP_RXPI_CFG0_VAL6;
+		else if (pll_clkout_mhz >= XHDMIPHY_DRP_PLL_CLKOUT_RANGE14)
+			drp_val = XHDMIPHY_DRP_RXPI_CFG0_VAL7;
+		else if (pll_clkout_mhz >= XHDMIPHY_DRP_PLL_CLKOUT_RANGE15)
+			drp_val = XHDMIPHY_DRP_RXPI_CFG0_VAL8;
+		else if (pll_clkout_mhz >= XHDMIPHY_DRP_PLL_CLKOUT_RANGE16)
+			drp_val = XHDMIPHY_DRP_RXPI_CFG0_VAL9;
+		else
+			drp_val = XHDMIPHY_DRP_RXPI_CFG0_VAL10;
+
+		/* write new DRP register value for RXPI_CFG0 */
+		status |= xhdmiphy_drpwr(inst, chid, XDRP_GTHE4_CHN_REG_009D,
+					 drp_val);
+		/* RXPI_CFG1 */
+		if (pll_clkout_mhz >= XHDMIPHY_DRP_PLL_CLKOUT_RANGE10)
+			drp_val = XHDMIPHY_DRP_RXPI_CFG1_VAL1;
+		else if (pll_clkout_mhz >= XHDMIPHY_DRP_PLL_CLKOUT_RANGE12)
+			drp_val = XHDMIPHY_DRP_RXPI_CFG1_VAL2;
+		else if (pll_clkout_mhz >= XHDMIPHY_DRP_PLL_CLKOUT_RANGE14)
+			drp_val = XHDMIPHY_DRP_RXPI_CFG1_VAL3;
+		else if (pll_clkout_mhz >= XHDMIPHY_DRP_PLL_CLKOUT_RANGE18)
+			drp_val = XHDMIPHY_DRP_RXPI_CFG1_VAL4;
+		else
+			drp_val = XHDMIPHY_DRP_RXPI_CFG1_VAL5;
+
+		/* write new DRP register value for RXPI_CFG1 */
+		status |= xhdmiphy_drpwr(inst, chid, XDRP_GTHE4_CHN_REG_0100,
+					 drp_val);
+	}
+
+	status |= xhdmiphy_gthe4_rxpll_div1_reconf(inst, chid);
+
+	return status;
+}
+
+/**
+ * xhdmiphy_gthe4_txpll_div1_reconf - This function will configure the
+ * channel's TX CLKDIV1 settings.
+ *
+ * @inst:	inst is a pointer to the XHdmiphy1 core instance
+ * @chid:	chid is the channel ID to operate on
+ *
+ * @return:	- 0 if the configuration was successful
+ *		- 1 otherwise
+ */
+static u32 xhdmiphy_gthe4_txpll_div1_reconf(struct xhdmiphy_dev *inst,
+					    enum chid chid)
+{
+	struct channel *pll_ptr = &inst->quad.plls[XHDMIPHY_CH2IDX(chid)];
+	u32 tx_refclkhz;
+	u32 status = 0;
+	u16 drp_val;
+
+	if (xhdmiphy_is_hdmi(inst, XHDMIPHY_DIR_TX))
+		tx_refclkhz = inst->tx_refclk_hz;
+	else
+		tx_refclkhz = xhdmiphy_get_quad_refclk(inst,
+						       pll_ptr->pll_refclk);
+
+	status |= xhdmiphy_drprd(inst, chid, XDRP_GTHE4_CHN_REG_007A, &drp_val);
+	drp_val &= ~XDRP_GTHE4_CHN_REG_007A_TXCLK25_MASK;
+	drp_val |= xhdmiphy_drpenc_clk25(tx_refclkhz) <<
+		   XDRP_GTHE4_CHN_REG_007A_TXCLK25_SHIFT;
+	status |= xhdmiphy_drpwr(inst, chid, XDRP_GTHE4_CHN_REG_007A, drp_val);
+
+	return status;
+}
+
+/**
+ * xhdmiphy_gthe4_txch_reconf - This function will configure the channel's
+ * TX settings.
+ *
+ * @inst:	inst is a pointer to the xhdmiphy core instance
+ * @chid:	chid is the channel ID to operate on
+ *
+ * @return:	- 0 if the configuration was successful
+ *		- 1 otherwise
+ */
+static u32 xhdmiphy_gthe4_txch_reconf(struct xhdmiphy_dev *inst, enum chid chid)
+{
+	struct channel *ch_ptr;
+	enum chid chid_pll;
+	enum pll_type pll_type;
+	u32 ret_val, xvcorate_mhz, pll_clkout_mhz, pll_clkout_div;
+	u32 status = 0;
+	u16 drp_val, write_val;
+
+	ret_val = xhdmiphy_gthe4_txpll_div1_reconf(inst, chid);
+	if (!xhdmiphy_is_hdmi(inst, XHDMIPHY_DIR_TX))
+		return ret_val;
+
+	pll_type = xhdmiphy_get_pll_type(inst, XHDMIPHY_DIR_TX, chid);
+
+	switch (pll_type) {
+	case XHDMIPHY_PLL_QPLL:
+	case XHDMIPHY_PLL_QPLL0:
+		chid_pll = XHDMIPHY_CHID_CMN0;
+		pll_clkout_div = XHDMIPHY_DRP_PLL_CLKOUT_DIV_VAL1;
+		break;
+	case XHDMIPHY_PLL_QPLL1:
+		chid_pll = XHDMIPHY_CHID_CMN1;
+		pll_clkout_div = XHDMIPHY_DRP_PLL_CLKOUT_DIV_VAL1;
+		break;
+	default:
+		chid_pll = chid;
+		pll_clkout_div = XHDMIPHY_DRP_PLL_CLKOUT_DIV_VAL2;
+		break;
+	}
+
+	if (xhdmiphy_is_hdmi(inst, XHDMIPHY_DIR_TX)) {
+		ch_ptr = &inst->quad.plls[XHDMIPHY_CH2IDX(chid)];
+		/* set TX_PROGDIV_CFG to 20/40 */
+		if (pll_type == XHDMIPHY_PLL_QPLL ||
+		    pll_type == XHDMIPHY_PLL_QPLL0 ||
+		    pll_type == XHDMIPHY_PLL_QPLL1) {
+			if (inst->quad.plls[XHDMIPHY_CH2IDX(chid)].tx_outdiv != 16) {
+				/* TX_PROGDIV_CFG = 20 */
+				xhdmiphy_drpwr(inst, chid,
+					       XDRP_GTHE4_CHN_REG_003E,
+					       XDRP_GTHE4_CHN_REG_003E_DRP_VAL1);
+			} else {
+				/* TX_PROGDIV_CFG = 40 */
+				xhdmiphy_drpwr(inst, chid,
+					       XDRP_GTHE4_CHN_REG_003E,
+					       XDRP_GTHE4_CHN_REG_003E_DRP_VAL2);
+			}
+		}
+
+		/* TX_INT_DATAWIDTH */
+		status |= xhdmiphy_drprd(inst, chid, XDRP_GTHE4_CHN_REG_0085,
+					 &drp_val);
+		drp_val &= ~(XDRP_GTHE4_CHN_REG_0085_TX_INT_DATAWIDTH_MASK <<
+			    XDRP_GTHE4_CHN_REG_0085_TX_INT_DATAWIDTH_SHIFT);
+		write_val = (xhdmiphy_drpenc_int_datawidth(ch_ptr->tx_intdata_width) &
+			    XDRP_GTHE4_CHN_REG_0085_TX_INT_DATAWIDTH_MASK);
+		write_val = write_val << XDRP_GTHE4_CHN_REG_0085_TX_INT_DATAWIDTH_SHIFT;
+		drp_val |= write_val;
+		status |= xhdmiphy_drpwr(inst, chid, XDRP_GTHE4_CHN_REG_0085,
+					 drp_val);
+		/* TX_DATA_WIDTH */
+		status |= xhdmiphy_drprd(inst, chid, XDRP_GTHE4_CHN_REG_007A,
+					 &drp_val);
+		drp_val &= ~(XDRP_GTHE4_CHN_REG_007A_TX_DATA_WIDTH_MASK);
+		write_val = (xhdmiphy_drpenc_datawidth(ch_ptr->tx_data_width) &
+			    XDRP_GTHE4_CHN_REG_007A_TX_DATA_WIDTH_MASK);
+
+		drp_val |= write_val;
+		status |= xhdmiphy_drpwr(inst, chid, XDRP_GTHE4_CHN_REG_007A,
+					 drp_val);
+
+		/* TXPH_CFG */
+		if (ch_ptr->tx_outdiv == XHDMIPHY_DRP_TX_OUTDIV_VAL1) {
+			if (ch_ptr->tx_data_width >
+			    XHDMIPHY_DRP_TX_DATAWIDTH_VAL1)
+				drp_val = XHDMIPHY_DRP_TXPH_CFG_VAL1;
+			else
+				drp_val = XHDMIPHY_DRP_TXPH_CFG_VAL2;
+		} else if (ch_ptr->tx_outdiv ==
+			   XHDMIPHY_DRP_TX_OUTDIV_VAL2) {
+			if (ch_ptr->tx_data_width >
+			    XHDMIPHY_DRP_TX_DATAWIDTH_VAL2)
+				drp_val = XHDMIPHY_DRP_TXPH_CFG_VAL1;
+			else
+				drp_val = XHDMIPHY_DRP_TXPH_CFG_VAL2;
+		} else {
+			drp_val = XHDMIPHY_DRP_TXPH_CFG_VAL1;
+		}
+
+		status |= xhdmiphy_drpwr(inst, chid, XDRP_GTHE4_CHN_REG_0073,
+					 drp_val);
+		xvcorate_mhz = xhdmiphy_get_pll_vco_freq(inst, chid_pll,
+							 XHDMIPHY_DIR_TX) / 1000000;
+		pll_clkout_mhz = xvcorate_mhz / pll_clkout_div;
+
+		/* TXPI_CFG */
+		if (pll_clkout_mhz >= XHDMIPHY_DRP_PLL_CLKOUT_RANGE10)
+			drp_val = XHDMIPHY_DRP_TXPI_CFG_VAL1;
+		else if (pll_clkout_mhz >= XHDMIPHY_DRP_PLL_CLKOUT_RANGE14)
+			drp_val = XHDMIPHY_DRP_TXPI_CFG_VAL2;
+		else
+			drp_val = XHDMIPHY_DRP_TXPI_CFG_VAL3;
+
+		/* write new DRP register value for TXPI_CFG */
+		status |= xhdmiphy_drpwr(inst, chid, XDRP_GTHE4_CHN_REG_00FF,
+					 drp_val);
+
+		/* TXPI_CFG3 & TXPI_CFG4 */
+		status |= xhdmiphy_drprd(inst, chid, XDRP_GTHE4_CHN_REG_009C,
+					 &drp_val);
+		drp_val &= ~(XDRP_GTHE4_CHN_REG_009C_TXPI_CFG3_CFG4_MASK);
+		if (pll_clkout_mhz > XHDMIPHY_DRP_PLL_CLKOUT_RANGE8)
+			drp_val = XHDMIPHY_DRP_TXPI_CFG3_CFG4_VAL1;
+		else if (pll_clkout_mhz >= XHDMIPHY_DRP_PLL_CLKOUT_RANGE9)
+			drp_val = XHDMIPHY_DRP_TXPI_CFG3_CFG4_VAL2;
+		else if (pll_clkout_mhz >= XHDMIPHY_DRP_PLL_CLKOUT_RANGE10)
+			drp_val = XHDMIPHY_DRP_TXPI_CFG3_CFG4_VAL3;
+		else if (pll_clkout_mhz >= XHDMIPHY_DRP_PLL_CLKOUT_RANGE11)
+			drp_val = XHDMIPHY_DRP_TXPI_CFG3_CFG4_VAL1;
+		else if (pll_clkout_mhz >= XHDMIPHY_DRP_PLL_CLKOUT_RANGE13)
+			drp_val = XHDMIPHY_DRP_TXPI_CFG3_CFG4_VAL2;
+		else if (pll_clkout_mhz >= XHDMIPHY_DRP_PLL_CLKOUT_RANGE15)
+			drp_val = XHDMIPHY_DRP_TXPI_CFG3_CFG4_VAL3;
+		else
+			drp_val = XHDMIPHY_DRP_TXPI_CFG3_CFG4_VAL4;
+
+		drp_val = (drp_val << XHDMIPHY_DRP_TXPI_CFG3_CFG4_SHIFT) &
+			  XDRP_GTHE4_CHN_REG_009C_TXPI_CFG3_CFG4_MASK;
+		/* write new DRP register value for TXPI_CFG3 & TXPI_CFG4 */
+		status |= xhdmiphy_drpwr(inst, chid, XDRP_GTHE4_CHN_REG_009C,
+					 drp_val);
+		/* TX_PI_BIASSET */
+		status |= xhdmiphy_drprd(inst, chid, XDRP_GTHE4_CHN_REG_00FB,
+					 &drp_val);
+		drp_val &= ~(XDRP_GTHE4_CHN_REG_00FB_TXPI_BIASSET_MASK);
+		if (pll_clkout_mhz >= XHDMIPHY_DRP_PLL_CLKOUT_RANGE17)
+			drp_val |= XHDMIPHY_DRP_TXPI_BIASSET_VAL1 <<
+				   XHDMIPHY_DRP_TXPI_BIASSET_SHIFT;
+		else if (pll_clkout_mhz >= XHDMIPHY_DRP_PLL_CLKOUT_RANGE10)
+			drp_val |= XHDMIPHY_DRP_TXPI_BIASSET_VAL2 <<
+				   XHDMIPHY_DRP_TXPI_BIASSET_SHIFT;
+		else if (pll_clkout_mhz >= XHDMIPHY_DRP_PLL_CLKOUT_RANGE14)
+			drp_val |= XHDMIPHY_DRP_TXPI_BIASSET_VAL3 <<
+				   XHDMIPHY_DRP_TXPI_BIASSET_SHIFT;
+
+		/* write new DRP register value for TX_PI_BIASSET */
+		status |= xhdmiphy_drpwr(inst, chid, XDRP_GTHE4_CHN_REG_00FB,
+					 drp_val);
+		/* CH_HSPMUX_TX */
+		status |= xhdmiphy_drprd(inst, chid, XDRP_GTHE4_CHN_REG_0116,
+					 &drp_val);
+		drp_val &= ~(XDRP_GTHE4_CHN_REG_0116_CH_TX_HSPMUX_MASK);
+
+		if (pll_clkout_mhz >= XHDMIPHY_DRP_PLL_CLKOUT_RANGE17)
+			drp_val |= XHDMIPHY_DRP_CH_HSPMUX_VAL1 <<
+				   XHDMIPHY_DRP_CH_HSPMUX_SHIFT;
+		else if (pll_clkout_mhz >= XHDMIPHY_DRP_PLL_CLKOUT_RANGE10)
+			drp_val |= XHDMIPHY_DRP_CH_HSPMUX_VAL2 <<
+				   XHDMIPHY_DRP_CH_HSPMUX_SHIFT;
+		else if (pll_clkout_mhz >= XHDMIPHY_DRP_PLL_CLKOUT_RANGE14)
+			drp_val |= XHDMIPHY_DRP_CH_HSPMUX_VAL3 <<
+				   XHDMIPHY_DRP_CH_HSPMUX_SHIFT;
+		else
+			drp_val |= XHDMIPHY_DRP_CH_HSPMUX_VAL4 <<
+				   XHDMIPHY_DRP_CH_HSPMUX_SHIFT;
+
+		/* write new DRP register value for CH_HSPMUX_TX */
+		status |= xhdmiphy_drpwr(inst, chid, XDRP_GTHE4_CHN_REG_0116,
+					 drp_val);
+	}
+
+	return status;
+}
+
+/**
+ * xhdmiphy_set_gt_linerate_cfg - This function will set the TXRATE or RXRATE
+ * port to select the GT Wizard configuration
+ *
+ * @inst:	inst is a pointer to the xhdmiphy core instance
+ * @chid:	chid is the channel ID to operate on
+ * @dir:	dir is an indicator for TX or RX
+ */
+static void xhdmiphy_set_gt_linerate_cfg(struct xhdmiphy_dev *inst,
+					 enum chid chid, enum dir dir)
+{
+	enum pll_type pll_type;
+	u32 reg_val, mask_val, shift_val, reg_off;
+	u16 lr_val;
+
+	pll_type = xhdmiphy_get_pll_type(inst, dir, XHDMIPHY_CHID_CH1);
+
+	if (pll_type == XHDMIPHY_PLL_LCPLL)
+		lr_val = inst->quad.lcpll.linerate_cfg;
+	else
+		lr_val = inst->quad.rpll.linerate_cfg;
+
+	if (dir == XHDMIPHY_DIR_TX) {
+		if (chid == XHDMIPHY_CHID_CH1 || chid == XHDMIPHY_CHID_CH2)
+			reg_off = XHDMIPHY_TX_RATE_CH12_REG;
+		else
+			reg_off = XHDMIPHY_TX_RATE_CH34_REG;
+
+		mask_val = XHDMIPHY_TX_RATE_MASK(chid);
+		shift_val = XHDMIPHY_TX_RATE_SHIFT(chid);
+	} else {
+		if (chid == XHDMIPHY_CHID_CH1 || chid == XHDMIPHY_CHID_CH2)
+			reg_off = XHDMIPHY_RX_RATE_CH12_REG;
+		else
+			reg_off = XHDMIPHY_RX_RATE_CH34_REG;
+
+		mask_val = XHDMIPHY_RX_RATE_MASK(chid);
+		shift_val = XHDMIPHY_RX_RATE_SHIFT(chid);
+	}
+
+	reg_val = xhdmiphy_read(inst, reg_off);
+	reg_val &= ~mask_val;
+	reg_val |= (lr_val << shift_val);
+	xhdmiphy_write(inst, reg_off, reg_val);
+}
+
+static u32 xhdmiphy_gtye5_rxch_reconf(struct xhdmiphy_dev *inst, enum chid chid)
+{
+	u8 val_cmp;
+
+	val_cmp = xhdmiphy_check_linerate_cfg(inst, chid, XHDMIPHY_DIR_RX);
+
+	if (!val_cmp) {
+		xhdmiphy_set_gt_linerate_cfg(inst, chid, XHDMIPHY_DIR_RX);
+	} else {
+		xhdmiphy_gt_mst_rst(inst, chid, XHDMIPHY_DIR_RX, true);
+		xhdmiphy_gt_mst_rst(inst, chid, XHDMIPHY_DIR_RX, false);
+	}
+
+	return 0;
+}
+
+static u32 xhdmiphy_gtye5_txch_reconf(struct xhdmiphy_dev *inst, enum chid chid)
+{
+	u8 val_cmp;
+
+	/* Compare the current and next CFG values */
+	val_cmp = xhdmiphy_check_linerate_cfg(inst, chid, XHDMIPHY_DIR_TX);
+	if (!val_cmp) {
+		xhdmiphy_set_gt_linerate_cfg(inst, chid, XHDMIPHY_DIR_TX);
+	} else {
+		/* Toggle RX Master Reset */
+		xhdmiphy_gt_mst_rst(inst, chid, XHDMIPHY_DIR_TX, true);
+		xhdmiphy_gt_mst_rst(inst, chid, XHDMIPHY_DIR_TX, false);
+	}
+
+	return 0;
+}
+
+/**
+ * xhdmiphy_get_gt_linerate - This function will get the TXRATE or RXRATE port
+ * to select the GT Wizard configuration
+ *
+ * @inst:	inst is a pointer to the xhdmiphy core instance
+ * @chid:	chid is the channel ID to operate on
+ * @dir:	dir is an indicator for TX or RX
+ *
+ * return:	returns linerate
+ */
+static u16 xhdmiphy_get_gt_linerate(struct xhdmiphy_dev *inst, enum chid chid,
+				    enum dir dir)
+{
+	u32 reg_val, mask_val, shift_val, reg_off;
+	u16 lr_val;
+
+	if (dir == XHDMIPHY_DIR_TX) {
+		if (chid == XHDMIPHY_CHID_CH1 || chid == XHDMIPHY_CHID_CH2)
+			reg_off = XHDMIPHY_TX_RATE_CH12_REG;
+		else
+			reg_off = XHDMIPHY_TX_RATE_CH34_REG;
+
+		mask_val = XHDMIPHY_TX_RATE_MASK(chid);
+		shift_val = XHDMIPHY_TX_RATE_SHIFT(chid);
+	} else {
+		if (chid == XHDMIPHY_CHID_CH1 || chid == XHDMIPHY_CHID_CH2)
+			reg_off = XHDMIPHY_RX_RATE_CH12_REG;
+		else
+			reg_off = XHDMIPHY_RX_RATE_CH34_REG;
+
+		mask_val = XHDMIPHY_RX_RATE_MASK(chid);
+		shift_val = XHDMIPHY_RX_RATE_SHIFT(chid);
+	}
+
+	reg_val = xhdmiphy_read(inst, reg_off);
+	reg_val &= mask_val;
+	lr_val = (u16)(reg_val >> shift_val);
+
+	return lr_val;
+}
+
+/**
+ * xhdmiphy_check_linerate_cfg - This function will check the current CFG
+ * setting and compare it with the next CFG value
+ *
+ * @inst:	inst is a pointer to the xhdmiphy core instance
+ * @chid:	chid is the channel ID to operate on
+ * @dir:	dir is an indicator for TX or RX
+ *
+ * @return:	true if Current and Next CFG are the same
+ *		false if Current and Next CFG are different
+ */
+bool xhdmiphy_check_linerate_cfg(struct xhdmiphy_dev *inst, enum chid chid,
+				 enum dir dir)
+{
+	enum pll_type pll_type;
+	u16 cur_val, lr_val;
+
+	pll_type = xhdmiphy_get_pll_type(inst, dir, XHDMIPHY_CHID_CH1);
+
+	if (pll_type == XHDMIPHY_PLL_LCPLL)
+		lr_val = inst->quad.lcpll.linerate_cfg;
+	else
+		lr_val = inst->quad.rpll.linerate_cfg;
+
+	cur_val = xhdmiphy_get_gt_linerate(inst, chid, dir);
+	if (cur_val != lr_val)
+		return false;
+
+	return true;
+}
+
+const struct gt_conf gthe4_conf = {
+	.cfg_set_cdr = xhdmiphy_gthe4_set_cdr,
+	.check_pll_oprange = xhdmiphy_gthe4_check_pll_oprange,
+	.outdiv_ch_reconf = xhdmiphy_gthe4_outdiv_chreconf,
+	.clk_ch_reconf = xhdmiphy_gthe4_clkch_reconf,
+	.clk_cmn_reconf = xhdmiphy_gthe4_clkcmn_reconf,
+	.rxch_reconf = xhdmiphy_gthe4_rxch_reconf,
+	.txch_reconf = xhdmiphy_gthe4_txch_reconf,
+
+	 .cpll_divs = {
+		.m = gthe4_cpll_divs_m,
+		.n1 = gthe4_cpll_divs_n1,
+		.n2 = gthe4_cpll_divs_n2,
+		.d = gthe4_cpll_divs_d,
+	},
+	.qpll_divs = {
+		.m = gthe4_qpll_divs_m,
+		.n1 = gthe4_qpll_divs_n1,
+		.n2 = gthe4_qpll_divs_n2,
+		.d = gthe4_qpll_divs_d,
+	},
+};
+
+const struct gt_conf gtye5_conf = {
+	.rxch_reconf = xhdmiphy_gtye5_rxch_reconf,
+	.txch_reconf = xhdmiphy_gtye5_txch_reconf,
+	.cpll_divs = {
+		.m = NULL,
+		.n1 = NULL,
+		.n2 = NULL,
+		.d = NULL,
+	},
+	.qpll_divs = {
+		.m = NULL,
+		.n1 = NULL,
+		.n2 = NULL,
+		.d = NULL,
+	},
+};
diff --git a/drivers/phy/xilinx/xhdmiphy_mmcm.c b/drivers/phy/xilinx/xhdmiphy_mmcm.c
new file mode 100644
index 000000000..6b86d7478
--- /dev/null
+++ b/drivers/phy/xilinx/xhdmiphy_mmcm.c
@@ -0,0 +1,1862 @@
+// SPDX-License-Identifier: GPL-2.0-only
+
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <linux/string.h>
+#include "xhdmiphy.h"
+
+struct gthdmi_chars {
+	u64 dru_linerate;
+	u64 tx_mmcm_fvcomin;
+	u64 tx_mmcm_fvcomax;
+	u64 rx_mmcm_fvcomin;
+	u64 rx_mmcm_fvcomax;
+	u32 qpll0_refclk_min;
+	u32 qpll1_refclk_min;
+	u32 cpll_refclk_min;
+	u16 tx_mmcm_scale;
+	u16 rx_mmcm_scale;
+	u16 pll_scale;
+};
+
+static const struct gthdmi_chars gthe4hdmi_chars = {
+	.dru_linerate = XHDMIPHY_HDMI_GTHE4_DRU_LRATE,
+	.pll_scale = XHDMIPHY_HDMI_GTHE4_PLL_SCALE,
+	.qpll0_refclk_min = XHDMIPHY_HDMI_GTHE4_QPLL0_REFCLK_MIN,
+	.qpll1_refclk_min = XHDMIPHY_HDMI_GTHE4_QPLL1_REFCLK_MIN,
+	.cpll_refclk_min = XHDMIPHY_HDMI_GTHE4_CPLL_REFCLK_MIN,
+	.tx_mmcm_scale = XHDMIPHY_HDMI_GTHE4_TX_MMCM_SCALE,
+	.tx_mmcm_fvcomin = XHDMIPHY_HDMI_GTHE4_TX_MMCM_FVCO_MIN,
+	.tx_mmcm_fvcomax = XHDMIPHY_HDMI_GTHE4_TX_MMCM_FVCO_MAX,
+	.rx_mmcm_scale = XHDMIPHY_HDMI_GTHE4_RX_MMCM_SCALE,
+	.rx_mmcm_fvcomin = XHDMIPHY_HDMI_GTHE4_RX_MMCM_FVCO_MIN,
+	.rx_mmcm_fvcomax = XHDMIPHY_HDMI_GTHE4_RX_MMCM_FVCO_MAX,
+};
+
+static const struct gthdmi_chars gtye4hdmi_chars = {
+	.dru_linerate = XHDMIPHY_HDMI_GTYE4_DRU_LRATE,
+	.pll_scale = XHDMIPHY_HDMI_GTYE4_PLL_SCALE,
+	.qpll0_refclk_min = XHDMIPHY_HDMI_GTYE4_QPLL0_REFCLK_MIN,
+	.qpll1_refclk_min = XHDMIPHY_HDMI_GTYE4_QPLL1_REFCLK_MIN,
+	.cpll_refclk_min = XHDMIPHY_HDMI_GTYE4_CPLL_REFCLK_MIN,
+	.tx_mmcm_scale = XHDMIPHY_HDMI_GTYE4_TX_MMCM_SCALE,
+	.tx_mmcm_fvcomin = XHDMIPHY_HDMI_GTYE4_TX_MMCM_FVCO_MIN,
+	.tx_mmcm_fvcomax = XHDMIPHY_HDMI_GTYE4_TX_MMCM_FVCO_MAX,
+	.rx_mmcm_scale = XHDMIPHY_HDMI_GTYE4_RX_MMCM_SCALE,
+	.rx_mmcm_fvcomin = XHDMIPHY_HDMI_GTYE4_RX_MMCM_FVCO_MIN,
+	.rx_mmcm_fvcomax = XHDMIPHY_HDMI_GTYE4_RX_MMCM_FVCO_MAX,
+};
+
+static const struct gthdmi_chars gtye5hdmi_chars = {
+	.dru_linerate = XHDMIPHY_HDMI_GTYE5_DRU_LRATE,
+	.pll_scale = XHDMIPHY_HDMI_GTYE5_PLL_SCALE,
+	.qpll0_refclk_min = XHDMIPHY_HDMI_GTYE5_LCPLL_REFCLK_MIN,
+	.qpll1_refclk_min = XHDMIPHY_HDMI_GTYE5_RPLL_REFCLK_MIN,
+	.cpll_refclk_min = 0,
+	.tx_mmcm_scale = XHDMIPHY_HDMI_GTYE5_TX_MMCM_SCALE,
+	.tx_mmcm_fvcomin = XHDMIPHY_HDMI_GTYE5_TX_MMCM_FVCO_MIN,
+	.tx_mmcm_fvcomax = XHDMIPHY_HDMI_GTYE5_TX_MMCM_FVCO_MAX,
+	.rx_mmcm_scale = XHDMIPHY_HDMI_GTYE5_RX_MMCM_SCALE,
+	.rx_mmcm_fvcomin = XHDMIPHY_HDMI_GTYE5_RX_MMCM_FVCO_MIN,
+	.rx_mmcm_fvcomax = XHDMIPHY_HDMI_GTYE5_RX_MMCM_FVCO_MAX,
+};
+
+/*
+ * Following are the MMCM Parameter values for each rate.
+ * Based on the MAX rate config in PHY the MMCM
+ * should be programmed to generate the vid clk in
+ * FRL mode
+ */
+static struct xhdmiphy_mmcm gthe4_gtye4_mmcm[] = {
+	{0, 3, 1, 8, 8, 8}, /* 3x3 G -> 150Mhz */
+	{1, 49, 16, 7, 7, 7}, /* 6x3 G -> 175Mhz */
+	{2, 54, 16, 6, 6, 6}, /* 6x4 G -> 225Mhz */
+	{3, 3, 1, 4, 4, 4}, /* 8 G -> 300Mhz */
+	{4, 15, 4, 4, 4, 4}, /* 10 G -> 375Mhz */
+	{5, 3, 1, 3, 3, 3} /* 12 G -> (400 * 3/1) / 3 -> 400Mhz */
+};
+
+static struct xhdmiphy_mmcm gtye5_mmcm[] = {
+	{0, 3, 1, 8, 8, 8}, /* 12 G -> (400 * 3/1) / 3 -> 400Mhz */
+	{1, 49, 16, 7, 7, 7}, /* 10 G -> 375Mhz */
+	{2, 54, 16, 6, 6, 6}, /* 8 G -> 300Mhz */
+	{3, 3, 1, 4, 4, 4}, /* 6x4 G -> 225Mhz */
+	{4, 15, 4, 4, 4, 4}, /* 6x3 G -> 175Mhz */
+	{5, 3, 1, 3, 3, 3} /* 3x3 G -> 150Mhz */
+};
+
+static u16 mmcme4_lockreg1_enc[37] = {0x0, 0x03e8, 0x03e8, 0x03e8, 0x03e8,
+				      0x03e8, 0x03e8, 0x03e8, 0x03e8, 0x03e8,
+				      0x03e8, 0x0384, 0x0339, 0x02ee, 0x02bc,
+				      0x028a, 0x0271, 0x023f, 0x0226, 0x020d,
+				      0x01f4, 0x01db, 0x01c2, 0x01a9, 0x0190,
+				      0x0190, 0x0177, 0x015e, 0x015e, 0x0145,
+				      0x0145, 0x012c, 0x012c, 0x012c, 0x0113,
+				      0x0113, 0x0113};
+
+static u16 mmcme4_lockreg2_enc[11] = {0x7c01, 0x1801, 0x1801, 0x2001, 0x2c01,
+				      0x3801, 0x4401, 0x4c01, 0x5801, 0x6401,
+				      0x7001};
+
+static u16 mmcme4_lockreg3_enc[11] = {0x7fe9, 0x1be9, 0x1be9, 0x23e9, 0x2fe9,
+				      0x3be9, 0x47e9, 0x4fe9, 0x5be9, 0x67e9,
+				      0x73e9};
+
+static struct xhdmiphy_mmcm *get_mmcm_conf(struct xhdmiphy_dev *inst)
+{
+	if (inst->conf.gt_type != XHDMIPHY_GTYE5)
+		return gthe4_gtye4_mmcm;
+
+	return gtye5_mmcm;
+}
+
+static const struct gthdmi_chars *get_gthdmi_ptr(struct xhdmiphy_dev *inst)
+{
+	if (inst->conf.gt_type == XHDMIPHY_GTHE4)
+		return &gthe4hdmi_chars;
+	else if (inst->conf.gt_type == XHDMIPHY_GTYE4)
+		return &gtye4hdmi_chars;
+	else if (inst->conf.gt_type == XHDMIPHY_GTYE5)
+		return &gtye5hdmi_chars;
+
+	return NULL;
+}
+
+/**
+ * xhdmiphy_mmcme5_div_enc - This function returns the DRP encoding of
+ * clkfbout_mult optimized for: Phase = 0; Dutycycle = 0.5; No Fractional
+ * division. The calculations are based on XAPP888
+ *
+ * @div_type:	divider type to be encoded
+ * @div:	div is the divider to be encoded
+ *
+ * @return:	- Encoded Value for clk_reg1 [15: 0]
+ *		- Encoded Value for clk_reg2 [31:16]
+ */
+static u32 xhdmiphy_mmcme5_div_enc(enum mmcm_divs div_type, u16 div)
+{
+	u32 clk_reg1, clk_reg2;
+	u16 divde = div;
+	u8 hi_time, lo_time;
+
+	if (div_type == XHDMIPHY_MMCM_CLKOUT_DIVIDE) {
+		if (div % 2)
+			divde = (div / 2);
+		else
+			divde = (div / 2) + (div % 2);
+	}
+
+	hi_time = divde / 2;
+	lo_time = hi_time;
+
+	clk_reg2 = lo_time & 0xff;
+	clk_reg2 |= (hi_time & 0xff) << 8;
+
+	if (div_type == XHDMIPHY_MMCM_CLKFBOUT_MULT_F) {
+		clk_reg1 = (divde % 2) ? 0x00001700 : 0x00001600;
+	} else {
+		if (div % 2)
+			clk_reg1 = (divde % 2) ? 0x0000bb00 : 0x0000ba00;
+		else
+			clk_reg1 = (divde % 2) ? 0x00001b00 : 0x00001a00;
+	}
+
+	return (clk_reg2 << 16) | clk_reg1;
+}
+
+/**
+ * xhdmiphy_mmcme5_cpres_enc - This function returns the DRP encoding of CP and
+ * Res optimized for: Phase = 0; Dutycycle = 0.5; BW = low; No Fractional
+ * division
+ *
+ * @mult:	mult is the divider to be encoded
+ *
+ * @return:	- [3:0] CP
+ *		- [20:17] RES
+ *
+ * note: For more details about DRP encoding values , refer GT user guide
+ */
+static u32 xhdmiphy_mmcme5_cpres_enc(u16 mult)
+{
+	u16 cp, res;
+
+	switch (mult) {
+	case 4:
+		cp = 5; res = 15;
+	break;
+	case 5:
+		cp = 6; res = 15;
+	break;
+	case 6:
+		cp = 7; res = 15;
+	break;
+	case 7:
+		cp = 13; res = 15;
+	break;
+	case 8:
+		cp = 14; res = 15;
+	break;
+	case 9:
+		cp = 15; res = 15;
+	break;
+	case 10:
+		cp = 14; res = 7;
+	break;
+	case 11:
+		cp = 15; res = 7;
+	break;
+	case 12 ... 13:
+		cp = 15; res = 11;
+	break;
+	case 14:
+		cp = 15; res = 13;
+	break;
+	case 15:
+		cp = 15; res = 3;
+	break;
+	case 16 ... 17:
+		cp = 14; res = 5;
+	break;
+	case 18 ... 19:
+		cp = 15; res = 5;
+	break;
+	case 20 ... 21:
+		cp = 15; res = 9;
+		break;
+	case 22 ... 23:
+		cp = 14; res = 14;
+		break;
+	case 24 ... 26:
+		cp = 15; res = 14;
+		break;
+	case 27 ... 28:
+		cp = 14; res = 1;
+		break;
+	case 29 ... 33:
+		cp = 15; res = 1;
+		break;
+	case 34 ... 37:
+		cp = 14; res = 6;
+		break;
+	case 38 ... 44:
+		cp = 15; res = 6;
+		break;
+	case 45 ... 57:
+		cp = 15; res = 10;
+		break;
+	case 58 ... 63:
+		cp = 13; res = 12;
+		break;
+	case 64 ... 70:
+		cp = 14; res = 12;
+		break;
+	case 71 ... 86:
+		cp = 15; res = 12;
+		break;
+	case 87 ... 93:
+		cp = 14; res = 2;
+		break;
+	case 94:
+		cp = 5; res = 15;
+		break;
+	case 95:
+		cp = 6; res = 15;
+		break;
+	case 96:
+		cp = 7; res = 15;
+		break;
+	case 97:
+		cp = 13; res = 15;
+		break;
+	case 98:
+		cp = 14; res = 15;
+		break;
+	case 99:
+		cp = 15; res = 15;
+		break;
+	case 100:
+		cp = 14; res = 7;
+		break;
+	case 101:
+		cp = 15; res = 7;
+		break;
+	case 102 ... 103:
+		cp = 15; res = 11;
+		break;
+	case 104:
+		cp = 15; res = 13;
+		break;
+	case 105:
+		cp = 15; res = 3;
+		break;
+	case 106 ... 107:
+		cp = 14; res = 5;
+		break;
+	case 108 ... 109:
+		cp = 15; res = 5;
+		break;
+	case 110 ... 111:
+		cp = 15; res = 9;
+		break;
+	case 112 ... 113:
+		cp = 14; res = 14;
+		break;
+	case 114 ... 116:
+		cp = 15; res = 14;
+		break;
+	case 117 ... 118:
+		cp = 14; res = 1;
+		break;
+	case 119 ... 123:
+		cp = 15; res = 1;
+		break;
+	case 124 ... 127:
+		cp = 14; res = 6;
+		break;
+	case 128 ... 134:
+		cp = 15; res = 6;
+		break;
+	case 135 ... 147:
+		cp = 15; res = 10;
+		break;
+	case 148 ... 153:
+		cp = 13; res = 12;
+		break;
+	case 154 ... 160:
+		cp = 14; res = 12;
+		break;
+	case 161 ... 176:
+		cp = 15; res = 12;
+		break;
+	case 177 ... 183:
+		cp = 14; res = 2;
+		break;
+	case 184 ... 200:
+		cp = 14; res = 4;
+		break;
+	case 201 ... 273:
+		cp = 15; res = 4;
+		break;
+	case 274 ... 300:
+		cp = 13; res = 8;
+		break;
+	case 301 ... 325:
+		cp = 14; res = 8;
+		break;
+	case 326 ... 432:
+		cp = 15; res = 8;
+		break;
+	default:
+		cp = 13; res = 8;
+		break;
+	}
+
+	return ((res & 0xf) << 17) | ((cp & 0xf) | 0x160);
+}
+
+/**
+ * xhdmiphy_mmcme5_lockreg12_enc - This function returns the DRP encoding of
+ * lock Reg1 & Reg2 optimized for: Phase = 0; Dutycycle = 0.5; BW = low;
+ * No Fractional division
+ *
+ * @mult:	mult is the divider to be encoded
+ *
+ * @return:	- [15:0] lock_1 Reg
+ *		- [31:16] lock_2 Reg
+ *
+ * note: For more details about DRP encoding values , refer GT user guide
+ */
+static u32 xhdmiphy_mmcme5_lockreg12_enc(u16 mult)
+{
+	u16 lock_1, lock_2, lock_ref_dly, lock_fb_dly, lock_cnt;
+	u16 lock_sat_high = 9;
+
+	switch (mult) {
+	case 4:
+		lock_ref_dly = 4;
+		lock_fb_dly = 4;
+		lock_cnt = 1000;
+		break;
+	case 5:
+		lock_ref_dly = 6;
+		lock_fb_dly = 6;
+		lock_cnt = 1000;
+		break;
+	case 6 ... 7:
+		lock_ref_dly = 7;
+		lock_fb_dly = 7;
+		lock_cnt = 1000;
+		break;
+	case 8:
+		lock_ref_dly = 9;
+		lock_fb_dly = 9;
+		lock_cnt = 1000;
+		break;
+	case 9 ... 10:
+		lock_ref_dly = 10;
+		lock_fb_dly = 10;
+		lock_cnt = 1000;
+		break;
+	case 11:
+		lock_ref_dly = 11;
+		lock_fb_dly = 11;
+		lock_cnt = 1000;
+		break;
+	case 12:
+		lock_ref_dly = 13;
+		lock_fb_dly = 13;
+		lock_cnt = 1000;
+		break;
+	case 13 ... 14:
+		lock_ref_dly = 14;
+		lock_fb_dly = 14;
+		lock_cnt = 1000;
+		break;
+	case 15:
+		lock_ref_dly = 16;
+		lock_fb_dly = 16;
+		lock_cnt = 900;
+		break;
+	case 16 ... 17:
+		lock_ref_dly = 16;
+		lock_fb_dly = 16;
+		lock_cnt = 825;
+		break;
+	case 18:
+		lock_ref_dly = 16;
+		lock_fb_dly = 16;
+		lock_cnt = 750;
+		break;
+	case 19 ... 20:
+		lock_ref_dly = 16;
+		lock_fb_dly = 16;
+		lock_cnt = 700;
+		break;
+	case 21:
+		lock_ref_dly = 16;
+		lock_fb_dly = 16;
+		lock_cnt = 650;
+		break;
+	case 22 ... 23:
+		lock_ref_dly = 16;
+		lock_fb_dly = 16;
+		lock_cnt = 625;
+		break;
+	case 24:
+		lock_ref_dly = 16;
+		lock_fb_dly = 16;
+		lock_cnt = 575;
+		break;
+	case 25:
+		lock_ref_dly = 16;
+		lock_fb_dly = 16;
+		lock_cnt = 550;
+		break;
+	case 26 ... 28:
+		lock_ref_dly = 16;
+		lock_fb_dly = 16;
+		lock_cnt = 525;
+		break;
+	case 29 ... 30:
+		lock_ref_dly = 16;
+		lock_fb_dly = 16;
+		lock_cnt = 475;
+		break;
+	case 31:
+		lock_ref_dly = 16;
+		lock_fb_dly = 16;
+		lock_cnt = 450;
+		break;
+	case 32 ... 33:
+		lock_ref_dly = 16;
+		lock_fb_dly = 16;
+		lock_cnt = 425;
+		break;
+	case 34 ... 36:
+		lock_ref_dly = 16;
+		lock_fb_dly = 16;
+		lock_cnt = 400;
+		break;
+	case 37:
+		lock_ref_dly = 16;
+		lock_fb_dly = 16;
+		lock_cnt = 375;
+		break;
+	case 38 ... 40:
+		lock_ref_dly = 16;
+		lock_fb_dly = 16;
+		lock_cnt = 350;
+		break;
+	case 41 ... 43:
+		lock_ref_dly = 16;
+		lock_fb_dly = 16;
+		lock_cnt = 325;
+		break;
+	case 44 ... 47:
+		lock_ref_dly = 16;
+		lock_fb_dly = 16;
+		lock_cnt = 300;
+		break;
+	case 48 ... 51:
+		lock_ref_dly = 16;
+		lock_fb_dly = 16;
+		lock_cnt = 275;
+		break;
+	case 52 ... 205:
+		lock_ref_dly = 16;
+		lock_fb_dly = 16;
+		lock_cnt = 950;
+		break;
+	case 206 ... 432:
+		lock_ref_dly = 16;
+		lock_fb_dly = 16;
+		lock_cnt = 925;
+		break;
+	default:
+		lock_ref_dly = 16;
+		lock_fb_dly = 16;
+		lock_cnt = 250;
+		break;
+	}
+
+	lock_1 = ((lock_fb_dly & 0x1f) << 10) | (lock_cnt & 0x3ff);
+
+	lock_2 = ((lock_ref_dly & 0x1f) << 10) | (lock_sat_high & 0x3ff);
+
+	return (lock_2 << 16) | lock_1;
+}
+
+/**
+ * xhdmiphy_mmcme4_div_enc - This function returns the DRP encoding of
+ * clkfbout_mult optimized for: Phase = 0; Dutycycle = 0.5; No Fractional
+ * division The calculations are based on XAPP888
+ *
+ * @div_type:	div is the divider to be encoded
+ * @div:	divider value
+ *
+ * @return:	- Encoded Value for clk_reg1 [31: 0]
+ *		- Encoded Value for clk_reg2 [63:32]
+ */
+static u32 xhdmiphy_mmcme4_div_enc(enum mmcm_divs div_type, u8 div)
+{
+	u32 clk_reg1, clk_reg2;
+	u8 hi_time, lo_time;
+
+	if (div == 1) {
+		clk_reg1 = 0x00001041;
+		clk_reg2 = 0x00C00000;
+	} else {
+		hi_time = div / 2;
+		lo_time = div - hi_time;
+		clk_reg1 = lo_time & 0x3f;
+		clk_reg1 |= (hi_time & 0x3f) << 6;
+		clk_reg1 |= (div_type == XHDMIPHY_MMCM_DIVCLK_DIVIDE) ?
+							0x0000 : 0x1000;
+		clk_reg2 = (div % 2) ? 0x00800000 : 0x00000000;
+	}
+
+	return clk_reg2 | clk_reg1;
+}
+
+/**
+ * xhdmiphy_mmcme4_filtreg1_enc - This function returns the drp encoding of
+ * filtereg1 optimized for: phase = 0; dutycycle = 0.5; BW = low; no fractional
+ * division
+ *
+ * @mult:	mult is the divider to be encoded
+ *
+ * @return:	- encoded value
+ *
+ * note: For more details about DRP encoding values , refer GT user guide
+ */
+static u16 xhdmiphy_mmcme4_filtreg1_enc(u8 mult)
+{
+	u16 drp_enc;
+
+	switch (mult) {
+	case 1: case 2: case 3:
+	case 4: case 5: case 6:
+	case 7: case 8: case 9:
+	case 10: case 11: case 12:
+	case 13: case 14:
+	case 16:
+		drp_enc = 0x0900;
+		break;
+	case 15:
+		drp_enc = 0x1000;
+		break;
+		break;
+	case 17: case 19: case 20:
+	case 29: case 30: case 31:
+	case 38: case 39: case 40:
+	case 41: case 78: case 79:
+	case 80: case 81: case 82:
+	case 83: case 84:
+	case 85:
+		drp_enc = 0x9800;
+		break;
+	case 26: case 27: case 28:
+	case 71: case 72: case 73:
+	case 74: case 75: case 76:
+	case 77: case 120: case 121:
+	case 122: case 123: case 124:
+	case 125: case 126: case 127:
+	case 128:
+		drp_enc = 0x9100;
+		break;
+	default:
+		drp_enc = 0x9900;
+		break;
+	}
+
+	return drp_enc;
+}
+
+/**
+ * xhdmiphy_mmcme4_filtreg2_enc - This function returns the drp encoding of
+ * filter reg1 optimized for: phase = 0; dutycycle = 0.5; bw = low; no
+ * fractional division
+ *
+ * @mult:	mult is the divider to be encoded
+ *
+ * @return:	- encoded Value
+ *
+ * note: For more details about DRP encoding values , refer GT user guide
+ */
+static u16 xhdmiphy_mmcme4_filtreg2_enc(u8 mult)
+{
+	u16 drp_enc;
+
+	switch (mult) {
+	case 1: case 2:
+		drp_enc = 0x9990;
+	break;
+	case 3:
+		drp_enc = 0x9190;
+		break;
+	case 4:
+		drp_enc = 0x1190;
+		break;
+	case 5:
+		drp_enc = 0x8190;
+		break;
+	case 6: case 7:
+		drp_enc = 0x9890;
+		break;
+	case 8:
+		drp_enc = 0x0190;
+		break;
+	case 9: case 10: case 11:
+	case 15: case 17: case 18:
+		drp_enc = 0x1890;
+		break;
+	case 12: case 13: case 14:
+	case 19: case 20: case 21:
+	case 22: case 23: case 24:
+	case 25:
+		drp_enc = 0x8890;
+		break;
+	case 16: case 26: case 27:
+	case 28: case 29: case 30:
+	case 31: case 32: case 33:
+	case 34: case 35: case 36:
+	case 37:
+		drp_enc = 0x9090;
+		break;
+	case 38: case 39: case 40:
+	case 41: case 42: case 43:
+	case 44: case 45: case 46:
+	case 47: case 48: case 49:
+	case 50: case 51: case 52:
+	case 53: case 54: case 55:
+	case 56: case 57: case 58:
+	case 59: case 60: case 61:
+	case 62:
+		drp_enc = 0x0890;
+		break;
+	case 120: case 121: case 122:
+	case 123: case 124: case 125:
+	case 126: case 127: case 128:
+		drp_enc = 0x8090;
+		break;
+	default:
+		drp_enc = 0x1090;
+		break;
+	}
+
+	return drp_enc;
+}
+
+static u16 xhdmiphy_mmcme4_lockreg1_enc(u8 mult)
+{
+	u16 drp_enc;
+
+	if (mult >= 1 && mult <= 36)
+		drp_enc = mmcme4_lockreg1_enc[mult];
+	else
+		drp_enc = 0x00fa;
+
+	return drp_enc;
+}
+
+/**
+ * xhdmiphy_mmcme4_lockreg2_enc - This function returns the drp encoding of
+ * lockreg2 optimized for: phase = 0; dutycycle = 0.5; no fractional division
+ *
+ * @mult:	mult is the divider to be encoded
+ *
+ * @return:	- encoded Value
+ */
+static u16 xhdmiphy_mmcme4_lockreg2_enc(u8 mult)
+{
+	if (mult >= 1 && mult <= 10)
+		return mmcme4_lockreg2_enc[mult];
+
+	return mmcme4_lockreg2_enc[0];
+}
+
+static u16 xhdmiphy_mmcme4_lockreg3_enc(u8 mult)
+{
+	if (mult >= 1 && mult <= 10)
+		return mmcme4_lockreg3_enc[mult];
+
+	return mmcme4_lockreg3_enc[0];
+}
+
+/**
+ * xhdmiphy_wr_mmcm5_params - This function will write the mixed-mode clock
+ * manager (MMCM) values currently stored in the driver's instance structure to
+ * hardware
+ *
+ * @inst:	inst is a pointer to the xhdmiphy core instance
+ * @dir:	dir is an indicator for TX or RX
+ *
+ * @return:	- 0 if the MMCM write was successful
+ *		- 1 otherwise, if the configuration success bit did not go low
+ */
+static bool xhdmiphy_wr_mmcm5_params(struct xhdmiphy_dev *inst, enum dir dir)
+{
+	struct xhdmiphy_mmcm *mmcm_params;
+	u32 drp_val32;
+	u16 drp_rdval;
+	u8 chid;
+
+	chid = (dir == XHDMIPHY_DIR_TX) ? XHDMIPHY_CHID_TXMMCM :
+		       XHDMIPHY_CHID_RXMMCM;
+
+	mmcm_params = &inst->quad.mmcm[dir];
+
+	/* check parameters if has been initialized */
+	if (!mmcm_params->divclk_divide && !mmcm_params->clkfbout_mult &&
+	    !mmcm_params->clkout0_div && !mmcm_params->clkout1_div &&
+	    !mmcm_params->clkout2_div)
+		return 1;
+
+	/* write CLKFBOUT_1 & CLKFBOUT_2 values */
+	drp_val32 = xhdmiphy_mmcme5_div_enc(XHDMIPHY_MMCM_CLKFBOUT_MULT_F,
+					    mmcm_params->clkfbout_mult);
+	xhdmiphy_drpwr(inst, chid, XHDMIPHY_MMCM5_DRP_CLKFBOUT_1_REG,
+		       (u16)(drp_val32 & XHDMIPHY_MMCM5_WRITE_VAL));
+	xhdmiphy_drpwr(inst, chid, XHDMIPHY_MMCM5_DRP_CLKFBOUT_2_REG,
+		       (u16)((drp_val32 >> 16) & XHDMIPHY_MMCM5_WRITE_VAL));
+
+	/* write DIVCLK_DIVIDE & DESKEW_2 values */
+	drp_val32 = xhdmiphy_mmcme5_div_enc(XHDMIPHY_MMCM_DIVCLK_DIVIDE,
+					    mmcm_params->divclk_divide);
+	xhdmiphy_drpwr(inst, chid, XHDMIPHY_MMCM5_DRP_DIVCLK_DIVIDE_REG,
+		       (u16)((drp_val32 >> 16) & XHDMIPHY_MMCM5_WRITE_VAL));
+	xhdmiphy_drpwr(inst, chid, XHDMIPHY_MMCM5_DRP_DESKEW_REG,
+		       ((mmcm_params->divclk_divide == 0) ? 0x0000 :
+		       ((mmcm_params->divclk_divide % 2) ? 0x0400 : 0x0000)));
+
+	/* write CLKOUT0_1 & CLKOUT0_2 values */
+	drp_val32 = xhdmiphy_mmcme5_div_enc(XHDMIPHY_MMCM_CLKOUT_DIVIDE,
+					    mmcm_params->clkout0_div);
+	xhdmiphy_drpwr(inst, chid, XHDMIPHY_MMCM5_DRP_CLKOUT0_REG1,
+		       (u16)(drp_val32 & XHDMIPHY_MMCM5_WRITE_VAL));
+	xhdmiphy_drpwr(inst, chid, XHDMIPHY_MMCM5_DRP_CLKOUT0_REG2,
+		       (u16)((drp_val32 >> 16) & XHDMIPHY_MMCM5_WRITE_VAL));
+
+	/* write CLKOUT1_1 & CLKOUT1_2 values */
+	drp_val32 = xhdmiphy_mmcme5_div_enc(XHDMIPHY_MMCM_CLKOUT_DIVIDE,
+					    mmcm_params->clkout1_div);
+	xhdmiphy_drpwr(inst, chid, XHDMIPHY_MMCM5_DRP_CLKOUT1_REG1,
+		       (u16)(drp_val32 & XHDMIPHY_MMCM5_WRITE_VAL));
+	xhdmiphy_drpwr(inst, chid, XHDMIPHY_MMCM5_DRP_CLKOUT1_REG2,
+		       (u16)((drp_val32 >> 16) & XHDMIPHY_MMCM5_WRITE_VAL));
+
+	/* write CLKOUT2_1 & CLKOUT2_2 values */
+	drp_val32 = xhdmiphy_mmcme5_div_enc(XHDMIPHY_MMCM_CLKOUT_DIVIDE,
+					    mmcm_params->clkout2_div);
+	xhdmiphy_drpwr(inst, chid, XHDMIPHY_MMCM5_DRP_CLKOUT2_REG1,
+		       (u16)(drp_val32 & XHDMIPHY_MMCM5_WRITE_VAL));
+	xhdmiphy_drpwr(inst, chid, XHDMIPHY_MMCM5_DRP_CLKOUT2_REG2,
+		       (u16)((drp_val32 >> 16) & XHDMIPHY_MMCM5_WRITE_VAL));
+
+	/* write CP & RES values */
+	drp_val32 = xhdmiphy_mmcme5_cpres_enc(mmcm_params->clkfbout_mult);
+	drp_rdval = xhdmiphy_drprd(inst, chid, XHDMIPHY_MMCM5_DRP_CP_REG1,
+				   &drp_rdval);
+	drp_rdval &= ~(XHDMIPHY_MMCM5_CP_RES_MASK);
+
+	xhdmiphy_drpwr(inst, chid, XHDMIPHY_MMCM5_DRP_CP_REG1,
+		       (u16)((drp_val32 & XHDMIPHY_MMCM5_CP_RES_MASK) |
+			     drp_rdval));
+
+	drp_rdval = xhdmiphy_drprd(inst, chid, XHDMIPHY_MMCM5_DRP_RES_REG1,
+				   &drp_rdval);
+	drp_rdval &= ~(XHDMIPHY_MMCM5_RES_MASK);
+	xhdmiphy_drpwr(inst, chid, XHDMIPHY_MMCM5_DRP_RES_REG1,
+		       (u16)(((drp_val32 >> 15) & XHDMIPHY_MMCM5_RES_MASK) |
+			      drp_rdval));
+
+	/* write lock reg1 & reg2 values */
+	drp_val32 = xhdmiphy_mmcme5_lockreg12_enc(mmcm_params->clkfbout_mult);
+	/* lock_1 */
+	drp_rdval = xhdmiphy_drprd(inst, chid, XHDMIPHY_MMCM5_DRP_LOCK_REG1,
+				   &drp_rdval);
+	drp_rdval &= ~(XHDMIPHY_MMCM5_LOCK1_MASK1);
+	xhdmiphy_drpwr(inst, chid, XHDMIPHY_MMCM5_DRP_LOCK_REG1,
+		       (u16)((drp_val32 & XHDMIPHY_MMCM5_LOCK1_MASK2) |
+			     drp_rdval));
+
+	/* lock_2 */
+	drp_rdval = xhdmiphy_drprd(inst, chid, XHDMIPHY_MMCM5_DRP_LOCK_REG2,
+				   &drp_rdval);
+	drp_rdval &= ~(XHDMIPHY_MMCM5_LOCK1_MASK1);
+	xhdmiphy_drpwr(inst, chid, XHDMIPHY_MMCM5_DRP_LOCK_REG2,
+		       (u16)(((drp_val32 >> 16) & XHDMIPHY_MMCM5_LOCK1_MASK2) |
+			     drp_rdval));
+
+	return 0;
+}
+
+/**
+ * xhdmiphy_wr_mmcm4_params - This function will write the mixed-mode clock
+ * manager (mmcm) values currently stored in the driver's instance structure
+ * to hardware .
+ *
+ * @inst:	inst is a pointer to the xhdmiphy core instance
+ * @dir:	dir is an indicator for tX or rX
+ *
+ * @return:	- 0 if the mmcm write was successful
+ *		- 1 otherwise, if the configuration success bit did not go low
+ */
+static bool xhdmiphy_wr_mmcm4_params(struct xhdmiphy_dev *inst, enum dir dir)
+{
+	struct xhdmiphy_mmcm *mmcm_params;
+	u32 drp_val32;
+	u16 drp_val;
+	u8 chid;
+
+	chid = (dir == XHDMIPHY_DIR_TX) ? XHDMIPHY_CHID_TXMMCM :
+					  XHDMIPHY_CHID_RXMMCM;
+	mmcm_params = &inst->quad.mmcm[dir];
+
+	if (!mmcm_params->divclk_divide && !mmcm_params->clkfbout_mult &&
+	    !mmcm_params->clkout0_div && !mmcm_params->clkout1_div &&
+	    !mmcm_params->clkout2_div) {
+		return 1;
+	}
+
+	/* write power register Value */
+	xhdmiphy_drpwr(inst, chid, XHDMIPHY_MMCM4_PWR_REG,
+		       XHDMIPHY_MMCM4_WRITE_VAL);
+
+	/* write CLKFBOUT reg1 & reg2 values */
+	drp_val32 = xhdmiphy_mmcme4_div_enc(XHDMIPHY_MMCM_CLKFBOUT_MULT_F,
+					    mmcm_params->clkfbout_mult);
+	xhdmiphy_drpwr(inst, chid, XHDMIPHY_MMCM4_CLKFBOUT_REG1,
+		       (u16)(drp_val32 & XHDMIPHY_MMCM4_WRITE_VAL));
+	xhdmiphy_drpwr(inst, chid, XHDMIPHY_MMCM4_CLKFBOUT_REG2,
+		       (u16)((drp_val32 >> 16) & XHDMIPHY_MMCM4_WRITE_VAL));
+
+	/* write gg value */
+	drp_val32 = xhdmiphy_mmcme4_div_enc(XHDMIPHY_MMCM_DIVCLK_DIVIDE,
+					    mmcm_params->divclk_divide);
+	xhdmiphy_drpwr(inst, chid, XHDMIPHY_MMCM4_DIVCLK_DIV_REG,
+		       (u16)(drp_val32 & XHDMIPHY_MMCM4_WRITE_VAL));
+
+	/* write CLKOUT0 reg1 & reg2 values */
+	drp_val32 = xhdmiphy_mmcme4_div_enc(XHDMIPHY_MMCM_CLKOUT_DIVIDE,
+					    mmcm_params->clkout0_div);
+	xhdmiphy_drpwr(inst, chid, XHDMIPHY_MMCM4_CLKOUT0_REG1,
+		       (u16)(drp_val32 & XHDMIPHY_MMCM4_WRITE_VAL));
+	xhdmiphy_drpwr(inst, chid, XHDMIPHY_MMCM4_CLKOUT0_REG2,
+		       (u16)((drp_val32 >> 16) & XHDMIPHY_MMCM4_WRITE_VAL));
+
+	drp_val32 = xhdmiphy_mmcme4_div_enc(XHDMIPHY_MMCM_CLKOUT_DIVIDE,
+					    mmcm_params->clkout1_div);
+	xhdmiphy_drpwr(inst, chid, XHDMIPHY_MMCM4_CLKOUT1_REG1,
+		       (u16)(drp_val32 & XHDMIPHY_MMCM4_WRITE_VAL));
+	xhdmiphy_drpwr(inst, chid, XHDMIPHY_MMCM4_CLKOUT1_REG2,
+		       (u16)((drp_val32 >> 16) & XHDMIPHY_MMCM4_WRITE_VAL));
+
+	drp_val32 = xhdmiphy_mmcme4_div_enc(XHDMIPHY_MMCM_CLKOUT_DIVIDE,
+					    mmcm_params->clkout2_div);
+	xhdmiphy_drpwr(inst, chid, XHDMIPHY_MMCM4_CLKOUT2_REG1,
+		       (u16)(drp_val32 & XHDMIPHY_MMCM4_WRITE_VAL));
+	xhdmiphy_drpwr(inst, chid, XHDMIPHY_MMCM4_CLKOUT2_REG2,
+		       (u16)((drp_val32 >> 16) & XHDMIPHY_MMCM4_WRITE_VAL));
+
+	drp_val = xhdmiphy_mmcme4_lockreg1_enc(mmcm_params->clkfbout_mult);
+	xhdmiphy_drpwr(inst, chid, XHDMIPHY_MMCM4_DRP_LOCK_REG1, drp_val);
+
+	drp_val = xhdmiphy_mmcme4_lockreg2_enc(mmcm_params->clkfbout_mult);
+	xhdmiphy_drpwr(inst, chid, XHDMIPHY_MMCM4_DRP_LOCK_REG2, drp_val);
+
+	drp_val = xhdmiphy_mmcme4_lockreg3_enc(mmcm_params->clkfbout_mult);
+	xhdmiphy_drpwr(inst, chid, XHDMIPHY_MMCM4_DRP_LOCK_REG3, drp_val);
+
+	drp_val = xhdmiphy_mmcme4_filtreg1_enc(mmcm_params->clkfbout_mult);
+	xhdmiphy_drpwr(inst, chid, XHDMIPHY_MMCM4_DRP_FILTER_REG1, drp_val);
+
+	drp_val = xhdmiphy_mmcme4_filtreg2_enc(mmcm_params->clkfbout_mult);
+	xhdmiphy_drpwr(inst, chid, XHDMIPHY_MMCM4_DRP_FILTER_REG2, drp_val);
+
+	return 0;
+}
+
+void xhdmiphy_mmcm_start(struct xhdmiphy_dev *inst, enum dir dir)
+{
+	struct xhdmiphy_mmcm *mmcm_ptr;
+
+	if (dir == XHDMIPHY_DIR_RX)
+		mmcm_ptr = &inst->quad.rx_mmcm;
+	else
+		mmcm_ptr = &inst->quad.tx_mmcm;
+
+	/* check values if valid */
+	if (inst->conf.gt_type != XHDMIPHY_GTYE5) {
+		if (!(mmcm_ptr->clkout0_div > 0 &&
+		      mmcm_ptr->clkout0_div <= 128 &&
+		      mmcm_ptr->clkout1_div > 0 &&
+		      mmcm_ptr->clkout1_div <= 128 &&
+		      mmcm_ptr->clkout2_div > 0 &&
+		      mmcm_ptr->clkout2_div <= 128))
+			return;
+	} else {
+		if (!(mmcm_ptr->clkout0_div > 0 &&
+		      mmcm_ptr->clkout0_div <= 432 &&
+		      mmcm_ptr->clkout1_div > 0 &&
+		      mmcm_ptr->clkout1_div <= 432 &&
+		      mmcm_ptr->clkout2_div > 0 &&
+		      mmcm_ptr->clkout2_div <= 432))
+			return;
+	}
+
+	xhdmiphy_mmcm_reset(inst, dir, true);
+
+	if (inst->conf.gt_type != XHDMIPHY_GTYE5)
+		xhdmiphy_wr_mmcm4_params(inst, dir);
+	else
+		xhdmiphy_wr_mmcm5_params(inst, dir);
+
+	xhdmiphy_mmcm_reset(inst, dir, false);
+	xhdmiphy_mmcm_lock_en(inst, dir, false);
+}
+
+/**
+ * xhdmiphy_mmcm_lock_en - This function will reset the mixed-mode clock
+ * manager (MMCM) core.
+ *
+ * @inst:	inst is a pointer to the xhdmiphy core instance
+ * @dir:	dir is an indicator for TX or RX
+ * @enable:	Enable is an indicator whether to "Enable" the locked mask
+ *		if set to 1. If set to 0: reset, then disable
+ */
+void xhdmiphy_mmcm_lock_en(struct xhdmiphy_dev *inst, enum dir dir, u8 enable)
+{
+	u32 reg_off, reg_val;
+
+	if (dir == XHDMIPHY_DIR_TX)
+		reg_off = XHDMIPHY_MMCM_TXUSRCLK_CTRL_REG;
+	else
+		reg_off = XHDMIPHY_MMCM_RXUSRCLK_CTRL_REG;
+
+	/* Assert reset */
+	reg_val = xhdmiphy_read(inst, reg_off);
+	reg_val |= XHDMIPHY_MMCM_USRCLK_CTRL_LOCKED_MASK_MASK;
+	xhdmiphy_write(inst, reg_off, reg_val);
+
+	if (!enable) {
+		/* De-assert reset */
+		reg_val &= ~XHDMIPHY_MMCM_USRCLK_CTRL_LOCKED_MASK_MASK;
+		xhdmiphy_write(inst, reg_off, reg_val);
+	}
+}
+
+/**
+ * xhdmiphy_mmcm_param - This function sets the MMCM programming values based
+ * on max rate
+ *
+ * @inst:	inst is a pointer to the Hdmiphy core instance.
+ * @dir:	dir is an indicator for RX or TX.
+ *
+ * @return:	none
+ *
+ * note:	based on the MAX Rate set in the GUI, the MMCM values are
+ *		selected.
+ *		3 -> Max Rate selected in GUI is 3G
+ *		6 -> Max Rate selected in GUI is 6G
+ *		8 -> Max Rate selected in GUI is 8G
+ *		10 -> Max Rate selected in GUI is 10G
+ *		12 -> Max Rate selected in GUI in 12G
+ */
+void xhdmiphy_mmcm_param(struct xhdmiphy_dev *inst, enum dir dir)
+{
+	struct xhdmiphy_mmcm *mmcm_ptr, *conf;
+	u8 maxrate, num;
+
+	if (dir == XHDMIPHY_DIR_RX) {
+		mmcm_ptr = &inst->quad.rx_mmcm;
+		maxrate = inst->conf.rx_maxrate;
+		num = inst->conf.rx_channels;
+	} else {
+		mmcm_ptr = &inst->quad.tx_mmcm;
+		maxrate = inst->conf.tx_maxrate;
+		num = inst->conf.tx_channels;
+	}
+
+	conf = get_mmcm_conf(inst);
+
+	switch (maxrate) {
+	case 3:
+		mmcm_ptr->clkfbout_mult = conf[0].clkfbout_mult;
+		mmcm_ptr->divclk_divide = conf[0].divclk_divide;
+		mmcm_ptr->clkout0_div = conf[0].clkout0_div;
+		mmcm_ptr->clkout1_div = conf[0].clkout1_div;
+		mmcm_ptr->clkout2_div = conf[0].clkout2_div;
+		break;
+	case 6:
+		if (num == 3) {
+			mmcm_ptr->clkfbout_mult = conf[1].clkfbout_mult;
+			mmcm_ptr->divclk_divide = conf[1].divclk_divide;
+			mmcm_ptr->clkout0_div = conf[1].clkout0_div;
+			mmcm_ptr->clkout1_div = conf[1].clkout1_div;
+			mmcm_ptr->clkout2_div = conf[1].clkout2_div;
+		} else {
+			mmcm_ptr->clkfbout_mult = conf[2].clkfbout_mult;
+			mmcm_ptr->divclk_divide = conf[2].divclk_divide;
+			mmcm_ptr->clkout0_div = conf[2].clkout0_div;
+			mmcm_ptr->clkout1_div = conf[2].clkout1_div;
+			mmcm_ptr->clkout2_div = conf[2].clkout2_div;
+		}
+		break;
+	case 8:
+		mmcm_ptr->clkfbout_mult = conf[3].clkfbout_mult;
+		mmcm_ptr->divclk_divide = conf[3].divclk_divide;
+		mmcm_ptr->clkout0_div = conf[3].clkout0_div;
+		mmcm_ptr->clkout1_div = conf[3].clkout1_div;
+		mmcm_ptr->clkout2_div = conf[3].clkout2_div;
+		break;
+	case 10:
+		mmcm_ptr->clkfbout_mult = conf[4].clkfbout_mult;
+		mmcm_ptr->divclk_divide = conf[4].divclk_divide;
+		mmcm_ptr->clkout0_div = conf[4].clkout0_div;
+		mmcm_ptr->clkout1_div = conf[4].clkout1_div;
+		mmcm_ptr->clkout2_div = conf[4].clkout2_div;
+		break;
+	case 12:
+		mmcm_ptr->clkfbout_mult = conf[5].clkfbout_mult;
+		mmcm_ptr->divclk_divide = conf[5].divclk_divide;
+		mmcm_ptr->clkout0_div = conf[5].clkout0_div;
+		mmcm_ptr->clkout1_div = conf[5].clkout1_div;
+		mmcm_ptr->clkout2_div = conf[5].clkout2_div;
+		break;
+	default:
+		break;
+	}
+}
+
+static void xhdmiphy_set_clkout2_div(struct xhdmiphy_dev *inst, enum dir dir,
+				     u64 linerate, struct xhdmiphy_mmcm *mmcm_ptr)
+{
+	/* Only do this when the clkout2_div has been set */
+	if (mmcm_ptr->clkout2_div) {
+		if (dir == XHDMIPHY_DIR_RX) {
+			/* Correct divider value if TMDS clock ratio is 1/40 */
+			if (inst->rx_tmdsclock_ratio) {
+				if ((mmcm_ptr->clkout2_div % 4) == 0) {
+					mmcm_ptr->clkout2_div =
+					mmcm_ptr->clkout2_div / 4;
+				} else {
+				/*
+				 * Not divisible by 4: repeat
+				 * loop with a lower multiply
+				 * value
+				 */
+					if (inst->conf.gt_type != XHDMIPHY_GTYE5)
+						mmcm_ptr->clkout2_div = 255;
+					else
+						mmcm_ptr->clkout2_div = 65535;
+				}
+			}
+		}
+		/* TX */
+		else if ((((linerate / 1000000) >= XHDMIPHY_LRATE_3400) &&
+			  (inst->tx_samplerate == 1)) ||
+			  (((linerate / 1000000) / inst->tx_samplerate) >=
+			    XHDMIPHY_LRATE_3400)) {
+			if ((mmcm_ptr->clkout2_div % 4) == 0) {
+				mmcm_ptr->clkout2_div = mmcm_ptr->clkout2_div / 4;
+			} else {
+			/*
+			 * Not divisible by 4: repeat loop with
+			 * a lower multiply value
+			 */
+				if (inst->conf.gt_type != XHDMIPHY_GTYE5)
+					mmcm_ptr->clkout2_div = 255;
+				else
+					mmcm_ptr->clkout2_div = 65535;
+			}
+		}
+	}
+}
+
+/**
+ * xhdmiphy_cal_mmcm_param - This function calculates the HDMI mmcm parameters.
+ *
+ * @inst:	inst is a pointer to the Hdmiphy core instance
+ * @chid:	chid is the channel ID to operate on
+ * @dir:	dir is an indicator for RX or TX
+ * @ppc:	ppc specifies the total number of pixels per clock
+ *		- 1 = XVIDC_PPC_1
+ *		- 2 = XVIDC_PPC_2
+ *		- 4 = XVIDC_PPC_4
+ * @bpc:	bpc specifies the color depth/bits per color component
+ *		- 6 = XVIDC_BPC_6
+ *		- 8 = XVIDC_BPC_8
+ *		- 10 = XVIDC_BPC_10
+ *		- 12 = XVIDC_BPC_12
+ *		- 16 = XVIDC_BPC_16
+ *
+ * @return:	- 0 if calculated PLL parameters updated successfully
+ *		- 1 if parameters not updated
+ */
+u32 xhdmiphy_cal_mmcm_param(struct xhdmiphy_dev *inst, enum chid chid,
+			    enum dir dir, enum ppc ppc, enum color_depth bpc)
+{
+	struct xhdmiphy_mmcm *mmcm_ptr;
+	enum pll_type pll_type;
+	u64 linerate = 0;
+	u32 refclk, div, mult;
+	u16 mult_div;
+	u8 valid;
+
+	pll_type = xhdmiphy_get_pll_type(inst, dir, XHDMIPHY_CHID_CH1);
+
+	switch (pll_type) {
+	case XHDMIPHY_PLL_QPLL:
+	case XHDMIPHY_PLL_QPLL0:
+	case XHDMIPHY_PLL_LCPLL:
+		linerate = inst->quad.cmn0.linerate;
+		break;
+	case XHDMIPHY_PLL_QPLL1:
+	case XHDMIPHY_PLL_RPLL:
+		linerate = inst->quad.cmn1.linerate;
+		break;
+	default:
+		linerate = inst->quad.ch1.linerate;
+		break;
+	}
+
+	if (((linerate / 1000000) > 2970) && ppc == XVIDC_PPC_1) {
+		dev_err(inst->dev, "ppc not supported\n");
+		return 1;
+	}
+
+	div = 1;
+	do {
+		if (dir == XHDMIPHY_DIR_RX) {
+			refclk = inst->rx_refclk_hz;
+			mmcm_ptr = &inst->quad.rx_mmcm;
+			refclk = refclk / (get_gthdmi_ptr(inst))->rx_mmcm_scale;
+			mult = (get_gthdmi_ptr(inst))->rx_mmcm_fvcomax * div / refclk;
+		} else {
+			refclk = inst->tx_refclk_hz;
+			mmcm_ptr = &inst->quad.tx_mmcm;
+			refclk = refclk / (get_gthdmi_ptr(inst))->tx_mmcm_scale;
+			mult = (get_gthdmi_ptr(inst))->tx_mmcm_fvcomax * div / refclk;
+		}
+
+		/* return if refclk is below valid range */
+		if (refclk < 20000000)
+			return (1);
+
+		/* in case of 4 pixels per clock, the M must be a multiple of four */
+		if (ppc == XVIDC_PPC_4) {
+			mult = mult / 4;
+			mult = mult * 4;
+		} else if (ppc == XVIDC_PPC_2) {
+		/* else the M must be a multiple of two */
+			mult = mult / 2;
+			mult = mult * 2;
+		}
+
+		valid = (false);
+		do {
+			mult_div = mult / div;
+			mmcm_ptr->clkfbout_mult = mult;
+			mmcm_ptr->divclk_divide = div;
+			if (inst->conf.transceiver_width == 4) {
+				/* link clock: TMDS clock ratio 1/40 */
+				if ((linerate / 1000000) >= XHDMIPHY_LRATE_3400) {
+					if (dir == XHDMIPHY_DIR_TX &&
+					    (((linerate / 1000000) / inst->tx_samplerate) < 3400)) {
+						mmcm_ptr->clkout0_div = mult_div * 4;
+					} else {
+						mmcm_ptr->clkout0_div = mult_div;
+					}
+				} else {
+				/* link clock: TMDS clock ratio 1/10 */
+					mmcm_ptr->clkout0_div = mult_div * 4;
+				}
+			} else {
+				/* 2 Byte Mode */
+				/* link clock: TMDS clock ratio 1/40 */
+				if ((linerate / 1000000) >= XHDMIPHY_LRATE_3400) {
+					if (dir == XHDMIPHY_DIR_TX &&
+					    (((linerate / 1000000) / inst->tx_samplerate) < 3400)) {
+						mmcm_ptr->clkout0_div = mult_div * 2;
+					} else {
+						mmcm_ptr->clkout0_div = mult_div / 2;
+					}
+				} else {
+				/* link clock: TMDS clock ratio 1/10 */
+					mmcm_ptr->clkout0_div = mult_div * 2;
+				}
+			}
+			/* TMDS clock */
+			mmcm_ptr->clkout1_div = mult_div *
+						((dir == XHDMIPHY_DIR_TX) ?
+						(inst->tx_samplerate) : 1);
+			/* video clock */
+			mmcm_ptr->clkout2_div = 0;
+			switch (bpc) {
+			case XVIDC_BPC_10:
+				/* quad pixel */
+				if (ppc == (XVIDC_PPC_4)) {
+					mmcm_ptr->clkout2_div = (mult_div * 5 *
+						((dir == XHDMIPHY_DIR_TX) ?
+						(inst->tx_samplerate) : 1));
+				/* dual pixel */
+				} else if (ppc == (XVIDC_PPC_2)) {
+					/*
+					 * The clock ratio is 2.5. The PLL only
+					 * supports integer value. The mult_div
+					 * must be dividable by two
+					 * (2 * 2.5 = 5) to get an integer
+					 * number
+					 */
+					if ((mult_div % 2) == 0) {
+						mmcm_ptr->clkout2_div =
+							(mult_div * 5 / 2 *
+							((dir == XHDMIPHY_DIR_TX) ?
+							(inst->tx_samplerate) : 1));
+					}
+				/* single pixel */
+				} else {
+					/*
+					 * The clock ratio is 1.25. The pll only
+					 * supports integer values The multDiv
+					 * must be dividable by four
+					 * (4 * 1.25 = 5) to get an integer
+					 * number
+					 */
+					if ((mult_div % 4) == 0) {
+						mmcm_ptr->clkout2_div = (mult_div * 5 / 4 *
+							((dir == XHDMIPHY_DIR_TX) ?
+							(inst->tx_samplerate) : 1));
+					}
+				}
+				break;
+			case XVIDC_BPC_12:
+				/* quad pixel */
+				if (ppc == (XVIDC_PPC_4)) {
+					mmcm_ptr->clkout2_div = (mult_div * 6 *
+						((dir == XHDMIPHY_DIR_TX) ?
+						(inst->tx_samplerate) : 1));
+				} else if (ppc == (XVIDC_PPC_2)) {
+				/* dual pixel */
+					mmcm_ptr->clkout2_div = (mult_div * 3 *
+						((dir == XHDMIPHY_DIR_TX) ?
+						(inst->tx_samplerate) : 1));
+				/* single pixel */
+				} else {
+					/*
+					 * The clock ratio is 1.5. The PLL only
+					 * supports integer values. The mult_div
+					 * must be dividable by two (2 * 1.5 = 3)
+					 * to get an integer number
+					 */
+					if ((mult_div % 2) == 0) {
+						mmcm_ptr->clkout2_div = (mult_div * 3 / 2 *
+							((dir == XHDMIPHY_DIR_TX) ?
+							(inst->tx_samplerate) : 1));
+					}
+				}
+				break;
+			case XVIDC_BPC_16:
+				/* quad pixel */
+				if (ppc == (XVIDC_PPC_4)) {
+					mmcm_ptr->clkout2_div = (mult_div * 8 *
+						((dir == XHDMIPHY_DIR_TX) ?
+						(inst->tx_samplerate) : 1));
+				} else if (ppc == (XVIDC_PPC_2)) {
+				/* dual pixel */
+					mmcm_ptr->clkout2_div = (mult_div * 4 *
+						((dir == XHDMIPHY_DIR_TX) ?
+						(inst->tx_samplerate) : 1));
+				} else {
+				/* single pixel */
+					mmcm_ptr->clkout2_div = (mult_div * 2 *
+						((dir == XHDMIPHY_DIR_TX) ?
+						(inst->tx_samplerate) : 1));
+				}
+				break;
+			case XVIDC_BPC_8:
+			default:
+				/* quad pixel */
+				if (ppc == (XVIDC_PPC_4)) {
+					mmcm_ptr->clkout2_div = (mult_div * 4 *
+						((dir == XHDMIPHY_DIR_TX) ?
+						(inst->tx_samplerate) : 1));
+				} else if (ppc == (XVIDC_PPC_2)) {
+				/* dual pixel */
+					mmcm_ptr->clkout2_div = (mult_div * 2 *
+						((dir == XHDMIPHY_DIR_TX) ?
+						(inst->tx_samplerate) : 1));
+				} else {
+				/* single pixel */
+					mmcm_ptr->clkout2_div = (mult_div *
+						((dir == XHDMIPHY_DIR_TX) ?
+						(inst->tx_samplerate) : 1));
+				}
+				break;
+			}
+			xhdmiphy_set_clkout2_div(inst, dir, linerate, mmcm_ptr);
+
+			/* Check values */
+			if (inst->conf.gt_type != XHDMIPHY_GTYE5) {
+				if (mmcm_ptr->clkout0_div > 0 &&
+				    mmcm_ptr->clkout0_div <= 128 &&
+				    mmcm_ptr->clkout1_div > 0 &&
+				    mmcm_ptr->clkout1_div <= 128 &&
+				    mmcm_ptr->clkout2_div > 0 &&
+				    mmcm_ptr->clkout2_div <= 128) {
+					valid = (true);
+				} else {
+					/* 4 pixels per clock */
+					if (ppc == (XVIDC_PPC_4)) {
+						/* Decrease mult value */
+						mult -= 4;
+					} else if (ppc == (XVIDC_PPC_2)) {
+					/* 2 pixels per clock */
+						/* Decrease M value */
+						mult -= 2;
+					} else {
+						/* 1 pixel per clock */
+						/* Decrease M value */
+						mult -= 1;
+					}
+				}
+			} else {
+				if (mmcm_ptr->clkout0_div > 0 &&
+				    mmcm_ptr->clkout0_div <= 511 &&
+				    mmcm_ptr->clkout1_div > 0 &&
+				    mmcm_ptr->clkout1_div <= 511 &&
+				    mmcm_ptr->clkout2_div > 0 &&
+				    mmcm_ptr->clkout2_div <= 511) {
+					valid = (true);
+				} else { /* 4 pixels per clock */
+					if (ppc == (XVIDC_PPC_4)) {
+						/* Decrease mult value */
+						mult -= 4;
+					} else if (ppc == (XVIDC_PPC_2)) {
+						/* 2 pixels per clock */
+						/* Decrease M value */
+						mult -= 2;
+					} else {
+						/* 1 pixel per clock */
+						/* Decrease M value */
+						mult -= 1;
+					}
+				}
+			}
+		} while (!valid && (mult > 0) && (mult < 129));
+
+		/* Increment divider */
+		div++;
+	} while (!valid && (div > 0) && (div < 107));
+
+	if (valid)
+		return 0;
+
+	dev_err(inst->dev, "failed to caliculate mmmcm params\n");
+
+	return 1;
+}
+
+/**
+ * xhdmiphy_clk_cal_params - This function will try to find the necessary PLL
+ * divisor values to produce the configured line rate given the specified PLL
+ * input frequency. This will be done for all channels specified by chid.
+ * This function is a wrapper for xhdmiphy_pll_cal.
+ *
+ * @inst:		inst is a pointer to the xhdmiphy core instance.
+ * @chid:		chid is the channel ID to calculate the PLL values for.
+ * @dir:		dir is an indicator for TX or RX.
+ * @pll_in_freq:	pll_clkin_freq is the PLL input frequency on which to
+ *			base the calculations on. A value of 0 indicates to use
+ *			the currently configured quad PLL reference clock.
+ *			A non-zero value indicates to ignore what is currently
+ *			configured in SW, and use a custom frequency instead.
+ *
+ * @return:		- 0 if valid PLL values were found to satisfy the
+ *			constraints
+ *			- 1 otherwise
+ */
+static u32 xhdmiphy_clk_cal_params(struct xhdmiphy_dev *inst, enum chid chid,
+				   enum dir dir, u32 pll_in_freq)
+{
+	u32 status = 0;
+	u8 id, id0, id1;
+
+	xhdmiphy_ch2ids(inst, chid, &id0, &id1);
+
+	for (id = id0; id <= id1; id++) {
+		status = xhdmiphy_pll_cal(inst, (enum chid)id, dir,
+					  pll_in_freq);
+		if (status != 0)
+			return status;
+	}
+
+	return status;
+}
+
+/**
+ * xhdmiphy_qpll_param - This function calculates the qpll parameters.
+ *
+ * @inst:	inst is a pointer to the HDMI GT core instance
+ * @chid:	chid is the channel ID to operate on
+ * @dir:	dir is an indicator for RX or TX
+ *
+ * @return:
+ *		- 0 if calculated QPLL parameters updated
+ *			successfully
+ *		- 1 if parameters not updated
+ */
+u32 xhdmiphy_qpll_param(struct xhdmiphy_dev *inst, enum chid chid, enum dir dir)
+{
+	enum sysclk_data_sel sysclk_data_sel = 0;
+	enum chid act_cmnid = XHDMIPHY_CHID_CMN0;
+	enum sysclk_outsel sysclk_out_sel = 0;
+	u64 refclk = 0, tx_linerate = 0;
+	u32 *refclk_ptr;
+	u32 qpll_clkmin = 0;
+	u32 status, qpll_refclk;
+	u8 sr_arr[] = {1, 3, 5};
+	u8 sr_index, sr_val, id, id0, id1;
+
+	/* determine qpll reference clock from the first (master) channel */
+	if (dir == XHDMIPHY_DIR_RX) {
+		qpll_refclk = inst->rx_refclk_hz;
+		refclk_ptr = &inst->rx_refclk_hz;
+	} else {
+		qpll_refclk = inst->tx_refclk_hz;
+		refclk_ptr = &inst->tx_refclk_hz;
+	}
+
+	if (inst->conf.gt_type == XHDMIPHY_GTHE4) {
+		/* determine which QPLL to use */
+		if ((qpll_refclk >= 102343750 && qpll_refclk <= 122500000) ||
+		    (qpll_refclk >= 204687500 && qpll_refclk <= 245000000) ||
+		    (qpll_refclk >= 409375000 && qpll_refclk <= 490000000)) {
+			sysclk_data_sel = XHDMIPHY_SYSCLKSELDATA_QPLL1_OUTCLK;
+			sysclk_out_sel = XHDMIPHY_SYSCLKSELOUT_QPLL1_REFCLK;
+			act_cmnid = XHDMIPHY_CHID_CMN1;
+			qpll_clkmin = (u32)XHDMIPHY_HDMI_GTHE4_QPLL1_REFCLK_MIN;
+		} else {
+			sysclk_data_sel = XHDMIPHY_SYSCLKSELDATA_QPLL0_OUTCLK;
+			sysclk_out_sel = XHDMIPHY_SYSCLKSELOUT_QPLL0_REFCLK;
+			act_cmnid = XHDMIPHY_CHID_CMN0;
+			qpll_clkmin = (u32)XHDMIPHY_HDMI_GTHE4_QPLL0_REFCLK_MIN;
+		}
+	} else if (inst->conf.gt_type == XHDMIPHY_GTYE4) {
+		if ((qpll_refclk >= 102343750 && qpll_refclk <= 122500000) ||
+		    (qpll_refclk >= 204687500 && qpll_refclk <= 245000000) ||
+		    (qpll_refclk >= 409375000 && qpll_refclk <= 490000000)) {
+			sysclk_data_sel = XHDMIPHY_SYSCLKSELDATA_QPLL1_OUTCLK;
+			sysclk_out_sel = XHDMIPHY_SYSCLKSELOUT_QPLL1_REFCLK;
+			act_cmnid = XHDMIPHY_CHID_CMN1;
+			qpll_clkmin = (u32)XHDMIPHY_HDMI_GTYE4_QPLL1_REFCLK_MIN;
+		} else {
+			sysclk_data_sel = XHDMIPHY_SYSCLKSELDATA_QPLL0_OUTCLK;
+			sysclk_out_sel = XHDMIPHY_SYSCLKSELOUT_QPLL0_REFCLK;
+			act_cmnid = XHDMIPHY_CHID_CMN0;
+			qpll_clkmin = (u32)XHDMIPHY_HDMI_GTYE4_QPLL0_REFCLK_MIN;
+		}
+	}
+
+	/* update qpll clock selections */
+	xhdmiphy_sysclk_data_sel(inst, dir, sysclk_data_sel);
+	xhdmiphy_sysclk_out_sel(inst, dir, sysclk_out_sel);
+
+	/* rx is using qpll */
+	if (dir == XHDMIPHY_DIR_RX) {
+		/*
+		 * check if the reference clock is not below the minimum qpll
+		 * input frequency
+		 */
+		if (qpll_refclk >= qpll_clkmin) {
+			refclk = qpll_refclk;
+			/* Scaled line rate */
+			if (inst->rx_hdmi21_cfg.is_en == 0) {
+				if (inst->rx_tmdsclock_ratio)
+					xhdmiphy_cfg_linerate(inst,
+							      XHDMIPHY_CHID_CMNA,
+							      (refclk * 40));
+				else
+					xhdmiphy_cfg_linerate(inst,
+							      XHDMIPHY_CHID_CMNA,
+							      (refclk * 10));
+			} else {
+				xhdmiphy_cfg_linerate(inst,
+						      XHDMIPHY_CHID_CMNA,
+						      inst->rx_hdmi21_cfg.linerate);
+			}
+			/* clear DRU is enabled flag */
+			inst->rx_dru_enabled = 0;
+
+			/* Set RX data width */
+			xhdmiphy_ch2ids(inst, XHDMIPHY_CHID_CHA, &id0, &id1);
+			for (id = id0; id <= id1; id++) {
+				if (inst->conf.transceiver_width == 2) {
+					inst->quad.plls[XHDMIPHY_CH2IDX(id)].rx_data_width = 20;
+					inst->quad.plls[XHDMIPHY_CH2IDX(id)].rx_intdata_width = 2;
+				} else {
+					inst->quad.plls[XHDMIPHY_CH2IDX(id)].rx_data_width = 40;
+					inst->quad.plls[XHDMIPHY_CH2IDX(id)].rx_intdata_width = 4;
+				}
+			}
+		} else if (inst->conf.dru_present) {
+			refclk = xhdmiphy_get_dru_refclk(inst);
+			/* check DRU frequency */
+			if (refclk == 1) {
+				dev_err(inst->dev, "cannot get dru refclk\n");
+				return 1;
+			}
+
+			/* round input frequency to 10 kHz */
+			refclk = (refclk + 5000) / 10000;
+			refclk = refclk * 10000;
+
+			/* wet the DRU to operate at a linerate of 2.5 Gbps */
+			xhdmiphy_cfg_linerate(inst, XHDMIPHY_CHID_CMNA,
+					      (get_gthdmi_ptr(inst))->dru_linerate);
+
+			/* set DRU is enabled flag */
+			inst->rx_dru_enabled = 1;
+
+			/* set RX data width to 40 and 4 bytes */
+			xhdmiphy_ch2ids(inst, XHDMIPHY_CHID_CHA, &id0, &id1);
+			for (id = id0; id <= id1; id++) {
+				inst->quad.plls[XHDMIPHY_CH2IDX(id)].rx_data_width = 20;
+				inst->quad.plls[XHDMIPHY_CH2IDX(id)].rx_intdata_width = 2;
+			}
+		} else {
+			dev_err(inst->dev, "dru is not present\n");
+			return 1;
+		}
+	/* TX is using QPLL */
+	} else {
+		/* Set default TX sample rate */
+		inst->tx_samplerate = 1;
+
+		if (inst->tx_hdmi21_cfg.is_en == 0) {
+			/* Update TX line rates */
+			xhdmiphy_cfg_linerate(inst, XHDMIPHY_CHID_CMNA,
+					      ((u64)(*refclk_ptr) * 10));
+			tx_linerate = (*refclk_ptr) / 100000;
+
+			/* Check if the linerate is above the 340 Mcsc */
+			if ((tx_linerate) >= XHDMIPHY_LRATE_3400)
+				(*refclk_ptr) = (*refclk_ptr) / 4;
+		} else { /* inst->tx_hdmi21_cfg.is_en == 1 */
+			xhdmiphy_cfg_linerate(inst, XHDMIPHY_CHID_CMNA,
+					      inst->tx_hdmi21_cfg.linerate);
+		}
+	}
+
+	/* Calculate QPLL values */
+	for (sr_index = 0; sr_index < sizeof(sr_arr); sr_index++) {
+		/* Only use oversampling when then TX is using the QPLL */
+		if (dir == XHDMIPHY_DIR_TX) {
+			sr_val = sr_arr[sr_index];
+
+			if (inst->tx_hdmi21_cfg.is_en == 0) {
+				/*
+				 * TX reference clock is below the minimum QPLL
+				 * clock input frequency
+				 */
+				if ((*refclk_ptr) < qpll_clkmin) {
+					refclk = ((*refclk_ptr) * sr_val);
+
+					/* Calculate scaled line rate */
+					if (tx_linerate >= XHDMIPHY_LRATE_3400) {
+						xhdmiphy_cfg_linerate(inst,
+								      XHDMIPHY_CHID_CMNA,
+								      (u64)(refclk * 40));
+					} else {
+						xhdmiphy_cfg_linerate(inst,
+								      XHDMIPHY_CHID_CMNA,
+								      (u64)(refclk * 10));
+					}
+				} else {
+					/*
+					 * TX reference clock is in QPLL clock input range.
+					 * In this case don't increase the reference clock, but
+					 * increase the line rate.
+					 */
+					refclk = (*refclk_ptr);
+
+					/* Calculate scaled line rate */
+					if (tx_linerate >= XHDMIPHY_LRATE_3400) {
+						xhdmiphy_cfg_linerate(inst,
+								      XHDMIPHY_CHID_CMNA,
+								      (u64)(refclk * 40 * sr_val));
+					} else {
+						xhdmiphy_cfg_linerate(inst,
+								      XHDMIPHY_CHID_CMNA,
+								      (u64)(refclk * 10 * sr_val));
+					}
+				}
+			} else { /* inst->tx_hdmi21_cfg.is_en == 1 */
+				refclk = (*refclk_ptr);
+			}
+		} else {
+			/* For all other reference clocks force sample rate to one */
+			sr_val = 1;
+		}
+
+		status = xhdmiphy_clk_cal_params(inst, act_cmnid, dir, refclk);
+		if (status == 0) {
+			/* Only execute when the TX is using the QPLL */
+			if (dir == XHDMIPHY_DIR_TX) {
+				/* Set TX sample rate */
+				inst->tx_samplerate = sr_val;
+
+				/*
+				 * Update reference clock only when the
+				 * reference clock is below the minimum QPLL
+				 * input frequency.
+				 */
+				if ((*refclk_ptr) < qpll_clkmin) {
+					(*refclk_ptr) = (*refclk_ptr) * sr_val;
+				} else if (sr_val > 1) {
+					dev_err(inst->dev,
+						"failed to configure qpll params\n");
+					return 1;
+				}
+			}
+			/*
+			 * Check Userclock Frequency (300 MHz + 0.5%) + 10 KHz
+			 * (Clkdet accuracy)
+			 */
+			if (301500000 < (xhdmiphy_get_linerate(inst, act_cmnid) /
+					 (inst->conf.transceiver_width * 10))) {
+				dev_err(inst->dev, "user clock error\n");
+				return 1;
+			}
+
+			return 0;
+		}
+	}
+
+	dev_err(inst->dev, "failed to configure qpll params\n");
+	return 1;
+}
+
+/**
+ * xhdmiphy_cpll_param - This function calculates the CPLL parameters.
+ *
+ * @inst:	inst is a pointer to the HDMI GT core instance
+ * @chid:	chid is the channel ID to operate on
+ * @dir:	dir is an indicator for RX or TX
+ *
+ * @return:	- 0 if calculated CPLL parameters updated
+ *		  successfully
+ *		- 1 if parameters not updated
+ */
+u32 xhdmiphy_cpll_param(struct xhdmiphy_dev *inst, enum chid chid, enum dir dir)
+{
+	enum chid ch_id = XHDMIPHY_CHID_CHA;
+	u64 refclk = 0;
+	u32 *refclk_ptr;
+	u32 tx_linerate = 0;
+	u32 status;
+	u8 sr_arr[] = {1, 3, 5};
+	u8 sr_index, sr_val, id, id0, id1;
+
+	/* tx is using cpll */
+	if (dir == XHDMIPHY_DIR_TX) {
+		/* set default tx sample rate */
+		inst->tx_samplerate = 1;
+		refclk_ptr = &inst->tx_refclk_hz;
+		if (inst->tx_hdmi21_cfg.is_en == 0) {
+			xhdmiphy_cfg_linerate(inst, ch_id,
+					      (u64)((*refclk_ptr) * 10));
+			tx_linerate = (*refclk_ptr)  / 100000;
+			/* check if the line rate is above the 340 Mcsc */
+			if (tx_linerate >= XHDMIPHY_LRATE_3400)
+				(*refclk_ptr) = (*refclk_ptr) / 4;
+		} else {
+			xhdmiphy_cfg_linerate(inst, ch_id,
+					      (u64)(inst->tx_hdmi21_cfg.linerate));
+			tx_linerate = inst->tx_hdmi21_cfg.linerate / 100000;
+		}
+	} else {
+		/* rx is using cpll */
+		refclk_ptr = &inst->rx_refclk_hz;
+		/*
+		 * check if the reference clock is not below the minimum CPLL
+		 * input frequency
+		 */
+		if ((*refclk_ptr) >= (get_gthdmi_ptr(inst))->cpll_refclk_min) {
+			refclk = (*refclk_ptr);
+			/* scaled linerate */
+			if (inst->rx_hdmi21_cfg.is_en == 0) {
+				if (inst->rx_tmdsclock_ratio) {
+					xhdmiphy_cfg_linerate(inst, ch_id,
+							      (refclk * 40));
+				} else {
+					xhdmiphy_cfg_linerate(inst, ch_id,
+							      (refclk * 10));
+				}
+			} else { /* inst->rx_hdmi21_cfg.is_en == 1 */
+				xhdmiphy_cfg_linerate(inst, ch_id,
+						      inst->rx_hdmi21_cfg.linerate);
+			}
+
+			inst->rx_dru_enabled = 0;
+			xhdmiphy_ch2ids(inst, XHDMIPHY_CHID_CHA, &id0,
+					&id1);
+			for (id = id0; id <= id1; id++) {
+				if (inst->conf.transceiver_width == 2) {
+					inst->quad.plls[XHDMIPHY_CH2IDX(id)].rx_data_width = 20;
+					inst->quad.plls[XHDMIPHY_CH2IDX(id)].rx_intdata_width = 2;
+				} else {
+					inst->quad.plls[XHDMIPHY_CH2IDX(id)].rx_data_width = 40;
+					inst->quad.plls[XHDMIPHY_CH2IDX(id)].rx_intdata_width = 4;
+				}
+			}
+		} else {
+			if (inst->conf.dru_present) {
+				/* Return config not found error when TMDS ratio is 1/40 */
+				if (inst->rx_tmdsclock_ratio) {
+					dev_err(inst->dev, "cpll config not found\n");
+					return 1;
+				}
+				refclk = xhdmiphy_get_dru_refclk(inst);
+				/* check DRU frequency */
+				if (refclk == 1) {
+					dev_err(inst->dev,
+						"cannot get dru refclk\n");
+					return 1;
+				}
+
+				/* Round input frequency to 10 kHz */
+				refclk = (refclk + 5000) / 10000;
+				refclk = refclk * 10000;
+
+				/*
+				 * set the dru to operate at a linerate of
+				 * 2.5 Gbps
+				 */
+				xhdmiphy_cfg_linerate(inst, ch_id,
+						      (get_gthdmi_ptr(inst))->
+						      dru_linerate);
+				/* Set dru is enabled flag */
+				inst->rx_dru_enabled = 1;
+
+				/* set rx data width */
+				xhdmiphy_ch2ids(inst, XHDMIPHY_CHID_CHA,
+						&id0, &id1);
+				for (id = id0; id <= id1; id++) {
+					inst->quad.plls[XHDMIPHY_CH2IDX(id)].rx_data_width = 20;
+					inst->quad.plls[XHDMIPHY_CH2IDX(id)].rx_intdata_width = 2;
+				}
+
+				if (tx_linerate > (((get_gthdmi_ptr(inst))->
+						dru_linerate) / 1000000)) {
+					dev_err(inst->dev,
+						"video format is not supported\n");
+					return 1;
+				}
+			} else {
+				/* return config not found error when TMDS ratio is 1/40 */
+				if (inst->rx_tmdsclock_ratio) {
+					dev_err(inst->dev,
+						"cpll config not found\n");
+				} else {
+					dev_err(inst->dev, "no dru present\n");
+				}
+				return 1;
+			}
+		}
+	}
+
+	/* try different sample rates */
+	for (sr_index = 0; sr_index < sizeof(sr_arr); sr_index++) {
+		/* only use oversampling when then tx is using the cpll */
+		if (dir == XHDMIPHY_DIR_TX) {
+			sr_val = sr_arr[sr_index];
+			if (inst->tx_hdmi21_cfg.is_en == 0) {
+				/* multiply the reference clock with the sample
+				 * rate value
+				 */
+				refclk = ((*refclk_ptr) * sr_val);
+				/* calculate scaled line rate */
+				if (tx_linerate >= XHDMIPHY_LRATE_3400) {
+					xhdmiphy_cfg_linerate(inst, ch_id,
+							      (refclk * 40));
+				} else {
+					xhdmiphy_cfg_linerate(inst,
+							      ch_id,
+							      (refclk * 10));
+				}
+			} else { /* inst->tx_hdmi21_cfg.is_en == 1 */
+				refclk = (*refclk_ptr);
+			}
+		/* for all other reference clocks force sample rate to one */
+		} else {
+			sr_val = 1;
+		}
+
+		status = xhdmiphy_clk_cal_params(inst, ch_id, dir, refclk);
+		if (status == (0)) {
+			/* only execute when the tx is using the qpll */
+			if (dir == XHDMIPHY_DIR_TX) {
+				inst->tx_samplerate = sr_val;
+				(*refclk_ptr) = (*refclk_ptr) * sr_val;
+			}
+
+			/* check userclock frequency */
+			/* (300 MHz + 0.5%) + 10 KHz (clkdet accuracy) */
+			if (301500000 <
+			    (xhdmiphy_get_linerate(inst,
+						   XHDMIPHY_CHID_CH1) /
+						   (inst->conf.transceiver_width * 10))) {
+				dev_err(inst->dev, "user clock error\n");
+				return 1;
+			}
+
+			return 0;
+		}
+	}
+
+	dev_err(inst->dev, "cpll config not found\n");
+
+	return 1;
+}
diff --git a/drivers/phy/xilinx/xhdmiphy_modules.c b/drivers/phy/xilinx/xhdmiphy_modules.c
new file mode 100644
index 000000000..70c695886
--- /dev/null
+++ b/drivers/phy/xilinx/xhdmiphy_modules.c
@@ -0,0 +1,2004 @@
+// SPDX-License-Identifier: GPL-2.0-only
+
+#include <linux/device.h>
+#include "xhdmiphy.h"
+
+void xhdmiphy_intr_en(struct xhdmiphy_dev *inst, u32 intr)
+{
+	u32 reg_val;
+
+	reg_val = xhdmiphy_read(inst, XHDMIPHY_INTR_EN_REG);
+	reg_val |= intr;
+	xhdmiphy_write(inst, XHDMIPHY_INTR_EN_REG, reg_val);
+}
+
+void xhdmiphy_intr_dis(struct xhdmiphy_dev *inst, u32 intr)
+{
+	u32 reg_val;
+
+	reg_val = xhdmiphy_read(inst, XHDMIPHY_INTR_DIS_REG);
+	reg_val |= intr;
+	xhdmiphy_write(inst, XHDMIPHY_INTR_DIS_REG, reg_val);
+}
+
+static void xhdmiphy_set(struct xhdmiphy_dev *inst, u32 addr, u32 set)
+{
+	xhdmiphy_write(inst, addr, xhdmiphy_read(inst, addr) | set);
+}
+
+inline void xhdmiphy_clr(struct xhdmiphy_dev *inst, u32 addr, u32 clr)
+{
+	xhdmiphy_write(inst, addr, xhdmiphy_read(inst, addr) & ~clr);
+}
+
+/**
+ * xhdmiphy_outdiv_reconf - This function will set the current output divider
+ * configuration over DRP.
+ *
+ * @inst:	inst is a pointer to the xhdmiphy core instance
+ * @chid:	chid is the channel ID for which to write the settings for
+ * @dir:	dir is an indicator for RX or TX
+ */
+static void xhdmiphy_outdiv_reconf(struct xhdmiphy_dev *inst, enum chid chid,
+				   enum dir dir)
+{
+	u32 ret = 0;
+	u8 id, id0, id1;
+
+	if (!xhdmiphy_is_ch(chid))
+		chid = XHDMIPHY_CHID_CHA;
+
+	xhdmiphy_ch2ids(inst, chid, &id0, &id1);
+
+	for (id = id0; id <= id1; id++) {
+		ret = xhdmiphy_outdiv_ch_reconf(inst, (enum chid)id, dir);
+		if (ret != 0)
+			break;
+	}
+}
+
+/**
+ * xhdmiphy_clkdet_freq_reset - This function will reset the clock change detector module.
+ *
+ * @inst:	inst is a pointer to the xhdmiphy core instance
+ * @dir:	dir is an indicator for RX or TX
+ */
+void xhdmiphy_clkdet_freq_reset(struct xhdmiphy_dev *inst, enum dir dir)
+{
+	u32 regval;
+
+	regval = xhdmiphy_read(inst, XHDMIPHY_CLKDET_CTRL_REG);
+	if (dir == XHDMIPHY_DIR_TX)
+		regval |= XHDMIPHY_CLKDET_CTRL_TX_FREQ_RST_MASK;
+	else
+		regval |= XHDMIPHY_CLKDET_CTRL_RX_FREQ_RST_MASK;
+
+	xhdmiphy_write(inst, XHDMIPHY_CLKDET_CTRL_REG, regval);
+}
+
+/**
+ * xhdmiphy_clkdet_freq_threshold - This function sets the clock detector
+ * frequency lock counter threshold value.
+ *
+ * @inst:	inst is a pointer to the xhdmiphy core instance
+ * @thres_val:	thresholdVal is the threshold value to be set
+ */
+static void xhdmiphy_clkdet_freq_threshold(struct xhdmiphy_dev *inst,
+					   u16 thres_val)
+{
+	u32 reg_val;
+
+	reg_val = xhdmiphy_read(inst, XHDMIPHY_CLKDET_CTRL_REG);
+
+	reg_val &= ~XHDMIPHY_CLKDET_CTRL_RX_FREQ_RST_MASK;
+	reg_val |= (thres_val << XHDMIPHY_CLKDET_CTRL_FREQ_LOCK_THRESH_SHIFT);
+	xhdmiphy_write(inst, XHDMIPHY_CLKDET_CTRL_REG, reg_val);
+}
+
+/**
+ * xhdmiphy_patgen_set_ratio - This function sets the Pattern Generator for the
+ * GT channel 4 when it is used to generate the TX TMDS Clock.
+ *
+ * @inst:		inst is a pointer to the xhdmiphy core instance
+ * @tx_linerate:	tx_linerate in Mbps
+ */
+static void xhdmiphy_patgen_set_ratio(struct xhdmiphy_dev *inst,
+				      u64 tx_linerate)
+{
+	u32 reg_val;
+
+	reg_val = xhdmiphy_read(inst, XHDMIPHY_PATGEN_CTRL_REG)
+				 & ~XHDMIPHY_PATGEN_CTRL_RATIO_MASK;
+
+	if (tx_linerate >= XHDMIPHY_LRATE_3400 && inst->tx_samplerate == 1)
+		reg_val |= XHDMIPHY_patgen_ratio_40 &
+			   XHDMIPHY_PATGEN_CTRL_RATIO_MASK;
+	else
+		reg_val |= inst->tx_samplerate &
+			   XHDMIPHY_PATGEN_CTRL_RATIO_MASK;
+
+	xhdmiphy_write(inst, XHDMIPHY_PATGEN_CTRL_REG, reg_val);
+}
+
+static void xhdmiphy_dru_reset(struct xhdmiphy_dev *inst, enum chid chid,
+			       u8 rst)
+{
+	u32 reg_val, mask_val = 0;
+	u8 id, id0, id1;
+
+	reg_val = xhdmiphy_read(inst, XHDMIPHY_DRU_CTRL_REG);
+
+	xhdmiphy_ch2ids(inst, chid, &id0, &id1);
+
+	for (id = id0; id <= id1; id++)
+		mask_val |= XHDMIPHY_DRU_CTRL_RST_MASK(id);
+
+	xhdmiphy_set_clr(inst, XHDMIPHY_DRU_CTRL_REG, reg_val, mask_val, rst);
+}
+
+static void xhdmiphy_dru_en(struct xhdmiphy_dev *inst, enum chid chid, u8 en)
+{
+	u32 reg_val, mask_val = 0;
+	u8 id, id0, id1;
+
+	reg_val = xhdmiphy_read(inst, XHDMIPHY_DRU_CTRL_REG);
+
+	xhdmiphy_ch2ids(inst, chid, &id0, &id1);
+
+	for (id = id0; id <= id1; id++)
+		mask_val |= XHDMIPHY_DRU_CTRL_EN_MASK(id);
+
+	xhdmiphy_set_clr(inst, XHDMIPHY_DRU_CTRL_REG, reg_val, mask_val, en);
+}
+
+static void xhdmiphy_dru_mode_en(struct xhdmiphy_dev *inst, u8 en)
+{
+	u32 reg_val, reg_mask = 0;
+	u8 id, id0, id1;
+
+	reg_val = xhdmiphy_read(inst, XHDMIPHY_RX_EQ_CDR_REG);
+
+	xhdmiphy_ch2ids(inst, XHDMIPHY_CHID_CHA, &id0, &id1);
+	for (id = id0; id <= id1; id++) {
+		reg_mask |= XHDMIPHY_RX_STATUS_RXCDRHOLD_MASK(id) |
+			    XHDMIPHY_RX_STATUS_RXOSOVRDEN_MASK(id) |
+			    XHDMIPHY_RX_STATUS_RXLPMLFKLOVRDEN_MASK(id) |
+			    XHDMIPHY_RX_STATUS_RXLPMHFOVRDEN_MASK(id);
+	}
+
+	xhdmiphy_set_clr(inst, XHDMIPHY_RX_EQ_CDR_REG, reg_val, reg_mask, en);
+}
+
+static void xhdmiphy_set_dru_centerfreq(struct xhdmiphy_dev *inst,
+					enum chid chid, u64 center_freq)
+{
+	u32 center_freq_l, center_freq_h, reg_off;
+	u8 id, id0, id1;
+
+	/* Split the 64-bit input into 2 32-bit values */
+	center_freq_l = lower_32_bits(center_freq);
+	center_freq_h = upper_32_bits(center_freq);
+
+	center_freq_h &= XHDMIPHY_DRU_CFREQ_H_MASK;
+
+	xhdmiphy_ch2ids(inst, chid, &id0, &id1);
+	for (id = id0; id <= id1; id++) {
+		reg_off = XHDMIPHY_DRU_CFREQ_L_REG(id);
+		xhdmiphy_write(inst, reg_off, center_freq_l);
+
+		reg_off = XHDMIPHY_DRU_CFREQ_H_REG(id);
+		xhdmiphy_write(inst, reg_off, center_freq_h);
+	}
+}
+
+/**
+ * xhdmiphy_get_dru_refclk - This function returns the frequency of the DRU
+ * reference clock as measured by the clock detector peripheral.
+ *
+ * @inst:	inst is a pointer to the xhdmiphy core instance
+ *
+ * @return:	The measured frequency of the DRU reference clock
+ */
+u32 xhdmiphy_get_dru_refclk(struct xhdmiphy_dev *inst)
+{
+	u32 dru_freq = xhdmiphy_read(inst, XHDMIPHY_CLKDET_FREQ_DRU_REG);
+
+	if (inst->conf.gt_type == XHDMIPHY_GTTYPE_GTHE4) {
+		if (dru_freq > XHDMIPHY_HDMI_GTHE4_DRU_REFCLK_MIN &&
+		    dru_freq < XHDMIPHY_HDMI_GTHE4_DRU_REFCLK_MAX) {
+			return XHDMIPHY_HDMI_GTHE4_DRU_REFCLK;
+		} else if (dru_freq > XHDMIPHY_HDMI_GTHE4_DRU_REFCLK2_MIN &&
+			   dru_freq < XHDMIPHY_HDMI_GTHE4_DRU_REFCLK2_MAX) {
+			return XHDMIPHY_HDMI_GTHE4_DRU_REFCLK2;
+		}
+	} else if (inst->conf.gt_type == XHDMIPHY_GTTYPE_GTYE4) {
+		if (dru_freq > XHDMIPHY_HDMI_GTYE4_DRU_REFCLK_MIN &&
+		    dru_freq < XHDMIPHY_HDMI_GTYE4_DRU_REFCLK_MAX) {
+			return XHDMIPHY_HDMI_GTYE4_DRU_REFCLK;
+		} else if (dru_freq > XHDMIPHY_HDMI_GTYE4_DRU_REFCLK2_MIN &&
+			   dru_freq < XHDMIPHY_HDMI_GTYE4_DRU_REFCLK2_MAX) {
+			return XHDMIPHY_HDMI_GTYE4_DRU_REFCLK2;
+		}
+	} else {
+		if (dru_freq > XHDMIPHY_HDMI_GTYE5_DRU_REFCLK_MIN &&
+		    dru_freq < XHDMIPHY_HDMI_GTYE5_DRU_REFCLK_MAX) {
+			return XHDMIPHY_HDMI_GTYE5_DRU_REFCLK;
+		}
+		if (dru_freq > XHDMIPHY_HDMI_GTYE5_DRU_REFCLK1_MIN &&
+		    dru_freq < XHDMIPHY_HDMI_GTYE5_DRU_REFCLK1_MAX) {
+			return XHDMIPHY_HDMI_GTYE5_DRU_REFCLK1;
+		}
+		if (dru_freq > XHDMIPHY_HDMI_GTYE5_DRU_REFCLK2_MIN &&
+		    dru_freq < XHDMIPHY_HDMI_GTYE5_DRU_REFCLK2_MAX) {
+			return XHDMIPHY_HDMI_GTYE5_DRU_REFCLK2;
+		}
+	}
+
+	return 1;
+}
+
+/**
+ * xhdmiphy_dru_cal_centerfreq - This function calculates the center frequency
+ * value for the DRU.
+ *
+ * @inst:	inst is a pointer to the xhdmiphy GT core instance
+ * @chid:	chid is the channel ID to operate on
+ *
+ * @return:	The calculated DRU Center frequency value.
+ *		According to XAPP1240 Center_f = fDIN * (2^32)/fdruclk
+ *		The DRU clock is derived from the measured reference clock and
+ *		the current QPLL settings.
+ */
+static u64 xhdmiphy_dru_cal_centerfreq(struct xhdmiphy_dev *inst,
+				       enum chid chid)
+{
+	struct channel *ch_ptr;
+	struct pll_param *pll_prm;
+	u64 dru_refclk, clkdet_refclk, data_rate, f_din, fdru_clk;
+
+	clkdet_refclk = xhdmiphy_read(inst, XHDMIPHY_CLKDET_FREQ_RX_REG);
+	pll_prm = &inst->quad.plls[XHDMIPHY_CH2IDX(chid)].pll_param;
+
+	if (inst->conf.gt_type != XHDMIPHY_GTYE5) {
+		dru_refclk = xhdmiphy_get_dru_refclk(inst);
+		/* take the master channel (channel 1) */
+		ch_ptr = &inst->quad.ch1;
+		if (chid == XHDMIPHY_CHID_CMN0 || chid == XHDMIPHY_CHID_CMN1) {
+			fdru_clk = (dru_refclk * pll_prm->nfb_div) /
+				    (pll_prm->m_refclk_div *
+				     (ch_ptr->rx_outdiv * 20));
+		} else {
+			fdru_clk = (dru_refclk * ch_ptr->pll_param.n1fb_div *
+				    ch_ptr->pll_param.n2fb_div * 2) /
+				    (ch_ptr->pll_param.m_refclk_div *
+				    ch_ptr->rx_outdiv * 20);
+		}
+	} else {
+		fdru_clk = (u64)(XHDMIPHY_HDMI_GTYE5_DRU_LRATE / 20);
+	}
+
+	data_rate = 10 * clkdet_refclk;
+	f_din = data_rate * ((u64)1 << 32);
+
+	if (f_din && fdru_clk)
+		return (f_din / fdru_clk);
+
+	return 0;
+}
+
+/**
+ * xhdmiphy_dir_reconf - This function will set the current RX/TX configuration
+ * over DRP.
+ *
+ * @inst:	inst is a pointer to the xhdmiphy core instance
+ * @chid:	chid is the channel ID for which to write the settings for
+ * @dir:	dir is an indicator for RX or TX
+ *
+ * @return:	- 0 if the configuration was successful
+ *		- 1 otherwise
+ */
+static bool xhdmiphy_dir_reconf(struct xhdmiphy_dev *inst, enum chid chid, enum dir dir)
+{
+	u32 status = 0;
+	u8 id, id0, id1;
+
+	xhdmiphy_ch2ids(inst, chid, &id0, &id1);
+	for (id = id0; id <= id1; id++) {
+		if (dir == XHDMIPHY_DIR_TX)
+			status |= xhdmiphy_txch_reconf(inst, id);
+		else
+			status |= xhdmiphy_rxch_reconf(inst, id);
+
+		if (status != 0)
+			return true;
+	}
+
+	return status;
+}
+
+/**
+ * xhdmiphy_clk_reconf - This function will set the current clocking settings
+ * for each channel to hardware based on the configuration stored in the
+ * driver's instance. hardware based on the configuration stored in the driver's
+ * instance.
+ *
+ * @inst:	inst is a pointer to the xhdmiphy core instance
+ * @chid:	chid is the channel ID for which to write the settings for
+ *
+ * @return:	- 0 if the configuration was successful
+ *		- 1 otherwise
+ */
+static bool xhdmiphy_clk_reconf(struct xhdmiphy_dev *inst, enum chid chid)
+{
+	u32 status = 0;
+	u8 id, id0, id1;
+
+	xhdmiphy_ch2ids(inst, chid, &id0, &id1);
+	for (id = id0; id <= id1; id++) {
+		if (xhdmiphy_is_ch(id)) {
+			status |= xhdmiphy_clk_ch_reconf(inst, (enum chid)id);
+		} else if (xhdmiphy_is_cmn(chid)) {
+			if (((xhdmiphy_is_hdmi(inst, XHDMIPHY_DIR_TX)) ||
+			     (xhdmiphy_is_hdmi(inst, XHDMIPHY_DIR_RX))) &&
+			     inst->qpll_present == 0) {
+				dev_err(inst->dev,
+					"return failure: qpll is not present\n");
+				return false;
+			}
+			status |= xhdmiphy_clk_cmn_reconf(inst, (enum chid)id);
+		}
+		if (status)
+			return false;
+	}
+
+	return status;
+}
+
+/**
+ * xhdmiphy_get_rcfg_chid - obtain the reconfiguration channel ID for given
+ * PLL type
+ *
+ * @pll_type:	pll_type is the PLL type being used by the channel
+ *
+ * @return:	The Channel ID to be used for reconfiguration
+ */
+static u8 xhdmiphy_get_rcfg_chid(enum pll_type pll_type)
+{
+	enum chid chid;
+
+	switch (pll_type) {
+	case XHDMIPHY_PLL_QPLL:
+	case XHDMIPHY_PLL_QPLL0:
+	case XHDMIPHY_PLL_LCPLL:
+		chid = XHDMIPHY_CHID_CMN0;
+		break;
+	case XHDMIPHY_PLL_QPLL1:
+	case XHDMIPHY_PLL_RPLL:
+		chid = XHDMIPHY_CHID_CMN1;
+		break;
+	default:
+		chid = XHDMIPHY_CHID_CHA;
+		break;
+	}
+
+	return chid;
+}
+
+/*
+ * This function sets the system clock selection
+ *
+ * @inst:	inst is a pointer to the xhmdiphy core instance
+ *
+ * @return:	none
+ */
+static void xhdmiphy_set_sys_clksel(struct xhdmiphy_dev *inst)
+{
+	if (inst->conf.tx_pllclk_sel == inst->conf.rx_pllclk_sel) {
+		if (inst->conf.rx_pllclk_sel ==
+		    XHDMIPHY_SYSCLKSELDATA_CPLL_OUTCLK)
+			xhdmiphy_pll_init(inst, XHDMIPHY_CHID_CHA,
+					  inst->conf.rx_refclk_sel,
+					  inst->conf.rx_refclk_sel,
+					  XHDMIPHY_PLL_CPLL,
+					  XHDMIPHY_PLL_CPLL);
+		else
+			xhdmiphy_pll_init(inst, XHDMIPHY_CHID_CMN0,
+					  inst->conf.rx_refclk_sel,
+					  inst->conf.rx_refclk_sel,
+					  XHDMIPHY_PLL_QPLL0,
+					  XHDMIPHY_PLL_QPLL0);
+	} else if (inst->conf.tx_pllclk_sel ==
+					XHDMIPHY_SYSCLKSELDATA_CPLL_OUTCLK) {
+		xhdmiphy_pll_init(inst, XHDMIPHY_CHID_CHA,
+				  inst->conf.rx_refclk_sel,
+				  inst->conf.tx_refclk_sel,
+				  XHDMIPHY_PLL_CPLL,
+				  XHDMIPHY_PLL_QPLL0);
+	} else {
+		xhdmiphy_pll_init(inst, XHDMIPHY_CHID_CMN0,
+				  inst->conf.tx_refclk_sel,
+				  inst->conf.rx_refclk_sel,
+				  XHDMIPHY_PLL_QPLL0,
+				  XHDMIPHY_PLL_CPLL);
+	}
+}
+
+/**
+ * xhdmiphy_mmcm_clkin_sel - This function will set the CLKINSEL port
+ * of theMMCM
+ *
+ * @inst:	inst is a pointer to the xhdmiphy core instance
+ * @dir:	dir is an indicator for TX or RX
+ * @sel:	sel CLKINSEL value
+ *		0 - CLKIN1
+ *		1 - CLKIN2
+ */
+static void xhdmiphy_mmcm_clkin_sel(struct xhdmiphy_dev *inst, enum dir dir,
+				    enum mmcmclk_insel sel)
+{
+	u32 reg_off, reg_val;
+
+	if (dir == XHDMIPHY_DIR_TX)
+		reg_off = XHDMIPHY_MMCM_TXUSRCLK_CTRL_REG;
+	else
+		reg_off = XHDMIPHY_MMCM_RXUSRCLK_CTRL_REG;
+
+	reg_val = xhdmiphy_read(inst, reg_off);
+
+	if (sel == XHDMIPHY_MMCM_CLKINSEL_CLKIN2)
+		reg_val &= ~XHDMIPHY_MMCM_USRCLK_CTRL_CLKINSEL_MASK;
+	else
+		reg_val |= XHDMIPHY_MMCM_USRCLK_CTRL_CLKINSEL_MASK;
+
+	xhdmiphy_write(inst, reg_off, reg_val);
+}
+
+/**
+ * xhdmiphy_reset_gtpll - This function will reset the GT's PLL logic.
+ *
+ * @inst:	inst is a pointer to the xhdmiphy core instance
+ * @chid:	chid is the channel ID which to operate on
+ * @dir:	dir is an indicator for TX or RX
+ * @hold:	hold is an indicator whether to "hold" the reset if set to 1.
+ *		If set to 0: reset, then enable.
+ */
+static void xhdmiphy_reset_gtpll(struct xhdmiphy_dev *inst, enum chid chid,
+				 enum dir dir, u8 hold)
+{
+	u32 reg_val, mask_val, reg_off;
+
+	if (dir == XHDMIPHY_DIR_TX)
+		reg_off = XHDMIPHY_TX_INIT_REG;
+	else
+		reg_off = XHDMIPHY_RX_INIT_REG;
+
+	if (chid == XHDMIPHY_CHID_CHA)
+		mask_val = XHDMIPHY_TXRX_INIT_PLLGTRESET_ALL_MASK;
+	else
+		mask_val = XHDMIPHY_TXRX_INIT_PLLGTRESET_MASK(chid);
+
+	reg_val = xhdmiphy_read(inst, reg_off);
+	reg_val |= mask_val;
+	xhdmiphy_write(inst, reg_off, reg_val);
+
+	if (!hold) {
+		reg_val &= ~mask_val;
+		xhdmiphy_write(inst, reg_off, reg_val);
+	}
+}
+
+u32 xhdmiphy_init_phy(struct xhdmiphy_dev *inst)
+{
+	u8 id, id0, id1;
+
+	xhdmiphy_cfg_init(inst);
+
+	xhdmiphy_ch2ids(inst, XHDMIPHY_CHID_CHA, &id0, &id1);
+	for (id = id0; id <= id1; id++) {
+		inst->quad.plls[XHDMIPHY_CH2IDX(id)].tx_state =
+			XHDMIPHY_GT_STATE_IDLE;
+		inst->quad.plls[XHDMIPHY_CH2IDX(id)].rx_state =
+			XHDMIPHY_GT_STATE_IDLE;
+		if (inst->conf.transceiver_width == 2) {
+			inst->quad.plls[XHDMIPHY_CH2IDX(id)].tx_data_width = 20;
+			inst->quad.plls[XHDMIPHY_CH2IDX(id)].tx_intdata_width = 2;
+			inst->quad.plls[XHDMIPHY_CH2IDX(id)].rx_data_width = 20;
+			inst->quad.plls[XHDMIPHY_CH2IDX(id)].rx_intdata_width = 2;
+		} else {
+			inst->quad.plls[XHDMIPHY_CH2IDX(id)].tx_data_width = 40;
+			inst->quad.plls[XHDMIPHY_CH2IDX(id)].tx_intdata_width = 4;
+			inst->quad.plls[XHDMIPHY_CH2IDX(id)].rx_data_width = 40;
+			inst->quad.plls[XHDMIPHY_CH2IDX(id)].rx_intdata_width = 4;
+		}
+	}
+	xhdmiphy_clr(inst, XHDMIPHY_CLKDET_CTRL_REG,
+		     XHDMIPHY_CLKDET_CTRL_RUN_MASK);
+
+	/* sets clock detector frequency lock counter threshold value */
+	xhdmiphy_write(inst, XHDMIPHY_CLKDET_FREQ_TMR_TO_REG,
+		       inst->conf.axilite_freq);
+	xhdmiphy_clkdet_freq_threshold(inst, 40);
+
+	if (inst->conf.gt_type != XHDMIPHY_GTYE5) {
+		xhdmiphy_set_sys_clksel(inst);
+
+		/* indicate of QPLL is present in design */
+		if ((xhdmiphy_is_using_qpll(inst, XHDMIPHY_CHID_CH1,
+					    XHDMIPHY_DIR_TX) &&
+		     (xhdmiphy_is_hdmi(inst, XHDMIPHY_DIR_TX))) ||
+		    (xhdmiphy_is_using_qpll(inst, XHDMIPHY_CHID_CH1,
+					    XHDMIPHY_DIR_RX) &&
+		     (xhdmiphy_is_hdmi(inst, XHDMIPHY_DIR_RX)))) {
+			inst->qpll_present = true;
+		} else {
+			inst->qpll_present = false;
+		}
+
+		if (inst->conf.gt_type == XHDMIPHY_GTTYPE_GTHE4 ||
+		    inst->conf.gt_type == XHDMIPHY_GTTYPE_GTYE4) {
+			xhdmiphy_set_bufgtdiv(inst, XHDMIPHY_DIR_TX, 1);
+			xhdmiphy_set_bufgtdiv(inst, XHDMIPHY_DIR_RX, 1);
+		}
+		xhdmiphy_powerdown_gtpll(inst, XHDMIPHY_CHID_CMNA, true);
+		xhdmiphy_powerdown_gtpll(inst, XHDMIPHY_CHID_CHA, true);
+		xhdmiphy_reset_gtpll(inst, XHDMIPHY_CHID_CHA,
+				     XHDMIPHY_DIR_RX, true);
+		xhdmiphy_reset_gtpll(inst, XHDMIPHY_CHID_CHA,
+				     XHDMIPHY_DIR_TX, true);
+	}
+
+	xhdmiphy_mmcm_reset(inst, XHDMIPHY_DIR_TX, true);
+	xhdmiphy_mmcm_reset(inst, XHDMIPHY_DIR_RX, true);
+
+	if (xhdmiphy_is_hdmi(inst, XHDMIPHY_DIR_TX))
+		xhdmiphy_ibufds_en(inst, XHDMIPHY_DIR_TX, (false));
+
+	if (xhdmiphy_is_hdmi(inst, XHDMIPHY_DIR_RX))
+		xhdmiphy_ibufds_en(inst, XHDMIPHY_DIR_RX, (false));
+
+	/* dru Settings */
+	if (inst->conf.dru_present) {
+		xhdmiphy_ibufds_en(inst, XHDMIPHY_DIR_RX, true);
+		xhdmiphy_dru_reset(inst, XHDMIPHY_CHID_CHA, true);
+		xhdmiphy_dru_en(inst, XHDMIPHY_CHID_CHA, false);
+	}
+
+	if (inst->conf.gt_type != XHDMIPHY_GTYE5)
+		xhdmiphy_set_rxlpm(inst, XHDMIPHY_CHID_CHA,
+				   XHDMIPHY_DIR_RX, 0);
+
+	xhdmiphy_ch2ids(inst, XHDMIPHY_CHID_CHA, &id0, &id1);
+	for (id = id0; id <= id1; id++) {
+		if (inst->conf.gt_type != XHDMIPHY_GTYE5)
+			xhdmiphy_set_tx_vs(inst, (enum chid)id,
+					   XHDMIPHY_HDMI_GTHE4_DEFAULT_VS_VAL);
+		else
+			xhdmiphy_set_tx_vs(inst, (enum chid)id,
+					   XHDMIPHY_HDMI_DEFAULT_VS_VAL);
+
+		xhdmiphy_set_tx_pe(inst, (enum chid)id,
+				   XHDMIPHY_HDMI_DEFAULT_PC_PE_VAL);
+		xhdmiphy_set_tx_pc(inst, (enum chid)id,
+				   XHDMIPHY_HDMI_DEFAULT_PC_PE_VAL);
+	}
+
+	/* clear interrupt register */
+	xhdmiphy_write(inst, XHDMIPHY_INTR_STS_REG, XHDMIPHY_INTR_STS_ALL_MASK);
+
+	/* interrupt enable */
+	xhdmiphy_intr_en(inst, XHDMIPHY_INTR_TXRESETDONE_MASK |
+			 XHDMIPHY_INTR_RXRESETDONE_MASK);
+
+	if (inst->conf.gt_type != XHDMIPHY_GTYE5) {
+		xhdmiphy_intr_en(inst, XHDMIPHY_INTR_CPLL_LOCK_MASK |
+				 XHDMIPHY_INTR_QPLL_LOCK_MASK |
+				 XHDMIPHY_INTR_TXALIGNDONE_MASK |
+				 XHDMIPHY_INTR_QPLL1_LOCK_MASK);
+	} else {
+		xhdmiphy_intr_en(inst, XHDMIPHY_INTR_LCPLL_LOCK_MASK |
+				 XHDMIPHY_INTR_RPLL_LOCK_MASK |
+				 XHDMIPHY_INTR_TXGPO_RE_MASK |
+				 XHDMIPHY_INTR_RXGPO_RE_MASK);
+	}
+
+	xhdmiphy_intr_en(inst, XHDMIPHY_INTR_TXFREQCHANGE_MASK |
+			 XHDMIPHY_INTR_RXFREQCHANGE_MASK |
+			 XHDMIPHY_INTR_TXMMCMUSRCLK_LOCK_MASK |
+			 XHDMIPHY_INTR_TXTMRTIMEOUT_MASK |
+			 XHDMIPHY_INTR_RXTMRTIMEOUT_MASK |
+			 XHDMIPHY_INTR_RXMMCMUSRCLK_LOCK_MASK);
+
+	xhdmiphy_set(inst, XHDMIPHY_CLKDET_CTRL_REG,
+		     XHDMIPHY_CLKDET_CTRL_RUN_MASK);
+
+	return 0;
+}
+
+/**
+ * xhdmiphy_tx_align_rst - This function resets the GT TX alignment module.
+ *
+ * @inst:	inst is a pointer to the xhdmiphy core instance
+ * @chid:	chid is the channel ID to operate on
+ * @rst:	rst specifies true/false value to either assert or deassert
+ *		reset on the TX alignment module, respectively
+ */
+static void xhdmiphy_tx_align_rst(struct xhdmiphy_dev *inst, enum chid chid,
+				  u8 rst)
+{
+	u32 reg_val, mask_val = 0;
+	u8 id, id0, id1;
+
+	/* read Tx align register */
+	reg_val = xhdmiphy_read(inst, XHDMIPHY_TX_BUFFER_BYPASS_REG);
+
+	xhdmiphy_ch2ids(inst, chid, &id0, &id1);
+	for (id = id0; id <= id1; id++)
+		mask_val |= XHDMIPHY_TX_BUFFER_BYPASS_TXPHDLYRESET_MASK(id);
+
+	xhdmiphy_set_clr(inst, XHDMIPHY_TX_BUFFER_BYPASS_REG, reg_val, mask_val,
+			 rst);
+}
+
+/**
+ * xhdmiphy_tx_align_start - This function resets the GT TX alignment module.
+ *
+ * @inst:	inst is a pointer to the xhdmiphy core instance
+ * @chid:	chid is the channel ID to operate on
+ * @start:	Start specifies true/false value to either start or ttop the TX
+ *		alignment module, respectively
+ */
+static void xhdmiphy_tx_align_start(struct xhdmiphy_dev *inst, enum chid chid,
+				    u8 start)
+{
+	u32 reg_val,  mask_val = 0;
+	u8 id, id0, id1;
+
+	reg_val = xhdmiphy_read(inst, XHDMIPHY_TX_BUFFER_BYPASS_REG);
+
+	xhdmiphy_ch2ids(inst, chid, &id0, &id1);
+	for (id = id0; id <= id1; id++)
+		mask_val |= XHDMIPHY_TX_BUFFER_BYPASS_TXPHALIGN_MASK(id);
+
+	xhdmiphy_set_clr(inst, XHDMIPHY_TX_BUFFER_BYPASS_REG, reg_val, mask_val,
+			 start);
+}
+
+static void xhdmiphy_txgpo_risingedge_handler(struct xhdmiphy_dev *inst)
+{
+	u8 id, id0, id1;
+
+	xhdmiphy_check_linerate_cfg(inst, XHDMIPHY_CHID_CH1, XHDMIPHY_DIR_TX);
+	xhdmiphy_set_gpi(inst, XHDMIPHY_CHID_CHA, XHDMIPHY_DIR_TX, false);
+
+	/* wait for GPO TX = 0 */
+	while (xhdmiphy_get_gpo(inst, XHDMIPHY_CHID_CHA, XHDMIPHY_DIR_TX))
+		;
+
+	xhdmiphy_mmcm_start(inst, XHDMIPHY_DIR_TX);
+
+	xhdmiphy_dir_reconf(inst, XHDMIPHY_CHID_CHA, XHDMIPHY_DIR_TX);
+
+	/* deassert reset on GT Reset IP TX */
+	xhdmiphy_write(inst, XHDMIPHY_COMMON_INIT_REG,
+		       (xhdmiphy_read(inst,
+		       XHDMIPHY_COMMON_INIT_REG) & ~0x1));
+	xhdmiphy_ch2ids(inst, XHDMIPHY_CHID_CHA, &id0, &id1);
+	for (id = id0; id <= id1; id++) {
+		inst->quad.plls[XHDMIPHY_CH2IDX(id)].tx_state =
+						XHDMIPHY_GT_STATE_LOCK;
+	}
+}
+
+/**
+ * xhdmiphy_lcpll_param - This function calculates the lcpll parameters.
+ *
+ * @inst:	inst is a pointer to the HDMI GT core instance
+ * @chid:	chid is the channel ID to operate on
+ * @dir:	dir is an indicator for RX or TX
+ *
+ * @return:	- 0 if calculated LCPLL parameters updated successfully
+ *		- 1 if parameters not updated
+ */
+static u32 xhdmiphy_lcpll_param(struct xhdmiphy_dev *inst, enum chid chid,
+				enum dir dir)
+{
+	u64 linerate = 0;
+	u32 status = 0;
+	u32 *refclk_ptr;
+	u8 tmdsclk_ratio = 0, is_hdmi21 = 0;
+
+	/* pre-calculation */
+	if (dir == XHDMIPHY_DIR_RX) {
+		refclk_ptr = &inst->rx_refclk_hz;
+		is_hdmi21 = inst->rx_hdmi21_cfg.is_en;
+		tmdsclk_ratio = inst->rx_tmdsclock_ratio;
+
+		/* calculate line rate */
+		if (is_hdmi21)
+			linerate = inst->rx_hdmi21_cfg.linerate;
+		else
+			linerate = (u64)(*refclk_ptr) *
+				   ((tmdsclk_ratio ? 40 : 10));
+
+		inst->rx_dru_enabled = 0;
+
+		/* enable DRU based on incoming REFCLK */
+		if (!is_hdmi21 && !tmdsclk_ratio &&
+		    inst->rx_refclk_hz < XHDMIPHY_LCPLL_MIN_REFCLK) {
+			if (inst->conf.dru_present) {
+				/* check DRU frequency */
+				if (xhdmiphy_get_dru_refclk(inst) == 1) {
+					dev_err(inst->dev,
+						"cannot get dru refclk\n");
+					return 1;
+				}
+
+				inst->rx_dru_enabled = 1;
+				linerate = XHDMIPHY_HDMI_GTYE5_DRU_LRATE;
+			} else {
+				dev_err(inst->dev, "dru is not present\n");
+				return 1;
+			}
+		}
+	} else {
+		refclk_ptr = &inst->tx_refclk_hz;
+		is_hdmi21 = inst->tx_hdmi21_cfg.is_en;
+		inst->tx_samplerate = 1;
+
+		if (!is_hdmi21) {
+			/* Determine if HDMI 2.0 mode */
+			if (*refclk_ptr >= XHDMIPHY_HDMI20_REFCLK_RANGE7) {
+				tmdsclk_ratio = 1;
+				(*refclk_ptr) = (*refclk_ptr) / 4;
+			} else if (*refclk_ptr >=
+				   XHDMIPHY_HDMI20_REFCLK_RANGE5) {
+			/* check for x1 Over sampling mode */
+				inst->tx_samplerate = 1;
+			} else if (*refclk_ptr >=
+				   XHDMIPHY_HDMI20_REFCLK_RANGE3) {
+			/* check for x2 Over sampling mode */
+				inst->tx_samplerate = 2;
+				(*refclk_ptr) = (*refclk_ptr) * 2;
+			} else if (*refclk_ptr >=
+				   XHDMIPHY_HDMI20_REFCLK_RANGE1) {
+			/* check for x3 Over sampling mode */
+				inst->tx_samplerate = 3;
+				(*refclk_ptr) = (*refclk_ptr) * 3;
+			} else if (*refclk_ptr <
+				   XHDMIPHY_HDMI20_REFCLK_RANGE1) {
+			/* check for x5 Over sampling mode */
+				inst->tx_samplerate = 5;
+				(*refclk_ptr) = (*refclk_ptr) * 5;
+			}
+		}
+
+		if (is_hdmi21)
+			linerate = inst->tx_hdmi21_cfg.linerate;
+		else
+			linerate = (u64)(*refclk_ptr) *
+						((tmdsclk_ratio ? 40 : 10));
+	}
+
+	/* check for DRU mode */
+	if (dir == XHDMIPHY_DIR_RX &&
+	    inst->rx_dru_enabled) {
+		inst->quad.lcpll.linerate_cfg = 0;
+	} else if (!is_hdmi21) {
+		/* check for HDMI 1.4/2.0 GT linerate config */
+		/* HDMI 1.4 */
+		if (!tmdsclk_ratio) {
+			if ((XHDMIPHY_HDMI14_REFCLK_RANGE1 <= (*refclk_ptr)) &&
+			    ((*refclk_ptr) <= XHDMIPHY_HDMI14_REFCLK_RANGE2)) {
+				inst->quad.lcpll.linerate_cfg = 1;
+			} else if ((XHDMIPHY_HDMI14_REFCLK_RANGE3 <= (*refclk_ptr)) &&
+						/* 297 MHz + 0.5% + 10 KHz error */
+						((*refclk_ptr) <=
+						 XHDMIPHY_HDMI14_REFCLK_RANGE3)) {
+				inst->quad.lcpll.linerate_cfg = 2;
+			} else {
+				status = 1;
+			}
+		} else {
+			/* HDMI 2.0 */
+			if ((XHDMIPHY_HDMI20_REFCLK_RANGE2 <= (*refclk_ptr)) &&
+			    ((*refclk_ptr) <= XHDMIPHY_HDMI20_REFCLK_RANGE4)) {
+				inst->quad.lcpll.linerate_cfg = 3;
+			} else if ((XHDMIPHY_HDMI20_REFCLK_RANGE4 <= (*refclk_ptr)) &&
+				   ((*refclk_ptr) <=
+				    XHDMIPHY_HDMI20_REFCLK_RANGE6)) {
+				inst->quad.lcpll.linerate_cfg = 4;
+			} else {
+				status = 1;
+			}
+		}
+	} else if (is_hdmi21) {
+		/* check for HDMI 2.1 GT linerate config */
+		if (linerate == XHDMIPHY_LRATE_3G)
+			inst->quad.lcpll.linerate_cfg = 5;
+		else if (linerate == XHDMIPHY_LRATE_6G)
+			inst->quad.lcpll.linerate_cfg = 6;
+		else if (linerate == XHDMIPHY_LRATE_8G)
+			inst->quad.lcpll.linerate_cfg = 7;
+		else if (linerate == XHDMIPHY_LRATE_10G)
+			inst->quad.lcpll.linerate_cfg = 8;
+		else if (linerate == XHDMIPHY_LRATE_12G)
+			inst->quad.lcpll.linerate_cfg = 9;
+		else
+			status = 1;
+	}
+
+	xhdmiphy_cfg_linerate(inst, XHDMIPHY_CHID_CMN0, linerate);
+
+	if (status == 1)
+		dev_err(inst->dev, "failed to configure lcpll params\n");
+
+	return status;
+}
+
+/**
+ * xhdmiphy_rpll_param - This function calculates the rpll parameters.
+ *
+ * @inst:	inst is a pointer to the HDMI GT core instance
+ * @chid:	chid is the channel Id to operate on
+ * @dir:	dir is an indicator for Rx or Tx
+ *
+ * @return:	- 0 if calculated RPLL parameters updated successfully
+ *		- 1 if parameters not updated
+ */
+static u32 xhdmiphy_rpll_param(struct xhdmiphy_dev *inst, enum chid chid,
+			       enum dir dir)
+{
+	u64 linerate = 0;
+	u32 status = 0;
+	u32 *refclk_ptr;
+	u8 tmdsclk_ratio = 0, is_hdmi21 = 0;
+
+	/* Pre-calculation */
+	if (dir == XHDMIPHY_DIR_RX) {
+		refclk_ptr = &inst->rx_refclk_hz;
+		is_hdmi21 = inst->tx_hdmi21_cfg.is_en;
+		tmdsclk_ratio = inst->rx_tmdsclock_ratio;
+
+		/* calculate line rate */
+		if (is_hdmi21) {
+			linerate = inst->rx_hdmi21_cfg.linerate;
+		} else {
+			linerate = (u64)(*refclk_ptr) *
+						((tmdsclk_ratio ? 40 : 10));
+		}
+
+		inst->rx_dru_enabled = 0;
+
+		/* enable DRU based on incoming REFCLK */
+		if (!is_hdmi21 && !tmdsclk_ratio &&
+		    inst->rx_refclk_hz < XHDMIPHY_RPLL_MIN_REFCLK) {
+			if (inst->conf.dru_present) {
+				/* check DRU frequency */
+				if (xhdmiphy_get_dru_refclk(inst) == 1) {
+					dev_err(inst->dev,
+						"cannot get dru refclk\n");
+					return 1;
+				}
+
+				inst->rx_dru_enabled = 1;
+				linerate = XHDMIPHY_HDMI_GTYE5_DRU_LRATE;
+			} else {
+				dev_err(inst->dev, "dru is not present\n");
+				return 1;
+			}
+		}
+	} else {
+		refclk_ptr = &inst->tx_refclk_hz;
+		is_hdmi21 = inst->tx_hdmi21_cfg.is_en;
+		inst->tx_samplerate = 1;
+
+		if (!is_hdmi21) {
+			/* determine if HDMI 2.0 mode */
+			if (*refclk_ptr >= XHDMIPHY_HDMI20_REFCLK_RANGE7) {
+				tmdsclk_ratio = 1;
+				(*refclk_ptr) = (*refclk_ptr) / 4;
+			} else if (*refclk_ptr >=
+				   XHDMIPHY_HDMI20_REFCLK_RANGE5) {
+			/* check for x1 over sampling mode */
+				inst->tx_samplerate = 1;
+			} else if (*refclk_ptr >=
+				   XHDMIPHY_HDMI20_REFCLK_RANGE3) {
+			/* check for x2 Over sampling mode */
+				inst->tx_samplerate = 2;
+				(*refclk_ptr) = (*refclk_ptr) * 2;
+			} else if (*refclk_ptr >=
+				   XHDMIPHY_HDMI20_REFCLK_RANGE1) {
+			/* check for x3 Over sampling mode */
+				inst->tx_samplerate = 3;
+				(*refclk_ptr) = (*refclk_ptr) * 3;
+			/* check for x5 Over sampling mode */
+			} else if (*refclk_ptr <
+				   XHDMIPHY_HDMI20_REFCLK_RANGE1) {
+				inst->tx_samplerate = 5;
+				(*refclk_ptr) = (*refclk_ptr) * 5;
+			}
+		}
+
+		/* calculate line rate */
+		if (is_hdmi21)
+			linerate = inst->tx_hdmi21_cfg.linerate;
+		else
+			linerate = (u64)(*refclk_ptr) * ((tmdsclk_ratio ? 40 : 10));
+	}
+
+	/* check for DRU mode */
+	if (dir == XHDMIPHY_DIR_RX && inst->rx_dru_enabled) {
+		inst->quad.rpll.linerate_cfg = 0;
+	/* check for HDMI 1.4/2.0 GT linerate config */
+	} else if (!is_hdmi21) {
+		/* HDMI 1.4 */
+		if (!tmdsclk_ratio) {
+			if ((XHDMIPHY_HDMI14_REFCLK_RANGE1 <= (*refclk_ptr)) &&
+			    ((*refclk_ptr) <= 200000000)) {
+				inst->quad.rpll.linerate_cfg = 1;
+			} else if ((200000000 <= (*refclk_ptr)) &&
+				   ((*refclk_ptr) <=
+				    XHDMIPHY_HDMI14_REFCLK_RANGE3)) {
+				inst->quad.rpll.linerate_cfg = 2;
+			} else {
+				status = 1;
+			}
+		/* HDMI 2.0 */
+		} else {
+			if ((XHDMIPHY_HDMI20_REFCLK_RANGE2 <= (*refclk_ptr)) &&
+			    ((*refclk_ptr) <= 100000000)) {
+				inst->quad.rpll.linerate_cfg = 3;
+			} else if ((100000000 <= (*refclk_ptr)) &&
+				   ((*refclk_ptr) <=
+				    XHDMIPHY_HDMI20_REFCLK_RANGE6)) {
+				inst->quad.rpll.linerate_cfg = 4;
+			} else {
+				status = 1;
+			}
+		}
+	/* check for HDMI 2.1 gt linerate config */
+	} else if (is_hdmi21) {
+		if (linerate == XHDMIPHY_LRATE_3G)
+			inst->quad.rpll.linerate_cfg = 5;
+		else if (linerate == XHDMIPHY_LRATE_6G)
+			inst->quad.rpll.linerate_cfg = 6;
+		else if (linerate == XHDMIPHY_LRATE_8G)
+			inst->quad.rpll.linerate_cfg = 7;
+		else if (linerate == XHDMIPHY_LRATE_10G)
+			inst->quad.rpll.linerate_cfg = 8;
+		else if (linerate == XHDMIPHY_LRATE_12G)
+			inst->quad.rpll.linerate_cfg = 9;
+		else
+			status = 1;
+	}
+
+	/* update line rate value */
+	xhdmiphy_cfg_linerate(inst, XHDMIPHY_CHID_CMN1, linerate);
+	if (status == 1)
+		dev_err(inst->dev, "failed to configure rpll params\n");
+
+	return status;
+}
+
+/**
+ * xhdmiphy_txpll_param - This function calculates the Tx pll parameters.
+ *
+ * @inst:	inst is a pointer to the HDMI GT core instance
+ * @chid:	chid is the channel ID to operate on
+ *
+ * @return:	- 0 if calculated qpll parameters updated successfully
+ *		- 1 if parameters not updated
+ */
+static u32 xhdmiphy_txpll_param(struct xhdmiphy_dev *inst, enum chid chid)
+{
+	enum pll_type pll_type;
+
+	pll_type = xhdmiphy_get_pll_type(inst, XHDMIPHY_DIR_TX,
+					 XHDMIPHY_CHID_CH1);
+
+	if (pll_type == XHDMIPHY_PLL_LCPLL)
+		return xhdmiphy_lcpll_param(inst, chid, XHDMIPHY_DIR_TX);
+
+	return xhdmiphy_rpll_param(inst, chid, XHDMIPHY_DIR_TX);
+}
+
+/**
+ * xhdmiphy_rxpll_param - This function calculates the Rx pll parameters.
+ *
+ * @inst:	inst is a pointer to the HDMI GT core instance
+ * @chid:	chid is the channel id to operate on
+ *
+ * @return:	- 0 if calculated qpll parameters updated
+ *		successfully
+ *		- 1 if parameters not updated
+ */
+static bool xhdmiphy_rxpll_param(struct xhdmiphy_dev *inst, enum chid chid)
+{
+	enum pll_type pll_type;
+
+	pll_type = xhdmiphy_get_pll_type(inst, XHDMIPHY_DIR_RX,
+					 XHDMIPHY_CHID_CH1);
+
+	if (pll_type == XHDMIPHY_PLL_LCPLL)
+		return xhdmiphy_lcpll_param(inst, chid, XHDMIPHY_DIR_RX);
+
+	return xhdmiphy_rpll_param(inst, chid, XHDMIPHY_DIR_RX);
+}
+
+/**
+ * xhdmiphy_set_tx_param - This function update/set the HDMI TX parameter.
+ *
+ * @inst:		is a pointer to the Hdmiphy core instance
+ * @chid:		chid is the channel ID to operate on
+ * @ppc:		ppc is the pixels per clock to set
+ * @bpc:		bpc is the bits per color to set
+ * @fmt:		fmt is the color format to set
+ *
+ * @return:
+ *		- 0 if TX parameters set/updated
+ *		- gc if low resolution video not supported
+ */
+u32 xhdmiphy_set_tx_param(struct xhdmiphy_dev *inst, enum chid chid,
+			  enum ppc ppc, enum color_depth bpc,
+			  enum color_fmt fmt)
+{
+	u32 status;
+
+	if (inst->conf.gt_type != XHDMIPHY_GTYE5) {
+		/*
+		 * only calculate the QPLL/CPLL parameters when the GT TX and
+		 * RX are not coupled
+		 */
+		if (xhdmiphy_is_tx_using_cpll(inst, chid)) {
+			status = xhdmiphy_cpll_param(inst, chid, XHDMIPHY_DIR_TX);
+		} else {
+			status = xhdmiphy_qpll_param(inst, chid, XHDMIPHY_DIR_TX);
+			/* update sysClk and PLL clk registers immediately */
+			xhdmiphy_write_refclksel(inst);
+		}
+	} else {
+		status = xhdmiphy_txpll_param(inst, chid);
+	}
+
+	if (status == 1)
+		return status;
+
+	/* Is HDMITXSS PPC match with HDMIPHY PPC? */
+	if (ppc == inst->conf.ppc) {
+		status = 0;
+	} else {
+		dev_err(inst->dev,
+			"HDMITXSS ppc does't match with hdmiphy ppc\n");
+		status = 1;
+	}
+	if (status == 0) {
+		/* HDMI 2.1 */
+		if (inst->tx_hdmi21_cfg.is_en) {
+			xhdmiphy_mmcm_param(inst, XHDMIPHY_DIR_TX);
+
+			return status;
+		}
+
+		/*
+		 * calculate TXPLL parameters.
+		 * In HDMI the colordepth in YUV422 is always 12 bits,
+		 * although on the link itself it is being transmitted as
+		 * 8-bits. Therefore if the colorspace is YUV422, then force the
+		 * colordepth to 8 bits.
+		 */
+		if (fmt == XVIDC_CSF_YCRCB_422) {
+			status = xhdmiphy_cal_mmcm_param(inst, chid,
+							 XHDMIPHY_DIR_TX, ppc,
+							 XVIDC_BPC_8);
+		} else {
+			status = xhdmiphy_cal_mmcm_param(inst, chid,
+							 XHDMIPHY_DIR_TX, ppc,
+							 bpc);
+		}
+	} else {
+		status = 1;
+	}
+
+	return status;
+}
+
+static u32 xhdmiphy_set_rx_param(struct xhdmiphy_dev *inst, enum chid chid)
+{
+	u64 dru_center_freq;
+	u32 status;
+	enum chid ch_id = chid;
+	enum pll_type pll_type;
+
+	if (inst->conf.gt_type != XHDMIPHY_GTYE5) {
+		if (xhdmiphy_is_rx_using_cpll(inst, chid)) {
+			status = xhdmiphy_cpll_param(inst, chid,
+						     XHDMIPHY_DIR_RX);
+		} else {
+			status = xhdmiphy_qpll_param(inst, chid,
+						     XHDMIPHY_DIR_RX);
+			/* update SysClk and PLL clk registers immediately */
+			xhdmiphy_write_refclksel(inst);
+		}
+	} else {
+		status = xhdmiphy_rxpll_param(inst, chid);
+	}
+
+	if (inst->rx_dru_enabled) {
+		pll_type = xhdmiphy_get_pll_type(inst, XHDMIPHY_DIR_RX,
+						 XHDMIPHY_CHID_CH1);
+		/* update the chid */
+		ch_id = xhdmiphy_get_rcfg_chid(pll_type);
+		dru_center_freq = xhdmiphy_dru_cal_centerfreq(inst, ch_id);
+		xhdmiphy_set_dru_centerfreq(inst, XHDMIPHY_CHID_CHA,
+					    dru_center_freq);
+	}
+
+	return status;
+}
+
+static void xhdmiphy_tx_timertimeout_handler(struct xhdmiphy_dev *inst)
+{
+	enum chid chid;
+	enum pll_type pll_type;
+	u8 val_cmp, id, id0, id1;
+
+	if (inst->conf.gt_type != XHDMIPHY_GTYE5) {
+		pll_type = xhdmiphy_get_pll_type(inst, XHDMIPHY_DIR_TX,
+						 XHDMIPHY_CHID_CH1);
+		/* determine which channel(s) to operate on */
+		chid = xhdmiphy_get_rcfg_chid(pll_type);
+		xhdmiphy_mmcm_start(inst, XHDMIPHY_DIR_TX);
+		xhdmiphy_powerdown_gtpll(inst, (pll_type == XHDMIPHY_PLL_CPLL) ?
+					       XHDMIPHY_CHID_CHA :
+					       XHDMIPHY_CHID_CMNA,
+					       false);
+
+		if (pll_type != XHDMIPHY_PLL_CPLL)
+			xhdmiphy_write_refclksel(inst);
+
+		xhdmiphy_clk_reconf(inst, chid);
+		xhdmiphy_outdiv_reconf(inst, XHDMIPHY_CHID_CHA,
+				       XHDMIPHY_DIR_TX);
+		if (inst->conf.gt_type == XHDMIPHY_GTTYPE_GTHE4 ||
+		    inst->conf.gt_type == XHDMIPHY_GTTYPE_GTYE4) {
+			xhdmiphy_set_bufgtdiv(inst, XHDMIPHY_DIR_TX,
+					      (pll_type == XHDMIPHY_PLL_CPLL) ?
+					      inst->quad.plls->tx_outdiv :
+					      (inst->quad.plls->tx_outdiv != 16) ?
+					      inst->quad.plls->tx_outdiv :
+					      inst->quad.plls->tx_outdiv / 2);
+		}
+
+		xhdmiphy_dir_reconf(inst, XHDMIPHY_CHID_CHA,
+				    XHDMIPHY_DIR_TX);
+		/* assert PLL reset */
+		xhdmiphy_reset_gtpll(inst, XHDMIPHY_CHID_CHA,
+				     XHDMIPHY_DIR_TX, true);
+		/* de-assert PLL reset */
+		xhdmiphy_reset_gtpll(inst, XHDMIPHY_CHID_CHA,
+				     XHDMIPHY_DIR_TX, false);
+
+		if (inst->conf.gt_type == XHDMIPHY_GTTYPE_GTHE4 ||
+		    inst->conf.gt_type == XHDMIPHY_GTTYPE_GTYE4) {
+			xhdmiphy_tx_align_start(inst, chid, false);
+		}
+
+		xhdmiphy_ch2ids(inst, XHDMIPHY_CHID_CHA, &id0, &id1);
+		for (id = id0; id <= id1; id++) {
+			inst->quad.plls[XHDMIPHY_CH2IDX(id)].tx_state =
+							XHDMIPHY_GT_STATE_LOCK;
+		}
+	} else {
+		xhdmiphy_ch2ids(inst, XHDMIPHY_CHID_CHA, &id0, &id1);
+		for (id = id0; id <= id1; id++) {
+			inst->quad.plls[XHDMIPHY_CH2IDX(id)].tx_state =
+						XHDMIPHY_GT_STATE_GPO_RE;
+		}
+		/* compare the current and next CFG values */
+		val_cmp = xhdmiphy_check_linerate_cfg(inst,
+						      XHDMIPHY_CHID_CH1,
+						      XHDMIPHY_DIR_TX);
+		if (!val_cmp) {
+			xhdmiphy_set_gpi(inst, XHDMIPHY_CHID_CHA,
+					 XHDMIPHY_DIR_TX, true);
+		} else {
+			xhdmiphy_txgpo_risingedge_handler(inst);
+		}
+	}
+}
+
+static void xhdmiphy_rxgpo_risingedge_handler(struct xhdmiphy_dev *inst)
+{
+	u8 id, id0, id1;
+
+	xhdmiphy_check_linerate_cfg(inst, XHDMIPHY_CHID_CH1, XHDMIPHY_DIR_RX);
+	/* De-assert GPI port. */
+	xhdmiphy_set_gpi(inst, XHDMIPHY_CHID_CHA,
+			 XHDMIPHY_DIR_RX, false);
+
+	/* Wait for GPO RX = 0 */
+	while (xhdmiphy_get_gpo(inst, XHDMIPHY_CHID_CHA, XHDMIPHY_DIR_RX))
+		;
+
+	/* Configure RXRATE Port */
+	xhdmiphy_dir_reconf(inst, XHDMIPHY_CHID_CHA, XHDMIPHY_DIR_RX);
+	/* Deassert reset on GT Reset IP RX */
+	xhdmiphy_write(inst, XHDMIPHY_COMMON_INIT_REG,
+		       (xhdmiphy_read(inst,
+		       XHDMIPHY_COMMON_INIT_REG) & ~0x2));
+	xhdmiphy_ch2ids(inst, XHDMIPHY_CHID_CHA, &id0, &id1);
+	for (id = id0; id <= id1; id++) {
+		inst->quad.plls[XHDMIPHY_CH2IDX(id)].rx_state =
+						XHDMIPHY_GT_STATE_LOCK;
+	}
+}
+
+static void xhdmiphy_rx_timertimeout_handler(struct xhdmiphy_dev *inst)
+{
+	enum chid chid;
+	enum pll_type pll_type;
+	u32 status;
+	u8 id, id0, id1, val_cmp;
+
+	if (!inst->rx_hdmi21_cfg.is_en) {
+		dev_info(inst->dev, "xhdmi 2.0 protocl is enabled\n");
+	} else {
+		if (inst->conf.rx_refclk_sel == inst->conf.rx_frl_refclk_sel) {
+			xhdmiphy_mmcm_clkin_sel(inst, XHDMIPHY_DIR_RX,
+						XHDMIPHY_MMCM_CLKINSEL_CLKIN1);
+			xhdmiphy_mmcm_start(inst, XHDMIPHY_DIR_RX);
+		}
+	}
+
+	pll_type = xhdmiphy_get_pll_type(inst, XHDMIPHY_DIR_RX,
+					 XHDMIPHY_CHID_CH1);
+	/* determine which channel(s) to operate on */
+	chid = xhdmiphy_get_rcfg_chid(pll_type);
+	xhdmiphy_ch2ids(inst, XHDMIPHY_CHID_CHA, &id0, &id1);
+
+	status = xhdmiphy_set_rx_param(inst, chid);
+	if (status != 0) {
+		for (id = id0; id <= id1; id++) {
+			inst->quad.plls[XHDMIPHY_CH2IDX(id)].rx_state =
+							XHDMIPHY_GT_STATE_IDLE;
+		}
+
+		return;
+	}
+
+	/* enable DRU to set the clock muxes */
+	xhdmiphy_dru_en(inst, XHDMIPHY_CHID_CHA, inst->rx_dru_enabled);
+
+	xhdmiphy_dru_mode_en(inst, inst->rx_dru_enabled);
+
+	if (inst->conf.gt_type != XHDMIPHY_GTYE5) {
+		/* enable PLL */
+		xhdmiphy_powerdown_gtpll(inst, (pll_type == XHDMIPHY_PLL_CPLL) ?
+					 XHDMIPHY_CHID_CHA :
+					 XHDMIPHY_CHID_CMNA, false);
+
+		/* update reference clock election */
+		if (!inst->rx_hdmi21_cfg.is_en) {
+			xhdmiphy_pll_refclk_sel(inst,
+						((pll_type == XHDMIPHY_PLL_CPLL) ?
+						XHDMIPHY_CHID_CHA :
+						XHDMIPHY_CHID_CMNA),
+						((inst->rx_dru_enabled) ?
+						inst->conf.dru_refclk_sel :
+						inst->conf.rx_refclk_sel));
+		}
+		xhdmiphy_write_refclksel(inst);
+
+		pll_type = xhdmiphy_get_pll_type(inst, XHDMIPHY_DIR_RX,
+						 XHDMIPHY_CHID_CH1);
+		/* determine which channel(s) to operate on */
+		chid = xhdmiphy_get_rcfg_chid(pll_type);
+		xhdmiphy_clk_reconf(inst, chid);
+		xhdmiphy_outdiv_reconf(inst, XHDMIPHY_CHID_CHA,
+				       XHDMIPHY_DIR_RX);
+		xhdmiphy_dir_reconf(inst, XHDMIPHY_CHID_CHA,
+				    XHDMIPHY_DIR_RX);
+		/* assert RX PLL reset */
+		xhdmiphy_reset_gtpll(inst, XHDMIPHY_CHID_CHA,
+				     XHDMIPHY_DIR_RX, true);
+		/* de-assert RX PLL reset */
+		xhdmiphy_reset_gtpll(inst, XHDMIPHY_CHID_CHA,
+				     XHDMIPHY_DIR_RX, false);
+		for (id = id0; id <= id1; id++) {
+			inst->quad.plls[XHDMIPHY_CH2IDX(id)].rx_state =
+							XHDMIPHY_GT_STATE_LOCK;
+		}
+	} else {
+		xhdmiphy_ch2ids(inst, XHDMIPHY_CHID_CHA, &id0, &id1);
+		for (id = id0; id <= id1; id++) {
+			inst->quad.plls[XHDMIPHY_CH2IDX(id)].rx_state =
+						XHDMIPHY_GT_STATE_GPO_RE;
+		}
+
+		/* compare the current and next CFG values */
+		val_cmp = xhdmiphy_check_linerate_cfg(inst, XHDMIPHY_CHID_CH1,
+						      XHDMIPHY_DIR_RX);
+		if (!val_cmp) {
+			xhdmiphy_set_gpi(inst, XHDMIPHY_CHID_CHA,
+					 XHDMIPHY_DIR_RX, true);
+		} else {
+			xhdmiphy_rxgpo_risingedge_handler(inst);
+		}
+	}
+}
+
+void xhdmiphy_hdmi20_conf(struct xhdmiphy_dev *inst, enum dir dir)
+{
+	enum pll_type pll_type;
+
+	pll_type = xhdmiphy_get_pll_type(inst, dir, XHDMIPHY_CHID_CH1);
+
+	if (dir == XHDMIPHY_DIR_TX) {
+		inst->tx_hdmi21_cfg.linerate = 0;
+		inst->tx_hdmi21_cfg.nchannels = 0;
+		inst->tx_hdmi21_cfg.is_en = false;
+	} else {
+		inst->rx_hdmi21_cfg.linerate = 0;
+		inst->rx_hdmi21_cfg.nchannels = 0;
+		inst->rx_hdmi21_cfg.is_en = false;
+	}
+
+	xhdmiphy_mmcm_clkin_sel(inst, dir, XHDMIPHY_MMCM_CLKINSEL_CLKIN1);
+
+	if (dir == XHDMIPHY_DIR_TX)
+		xhdmiphy_intr_en(inst, XHDMIPHY_INTR_TXFREQCHANGE_MASK);
+	else
+		xhdmiphy_intr_en(inst, XHDMIPHY_INTR_RXFREQCHANGE_MASK);
+
+	if (inst->conf.gt_type != XHDMIPHY_GTYE5) {
+		xhdmiphy_pll_refclk_sel(inst, ((pll_type == XHDMIPHY_PLL_CPLL) ?
+					XHDMIPHY_CHID_CHA : XHDMIPHY_CHID_CMNA),
+					((dir == XHDMIPHY_DIR_TX) ?
+					inst->conf.tx_refclk_sel :
+					inst->conf.rx_refclk_sel));
+		xhdmiphy_write_refclksel(inst);
+	}
+}
+
+/**
+ * xhdmiphy_hdmi21_conf - This function will configure the GT for HDMI 2.1
+ * operation
+ *
+ * @inst:	inst is a pointer to the Hdmiphy core instance
+ * @dir:	chid is the channel ID to operate on
+ * @linerate:	dir is an indicator for RX or TX
+ * @nchannels:	no of channels
+ *
+ * @return:	- 0 if Tx parameters set/updated
+ *		- 1 if low resolution video not supported
+ */
+u32 xhdmiphy_hdmi21_conf(struct xhdmiphy_dev *inst, enum dir dir, u64 linerate,
+			 u8 nchannels)
+{
+	enum pll_type pll_type;
+	u32 status = 0;
+
+	if (inst->conf.gt_type == XHDMIPHY_GTHE4 ||
+	    inst->conf.gt_type == XHDMIPHY_GTYE4) {
+		char speedgrade[5] = "-2";
+		char comp_val[5] = "-1";
+		char *speed_grade_ptr = &speedgrade[0];
+		char *compval_ptr = &comp_val[0];
+
+		if (strncmp(speed_grade_ptr, compval_ptr, 2) == 0) {
+			if (linerate > XHDMIPHY_LRATE_8G) {
+				dev_err(inst->dev, "linkrate is not supported\n");
+				return 1;
+			}
+		}
+	}
+
+	pll_type = xhdmiphy_get_pll_type(inst, dir, XHDMIPHY_CHID_CH1);
+	if (dir == XHDMIPHY_DIR_TX) {
+		if (inst->conf.tx_refclk_sel != inst->conf.tx_frl_refclk_sel)
+			xhdmiphy_intr_dis(inst,
+					  XHDMIPHY_INTR_TXFREQCHANGE_MASK);
+
+		/* enable 4th channel output */
+		xhdmiphy_clkout1_obuftds_en(inst, XHDMIPHY_DIR_TX, (true));
+	} else {
+		if (inst->conf.rx_refclk_sel != inst->conf.rx_frl_refclk_sel)
+			xhdmiphy_intr_dis(inst, XHDMIPHY_INTR_RXFREQCHANGE_MASK);
+	}
+
+	if (inst->conf.gt_type != XHDMIPHY_GTYE5) {
+		xhdmiphy_pll_refclk_sel(inst, ((pll_type == XHDMIPHY_PLL_CPLL) ?
+					XHDMIPHY_CHID_CHA : XHDMIPHY_CHID_CMNA),
+					((dir == XHDMIPHY_DIR_TX) ?
+					inst->conf.tx_frl_refclk_sel :
+					inst->conf.rx_frl_refclk_sel));
+
+		xhdmiphy_write_refclksel(inst);
+	}
+
+	/* update HDMI confurations */
+	if (dir == XHDMIPHY_DIR_TX) {
+		inst->tx_refclk_hz = XHDMIPHY_HDMI21_FRL_REFCLK;
+		inst->tx_hdmi21_cfg.linerate = linerate;
+		inst->tx_hdmi21_cfg.nchannels = nchannels;
+		inst->tx_hdmi21_cfg.is_en = true;
+
+		status = xhdmiphy_set_tx_param(inst,
+					       ((pll_type == XHDMIPHY_PLL_CPLL) ?
+					       XHDMIPHY_CHID_CHA :
+					       XHDMIPHY_CHID_CMNA),
+					       inst->conf.ppc, XVIDC_BPC_8,
+					       XVIDC_CSF_RGB);
+
+		xhdmiphy_mmcm_lock_en(inst, dir, true);
+
+		if (inst->conf.tx_refclk_sel == inst->conf.tx_frl_refclk_sel)
+			xhdmiphy_mmcm_clkin_sel(inst, dir,
+						XHDMIPHY_MMCM_CLKINSEL_CLKIN1);
+		else
+			xhdmiphy_mmcm_clkin_sel(inst, dir,
+						XHDMIPHY_MMCM_CLKINSEL_CLKIN2);
+
+		if (inst->conf.tx_refclk_sel != inst->conf.tx_frl_refclk_sel)
+			xhdmiphy_tx_timertimeout_handler(inst);
+	} else {
+		inst->rx_refclk_hz = XHDMIPHY_HDMI21_FRL_REFCLK;
+		inst->rx_hdmi21_cfg.linerate = linerate;
+		inst->rx_hdmi21_cfg.nchannels = nchannels;
+		inst->rx_hdmi21_cfg.is_en = true;
+
+		/* set mmcm dividers for frl mode */
+		xhdmiphy_mmcm_param(inst, XHDMIPHY_DIR_RX);
+
+		/* mask the mmcm lock */
+		xhdmiphy_mmcm_lock_en(inst, dir, true);
+
+		if (inst->conf.rx_refclk_sel != inst->conf.rx_frl_refclk_sel) {
+			/* set mmcm clkinsel to clk2 */
+			xhdmiphy_mmcm_clkin_sel(inst, dir,
+						XHDMIPHY_MMCM_CLKINSEL_CLKIN2);
+
+			xhdmiphy_mmcm_start(inst, XHDMIPHY_DIR_RX);
+
+			xhdmiphy_rx_timertimeout_handler(inst);
+		}
+	}
+
+	return status;
+}
+
+/**
+ * xhdmiphy_is_pll_locked - This function will check the status of a PLL lock
+ * on the specified channel.
+ *
+ * @inst:	inst is a pointer to the xhdmiphy core instance
+ * @chid:	chid is the channel ID which to operate on
+ *
+ * @return:	- true if the specified PLL is locked
+ *		- false otherwise
+ */
+static bool xhdmiphy_is_pll_locked(struct xhdmiphy_dev *inst, enum chid chid)
+{
+	u32 reg_val, mask_val;
+	enum pll_type tx_pll, rx_pll;
+
+	if (chid == XHDMIPHY_CHID_CMN0) {
+		if (inst->conf.gt_type != XHDMIPHY_GTYE5)
+			mask_val = XHDMIPHY_PLL_LOCK_STATUS_QPLL0_MASK;
+		else
+			mask_val = XHDMIPHY_PLL_LOCK_STATUS_LCPLL_MASK;
+	} else if ((chid == XHDMIPHY_CHID_CMN1) &&
+		   (inst->conf.gt_type != XHDMIPHY_GTYE5)) {
+		mask_val = XHDMIPHY_PLL_LOCK_STATUS_QPLL1_MASK;
+	} else if (chid == XHDMIPHY_CHID_CMN1) {
+		mask_val = XHDMIPHY_PLL_LOCK_STATUS_RPLL_MASK;
+	} else {
+		/* This will result to 1 */
+		mask_val = XHDMIPHY_PLL_LOCK_STATUS_CPLL_ALL_MASK;
+	}
+
+	if (inst->conf.gt_type != XHDMIPHY_GTYE5) {
+		if (chid == XHDMIPHY_CHID_CMNA) {
+			mask_val = XHDMIPHY_PLL_LOCK_STATUS_QPLL0_MASK |
+				   XHDMIPHY_PLL_LOCK_STATUS_QPLL1_MASK;
+		} else if (chid == XHDMIPHY_CHID_CHA) {
+			tx_pll = xhdmiphy_get_pll_type(inst, XHDMIPHY_DIR_TX,
+						       XHDMIPHY_CHID_CH1);
+			rx_pll = xhdmiphy_get_pll_type(inst, XHDMIPHY_DIR_RX,
+						       XHDMIPHY_CHID_CH1);
+			if (rx_pll == XHDMIPHY_PLL_CPLL &&
+			    xhdmiphy_is_hdmi(inst, XHDMIPHY_DIR_RX)) {
+				mask_val = XHDMIPHY_PLL_LOCK_STATUS_CPLL_HDMI_MASK;
+			} else if (tx_pll == XHDMIPHY_PLL_CPLL &&
+				   xhdmiphy_is_hdmi(inst, XHDMIPHY_DIR_TX)) {
+				mask_val = XHDMIPHY_PLL_LOCK_STATUS_CPLL_HDMI_MASK;
+			} else {
+				mask_val = XHDMIPHY_PLL_LOCK_STATUS_CPLL_ALL_MASK;
+			}
+		} else {
+			mask_val = XHDMIPHY_PLL_LOCK_STATUS_CPLL_MASK(chid);
+		}
+	}
+
+	reg_val = xhdmiphy_read(inst, XHDMIPHY_PLL_LOCK_STATUS_REG);
+
+	if ((reg_val & mask_val) == mask_val)
+		return false;
+
+	return true;
+}
+
+static void xhdmiphy_lcpll_lock_handler(struct xhdmiphy_dev *inst)
+{
+	enum pll_type tx_pll_type;
+	enum chid chid;
+	u8 id, id0, id1;
+
+	tx_pll_type = xhdmiphy_get_pll_type(inst, XHDMIPHY_DIR_TX,
+					    XHDMIPHY_CHID_CH1);
+
+	/* Determine which channel(s) to operate on */
+	chid = xhdmiphy_get_rcfg_chid(XHDMIPHY_PLL_LCPLL);
+	if (xhdmiphy_is_pll_locked(inst, chid) == 0) {
+		dev_info(inst->dev, "lcpll is locked\n");
+		xhdmiphy_ch2ids(inst, XHDMIPHY_CHID_CHA, &id0, &id1);
+		for (id = id0; id <= id1; id++) {
+			if (tx_pll_type == XHDMIPHY_PLL_LCPLL)
+				inst->quad.plls[XHDMIPHY_CH2IDX(id)].tx_state =
+							XHDMIPHY_GT_STATE_RESET;
+			else
+				inst->quad.plls[XHDMIPHY_CH2IDX(id)].rx_state =
+							XHDMIPHY_GT_STATE_RESET;
+		}
+	} else {
+		dev_info(inst->dev, "lcpll lock lost !\n");
+	}
+}
+
+static void xhdmiphy_rpll_lock_handler(struct xhdmiphy_dev *inst)
+{
+	enum chid chid;
+	enum pll_type tx_pll_type;
+	u8 id, id0, id1;
+
+	tx_pll_type = xhdmiphy_get_pll_type(inst, XHDMIPHY_DIR_TX,
+					    XHDMIPHY_CHID_CH1);
+	/* determine which channel(s) to operate on */
+	chid = xhdmiphy_get_rcfg_chid(XHDMIPHY_PLL_RPLL);
+	if (xhdmiphy_is_pll_locked(inst, chid) == 0) {
+		dev_info(inst->dev, "rpll is locked\n");
+		xhdmiphy_ch2ids(inst, XHDMIPHY_CHID_CHA, &id0, &id1);
+		for (id = id0; id <= id1; id++) {
+			if (tx_pll_type == XHDMIPHY_PLL_RPLL) {
+				inst->quad.plls[XHDMIPHY_CH2IDX(id)].tx_state =
+							XHDMIPHY_GT_STATE_RESET;
+			} else {
+				inst->quad.plls[XHDMIPHY_CH2IDX(id)].rx_state =
+							XHDMIPHY_GT_STATE_RESET;
+			}
+		}
+	} else {
+		dev_info(inst->dev, "rpll lock lost !\n");
+	}
+}
+
+/**
+ * xhdmiphy_rst_gt_txrx - This function will reset the GT's TX/RX logic.
+ *
+ * @inst:	inst is a pointer to the xhdmiphy core instance
+ * @chid:	chid is the channel ID which to operate on
+ * @dir:	dir is an indicator for TX or RX
+ * @hold:	hold is an indicator whether to "hold" the reset if set to 1
+ *		If set to 0: reset, then enable
+ */
+void xhdmiphy_rst_gt_txrx(struct xhdmiphy_dev *inst, enum chid chid,
+			  enum dir dir, u8 hold)
+{
+	u32 reg_val, mask_val, reg_off;
+
+	if (dir == XHDMIPHY_DIR_TX)
+		reg_off = XHDMIPHY_TX_INIT_REG;
+	else
+		reg_off = XHDMIPHY_RX_INIT_REG;
+
+	if (chid == XHDMIPHY_CHID_CHA)
+		mask_val = XHDMIPHY_TXRX_INIT_GTRESET_ALL_MASK;
+	else
+		mask_val = XHDMIPHY_TXRX_INIT_GTRESET_MASK(chid);
+
+	reg_val = xhdmiphy_read(inst, reg_off);
+	reg_val |= mask_val;
+	xhdmiphy_write(inst, reg_off, reg_val);
+
+	if (!hold) {
+		reg_val &= ~mask_val;
+		xhdmiphy_write(inst, reg_off, reg_val);
+	}
+}
+
+static void xhdmiphy_qpll_lock_handler(struct xhdmiphy_dev *inst)
+{
+	enum chid chid;
+	enum pll_type tx_pll_type, rx_pll_type;
+	u8 id, id0, id1;
+
+	tx_pll_type = xhdmiphy_get_pll_type(inst, XHDMIPHY_DIR_TX,
+					    XHDMIPHY_CHID_CH1);
+	rx_pll_type = xhdmiphy_get_pll_type(inst, XHDMIPHY_DIR_RX,
+					    XHDMIPHY_CHID_CH1);
+
+	/* rX is using QPLL */
+	if (rx_pll_type == XHDMIPHY_PLL_QPLL ||
+	    rx_pll_type == XHDMIPHY_PLL_QPLL0 ||
+	    rx_pll_type == XHDMIPHY_PLL_QPLL1) {
+		chid = xhdmiphy_get_rcfg_chid(rx_pll_type);
+
+		if (xhdmiphy_is_pll_locked(inst, chid) == 0) {
+			dev_info(inst->dev, "qpll is locked\n");
+			xhdmiphy_rst_gt_txrx(inst, XHDMIPHY_CHID_CHA,
+					     XHDMIPHY_DIR_RX, false);
+			xhdmiphy_ch2ids(inst, XHDMIPHY_CHID_CHA, &id0, &id1);
+			for (id = id0; id <= id1; id++)
+				inst->quad.plls[XHDMIPHY_CH2IDX(id)].rx_state =
+							XHDMIPHY_GT_STATE_RESET;
+
+		} else {
+			dev_info(inst->dev, "qpll lock lost!\n");
+		}
+	} else {
+		/* tX is using QPLL */
+		chid = xhdmiphy_get_rcfg_chid(tx_pll_type);
+		if (xhdmiphy_is_pll_locked(inst, chid) == 0) {
+			dev_info(inst->dev, "qpll locked\n");
+			xhdmiphy_rst_gt_txrx(inst, XHDMIPHY_CHID_CHA,
+					     XHDMIPHY_DIR_TX, false);
+			xhdmiphy_ch2ids(inst, XHDMIPHY_CHID_CHA, &id0,
+					&id1);
+			for (id = id0; id <= id1; id++) {
+				inst->quad.plls[XHDMIPHY_CH2IDX(id)].tx_state =
+							XHDMIPHY_GT_STATE_RESET;
+			}
+		} else {
+			dev_info(inst->dev, "qpll lock lost !\n");
+		}
+	}
+}
+
+static void xhdmiphy_cpll_lock_handler(struct xhdmiphy_dev *inst)
+{
+	enum pll_type tx_pll_type;
+	enum pll_type rx_pll_type;
+	enum chid chid;
+	u8 id, id0, id1;
+
+	tx_pll_type = xhdmiphy_get_pll_type(inst, XHDMIPHY_DIR_TX,
+					    XHDMIPHY_CHID_CH1);
+	rx_pll_type = xhdmiphy_get_pll_type(inst, XHDMIPHY_DIR_RX,
+					    XHDMIPHY_CHID_CH1);
+	xhdmiphy_ch2ids(inst, XHDMIPHY_CHID_CHA, &id0, &id1);
+
+	if (rx_pll_type == XHDMIPHY_PLL_CPLL) {
+		chid = xhdmiphy_get_rcfg_chid(rx_pll_type);
+		if (xhdmiphy_is_pll_locked(inst, chid) == 0) {
+			dev_info(inst->dev, "cpll locked\n");
+			xhdmiphy_rst_gt_txrx(inst, XHDMIPHY_CHID_CHA,
+					     XHDMIPHY_DIR_RX, false);
+			for (id = id0; id <= id1; id++) {
+				inst->quad.plls[XHDMIPHY_CH2IDX(id)].rx_state =
+							XHDMIPHY_GT_STATE_RESET;
+			}
+		} else {
+			dev_info(inst->dev, "cpll lock lost\n");
+		}
+	} else {
+		/*
+		 * TX is using CPLL. Determine which channel(s)
+		 * to operate on
+		 */
+		chid = xhdmiphy_get_rcfg_chid(tx_pll_type);
+		if (xhdmiphy_is_pll_locked(inst, chid) == 0) {
+			dev_info(inst->dev, "cpll locked\n");
+			xhdmiphy_rst_gt_txrx(inst, XHDMIPHY_CHID_CHA,
+					     XHDMIPHY_DIR_TX, false);
+			for (id = id0; id <= id1; id++) {
+				inst->quad.plls[XHDMIPHY_CH2IDX(id)].tx_state =
+							XHDMIPHY_GT_STATE_RESET;
+			}
+		} else {
+			dev_info(inst->dev, "cpll lock lost\n");
+		}
+	}
+}
+
+static void xhdmiphy_txgt_aligndone_handler(struct xhdmiphy_dev *inst)
+{
+	u8 id, id0, id1;
+
+	xhdmiphy_ch2ids(inst, XHDMIPHY_CHID_CHA, &id0, &id1);
+	for (id = id0; id <= id1; id++)
+		inst->quad.plls[XHDMIPHY_CH2IDX(id)].tx_state =
+						XHDMIPHY_GT_STATE_READY;
+}
+
+static void xhdmiphy_txgt_rstdone_handler(struct xhdmiphy_dev *inst)
+{
+	enum pll_type pll_type;
+	enum chid chid;
+	u8 id, id0, id1;
+
+	pll_type = xhdmiphy_get_pll_type(inst, XHDMIPHY_DIR_TX,
+					 XHDMIPHY_CHID_CH1);
+	chid = xhdmiphy_get_rcfg_chid(pll_type);
+
+	/* Set TX TMDS Clock Pattern Generator */
+	if (inst->conf.gt_as_tx_tmdsclk &&
+	    (inst->tx_hdmi21_cfg.is_en == 0 ||
+	    (inst->tx_hdmi21_cfg.is_en == 1 &&
+	    inst->tx_hdmi21_cfg.nchannels == 3))) {
+		xhdmiphy_patgen_set_ratio(inst,
+					  (u64)((xhdmiphy_get_linerate(inst,
+					  chid)) / 1000000));
+		xhdmiphy_set(inst, XHDMIPHY_PATGEN_CTRL_REG,
+			     XHDMIPHY_PATGEN_CTRL_ENABLE_MASK);
+	} else {
+		xhdmiphy_clr(inst, XHDMIPHY_PATGEN_CTRL_REG,
+			     XHDMIPHY_PATGEN_CTRL_ENABLE_MASK);
+	}
+
+	if (inst->conf.gt_type != XHDMIPHY_GTYE5) {
+		if (inst->conf.gt_type == XHDMIPHY_GTTYPE_GTHE4 ||
+		    inst->conf.gt_type == XHDMIPHY_GTTYPE_GTYE4) {
+			xhdmiphy_tx_align_rst(inst, XHDMIPHY_CHID_CHA, true);
+			xhdmiphy_tx_align_rst(inst, XHDMIPHY_CHID_CHA, false);
+		}
+		/* GT alignment */
+		xhdmiphy_tx_align_start(inst, XHDMIPHY_CHID_CHA, true);
+		xhdmiphy_tx_align_start(inst, XHDMIPHY_CHID_CHA, false);
+		xhdmiphy_ch2ids(inst, XHDMIPHY_CHID_CHA, &id0, &id1);
+		for (id = id0; id <= id1; id++)
+			inst->quad.plls[XHDMIPHY_CH2IDX(id)].tx_state =
+						XHDMIPHY_GT_STATE_ALIGN;
+	} else {
+		/* Deassert TX LNKRDY MASK */
+		xhdmiphy_write(inst, XHDMIPHY_TX_INIT_REG,
+			       (xhdmiphy_read(inst, XHDMIPHY_TX_INIT_REG) &
+			       ~XHDMIPHY_TXPCS_RESET_MASK));
+
+		xhdmiphy_ch2ids(inst, XHDMIPHY_CHID_CHA, &id0, &id1);
+
+		for (id = id0; id <= id1; id++)
+			inst->quad.plls[XHDMIPHY_CH2IDX(id)].tx_state =
+							XHDMIPHY_GT_STATE_READY;
+	}
+}
+
+static void xhdmiphy_rxgt_rstdone_handler(struct xhdmiphy_dev *inst)
+{
+	u8 id, id0, id1;
+
+	xhdmiphy_ch2ids(inst, XHDMIPHY_CHID_CHA, &id0, &id1);
+	for (id = id0; id <= id1; id++)
+		inst->quad.plls[XHDMIPHY_CH2IDX(id)].rx_state =
+						XHDMIPHY_GT_STATE_READY;
+
+	xhdmiphy_write(inst, XHDMIPHY_RX_INIT_REG,
+		       (xhdmiphy_read(inst, XHDMIPHY_RX_INIT_REG) &
+		       ~XHDMIPHY_RXPCS_RESET_MASK));
+	if (inst->rx_dru_enabled)
+		xhdmiphy_dru_reset(inst, XHDMIPHY_CHID_CHA, false);
+
+	if (inst->phycb[RX_READY_CB].cb)
+		inst->phycb[RX_READY_CB].cb(inst->phycb[RX_READY_CB].data);
+}
+
+static void xhdmiphy_tx_freqchnage_handler(struct xhdmiphy_dev *inst)
+{
+	enum pll_type pll_type;
+	u8 id, id0, id1;
+
+	if (inst->tx_hdmi21_cfg.is_en) {
+		if (inst->conf.tx_refclk_sel != inst->conf.tx_frl_refclk_sel)
+			return;
+	}
+
+	/* set tX TMDS clock pattern generator */
+	if (inst->conf.gt_as_tx_tmdsclk &&
+	    (inst->tx_hdmi21_cfg.is_en == 0 ||
+	    (inst->tx_hdmi21_cfg.is_en == 1 &&
+	    inst->tx_hdmi21_cfg.nchannels == 3)))
+		xhdmiphy_clr(inst, XHDMIPHY_PATGEN_CTRL_REG,
+			     XHDMIPHY_PATGEN_CTRL_ENABLE_MASK);
+
+	pll_type = xhdmiphy_get_pll_type(inst, XHDMIPHY_DIR_TX,
+					 XHDMIPHY_CHID_CH1);
+
+	/* If the TX frequency has changed, the PLL is always disabled */
+	if (inst->conf.gt_type != XHDMIPHY_GTYE5) {
+		xhdmiphy_powerdown_gtpll(inst, (pll_type == XHDMIPHY_PLL_CPLL) ?
+					 XHDMIPHY_CHID_CHA :
+					 XHDMIPHY_CHID_CMNA, true);
+		xhdmiphy_reset_gtpll(inst, XHDMIPHY_CHID_CHA,
+				     XHDMIPHY_DIR_TX, true);
+	} else {
+		/* Mask RESET DONE */
+		/* Deassert TX LNKRDY MASK */
+		xhdmiphy_write(inst, XHDMIPHY_TX_INIT_REG,
+			       (xhdmiphy_read(inst,
+			       XHDMIPHY_TX_INIT_REG) |
+			       XHDMIPHY_TXPCS_RESET_MASK));
+	}
+
+	xhdmiphy_mmcm_lock_en(inst, XHDMIPHY_DIR_TX, true);
+	xhdmiphy_set(inst, XHDMIPHY_CLKDET_CTRL_REG,
+		     XHDMIPHY_CLKDET_CTRL_TX_TMR_CLR_MASK);
+
+	if (inst->conf.gt_type != XHDMIPHY_GTYE5)
+		xhdmiphy_tx_align_start(inst, XHDMIPHY_CHID_CHA, false);
+
+	xhdmiphy_ch2ids(inst, XHDMIPHY_CHID_CHA, &id0, &id1);
+	for (id = id0; id <= id1; id++)
+		inst->quad.plls[XHDMIPHY_CH2IDX(id)].tx_state =
+							XHDMIPHY_GT_STATE_IDLE;
+
+	/* If there is no reference clock, load TX timer in usec */
+	if (xhdmiphy_read(inst, XHDMIPHY_CLKDET_FREQ_TX_REG))
+		xhdmiphy_write(inst, XHDMIPHY_CLKDET_TMR_TX_REG,
+			       inst->conf.axilite_freq / 1000);
+}
+
+static void xhdmiphy_rx_freqchange_handler(struct xhdmiphy_dev *inst)
+{
+	enum pll_type pll_type;
+	u32 rx_refclk;
+	u8 id, id0, id1;
+
+	if (inst->rx_hdmi21_cfg.is_en)
+		if (inst->conf.rx_refclk_sel != inst->conf.rx_frl_refclk_sel)
+			return;
+
+	xhdmiphy_ch2ids(inst, XHDMIPHY_CHID_CHA, &id0, &id1);
+	for (id = id0; id <= id1; id++)
+		inst->quad.plls[XHDMIPHY_CH2IDX(id)].rx_state =
+							XHDMIPHY_GT_STATE_IDLE;
+	if (!inst->rx_hdmi21_cfg.is_en)
+		/* mask the MMCM Lock */
+		xhdmiphy_mmcm_lock_en(inst, XHDMIPHY_DIR_RX, true);
+
+	/* determine PLL type and RX reference clock selection */
+	pll_type = xhdmiphy_get_pll_type(inst, XHDMIPHY_DIR_RX,
+					 XHDMIPHY_CHID_CH1);
+
+	/* fetch New RX Reference Clock Frequency */
+	rx_refclk = xhdmiphy_read(inst, XHDMIPHY_CLKDET_FREQ_RX_REG);
+
+	/* round input frequency to 10 kHz */
+	rx_refclk = (rx_refclk + 5000) / 10000;
+	rx_refclk = rx_refclk * 10000;
+
+	/* store RX reference clock */
+	if (inst->rx_hdmi21_cfg.is_en)
+		inst->rx_refclk_hz = XHDMIPHY_HDMI21_FRL_REFCLK;
+	else
+		inst->rx_refclk_hz = rx_refclk;
+
+	/* If the RX frequency has changed, the PLL is always disabled */
+	if (inst->conf.gt_type != XHDMIPHY_GTYE5) {
+		xhdmiphy_powerdown_gtpll(inst, (pll_type == XHDMIPHY_PLL_CPLL) ?
+					 XHDMIPHY_CHID_CHA :
+					 XHDMIPHY_CHID_CMNA, true);
+		xhdmiphy_reset_gtpll(inst, XHDMIPHY_CHID_CHA,
+				     XHDMIPHY_DIR_RX, true);
+	} else {
+		xhdmiphy_write(inst, XHDMIPHY_RX_INIT_REG,
+			       (xhdmiphy_read(inst, XHDMIPHY_RX_INIT_REG) |
+					      XHDMIPHY_RXPCS_RESET_MASK));
+	}
+
+	/* if DRU is present, disable it and assert reset */
+	if (inst->conf.dru_present) {
+		xhdmiphy_dru_reset(inst, XHDMIPHY_CHID_CHA, true);
+		xhdmiphy_dru_en(inst, XHDMIPHY_CHID_CHA, false);
+	}
+	/* clear RX timer */
+	xhdmiphy_set(inst, XHDMIPHY_CLKDET_CTRL_REG,
+		     XHDMIPHY_CLKDET_CTRL_RX_TMR_CLR_MASK);
+	/*
+	 * If there is reference clock, load RX timer in usec.
+	 * The reference clock should be larger than 25Mhz. We are using a
+	 * 20Mhz instead to keep some margin for errors.
+	 */
+
+	if (rx_refclk > 20000000) {
+		xhdmiphy_write(inst, XHDMIPHY_CLKDET_TMR_RX_REG,
+			       inst->conf.axilite_freq / 1000);
+		if (inst->phycb[RX_INIT_CB].cb)
+			inst->phycb[RX_INIT_CB].cb(inst->phycb[RX_INIT_CB].data);
+	}
+}
+
+void xhdmiphy_gt_handler(struct xhdmiphy_dev *inst, u32 event_ack, u32 event)
+{
+	enum gt_state *tx_state;
+	enum gt_state *rx_state;
+	enum pll_type tx_pll_type;
+	enum pll_type rx_pll_type;
+
+	/* read states for Ch1 */
+	tx_state = &inst->quad.ch1.tx_state;
+	rx_state = &inst->quad.ch1.rx_state;
+
+	/* determine PLL type */
+	tx_pll_type = xhdmiphy_get_pll_type(inst, XHDMIPHY_DIR_TX,
+					    XHDMIPHY_CHID_CH1);
+	rx_pll_type = xhdmiphy_get_pll_type(inst, XHDMIPHY_DIR_RX,
+					    XHDMIPHY_CHID_CH1);
+	if (inst->conf.gt_type != XHDMIPHY_GTYE5) {
+		if ((event & XHDMIPHY_INTR_QPLL0_LOCK_MASK) ||
+		    (event & XHDMIPHY_INTR_QPLL1_LOCK_MASK))
+			xhdmiphy_qpll_lock_handler(inst);
+
+		if (event & XHDMIPHY_INTR_CPLL_LOCK_MASK)
+			xhdmiphy_cpll_lock_handler(inst);
+
+		if ((event & XHDMIPHY_INTR_TXRESETDONE_MASK) &&
+		    (*tx_state == XHDMIPHY_GT_STATE_RESET))
+			xhdmiphy_txgt_rstdone_handler(inst);
+
+		if ((event & XHDMIPHY_INTR_TXALIGNDONE_MASK) &&
+		    (*tx_state == XHDMIPHY_GT_STATE_ALIGN))
+			xhdmiphy_txgt_aligndone_handler(inst);
+
+		if ((event & XHDMIPHY_INTR_RXRESETDONE_MASK) &&
+		    (*rx_state == XHDMIPHY_GT_STATE_RESET))
+			xhdmiphy_rxgt_rstdone_handler(inst);
+	} else {
+		if (event & XHDMIPHY_INTR_TXGPO_RE_MASK)
+			xhdmiphy_txgpo_risingedge_handler(inst);
+
+		if (event & XHDMIPHY_INTR_RXGPO_RE_MASK)
+			xhdmiphy_rxgpo_risingedge_handler(inst);
+
+		if ((event & XHDMIPHY_INTR_LCPLL_LOCK_MASK) &&
+		    (((*tx_state != XHDMIPHY_GT_STATE_IDLE) &&
+		    tx_pll_type == XHDMIPHY_PLL_LCPLL) ||
+		    ((*rx_state != XHDMIPHY_GT_STATE_IDLE) &&
+		    rx_pll_type == XHDMIPHY_PLL_LCPLL))) {
+			xhdmiphy_lcpll_lock_handler(inst);
+		}
+
+		if ((event & XHDMIPHY_INTR_RPLL_LOCK_MASK) &&
+		    (((*tx_state != XHDMIPHY_GT_STATE_IDLE) &&
+		    tx_pll_type == XHDMIPHY_PLL_RPLL) ||
+		    ((*rx_state != XHDMIPHY_GT_STATE_IDLE) &&
+		    rx_pll_type == XHDMIPHY_PLL_RPLL)))
+			xhdmiphy_rpll_lock_handler(inst);
+
+		if ((event & XHDMIPHY_INTR_TXRESETDONE_MASK) &&
+		    (*tx_state == XHDMIPHY_GT_STATE_RESET))
+			xhdmiphy_txgt_rstdone_handler(inst);
+
+		if ((event & XHDMIPHY_INTR_RXRESETDONE_MASK) &&
+		    (*rx_state == XHDMIPHY_GT_STATE_RESET))
+			xhdmiphy_rxgt_rstdone_handler(inst);
+	}
+
+	xhdmiphy_write(inst, XHDMIPHY_INTR_STS_REG, event_ack);
+}
+
+void xhdmiphy_clkdet_handler(struct xhdmiphy_dev *inst, u32 event_ack,
+			     u32 event)
+{
+	if (event & XHDMIPHY_INTR_TXFREQCHANGE_MASK)
+		xhdmiphy_tx_freqchnage_handler(inst);
+
+	if (event & XHDMIPHY_INTR_RXFREQCHANGE_MASK)
+		xhdmiphy_rx_freqchange_handler(inst);
+
+	if (event & XHDMIPHY_INTR_TXTMRTIMEOUT_MASK)
+		xhdmiphy_tx_timertimeout_handler(inst);
+
+	if (event & XHDMIPHY_INTR_RXTMRTIMEOUT_MASK)
+		xhdmiphy_rx_timertimeout_handler(inst);
+
+	xhdmiphy_write(inst, XHDMIPHY_INTR_STS_REG, event_ack);
+}
diff --git a/include/linux/phy/phy-hdmi.h b/include/linux/phy/phy-hdmi.h
new file mode 100644
index 000000000..d37532939
--- /dev/null
+++ b/include/linux/phy/phy-hdmi.h
@@ -0,0 +1,211 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+
+#ifndef __PHY_HDMI_H_
+#define __PHY_HDMI_H_
+
+#include <linux/types.h>
+
+/**
+ * enum callback_type - HDMI PHY callback functions type
+ * This enumerates the list of available HDMI PHY callback functions types.
+ *
+ * @RX_INIT_CB:		Receiver initialization callback type
+ * @RX_READY_CB:	Receiver ready callback type
+ * @TX_INIT_CB:		Transmitter initialization callback type
+ * @TX_READY_CB:	Transmitter ready callback type
+ */
+enum callback_type {
+	RX_INIT_CB,
+	RX_READY_CB,
+	TX_INIT_CB,
+	TX_READY_CB,
+};
+
+/**
+ * struct hdmiphy_callback - HDMI PHY callback structure
+ * This structure is used to represent the callback function of a
+ * HDMI phy.
+ *
+ * @cb:		Callback function pointer
+ * @data:	Pointer to store data
+ * @type:	Callback type
+ */
+struct hdmiphy_callback {
+	void (*cb)(void *callback_func);
+	void *data;
+	u32 type;
+};
+
+/**
+ * struct phy_configure_opts_hdmi - HDMI PHY configuration set
+ *
+ * This structure is used to represent the configuration state of a
+ * HDMI phy.
+ */
+struct phy_configure_opts_hdmi {
+	/**
+	 * @tmdsclock_ratio_flag:
+	 *
+	 * SCDC tmds clock ratio flag.
+	 *
+	 * Allowed values: 0, 1
+	 */
+	u8 tmdsclock_ratio_flag : 1;
+	/**
+	 * @tmdsclock_ratio:
+	 *
+	 * SCDC tmds clock ratio bit.
+	 *
+	 * Allowed values: 0, 1
+	 */
+	u8 tmdsclock_ratio : 1;
+
+	/**
+	 * @ibufds:
+	 *
+	 * Flag to enable/disable the TX or RX IBUFDS configuration.
+	 *
+	 * Allowed values: 0, 1
+	 */
+	u8 ibufds : 1;
+	/**
+	 * @ibufds_en:
+	 *
+	 * enables/disable the TX or RX IBUFDS peripheral.
+	 *
+	 * Allowed values: 0, 1
+	 */
+	u8 ibufds_en : 1;
+	/**
+	 * @clkout1_obuftds:
+	 *
+	 * Flag to enable/disable the TX or RX CLKOUT1 OBUFTDS configuration.
+	 *
+	 * Allowed values: 0, 1
+	 */
+	u8 clkout1_obuftds : 1;
+	/**
+	 * @clkout1_obuftds_en:
+	 *
+	 * enable/disable the TX or RX CLKOUT1 OBUFTDS peripheral.
+	 *
+	 * Allowed values: 0, 1
+	 */
+	u8 clkout1_obuftds_en : 1;
+	/**
+	 * @config_hdmi20:
+	 *
+	 * Flag to enable/disable HDMI-PHY to be configured in 2.0 mode
+	 *
+	 * Allowed values: 0, 1
+	 */
+	u8 config_hdmi20 : 1;
+	/**
+	 * @config_hdmi21:
+	 *
+	 * Flag to enable/disable HDMI-PHY to be configured in 2.1 mode
+	 *
+	 * Allowed values: 0, 1
+	 */
+	u8 config_hdmi21 : 1;
+	/**
+	 * @linerate:
+	 *
+	 * Supported linerates(in Gb/s) to be configured in FRL mode.
+	 *
+	 * Allowed values: 3, 6, 8. 10, 12
+	 */
+	u64 linerate;
+	/**
+	 * @nchannels:
+	 *
+	 * No of channels to confiure in FRL mode.
+	 *
+	 * Allowed values: 3, 4
+	 */
+	u8 nchannels;
+	/**
+	 * @rx_get_refclk:
+	 *
+	 * Flag to get the rx reference clock value from the PHY driver
+	 *
+	 * Allowed values: 0, 1
+	 */
+	u8 rx_get_refclk : 1;
+	/**
+	 * @rx_refclk_hz:
+	 *
+	 * Rx reference clock value.
+	 *
+	 */
+	unsigned long rx_refclk_hz;
+	/**
+	 * @phycb:
+	 *
+	 * phy callback functions flag.
+	 *
+	 * Allowed values: 0, 1
+	 */
+	u8 phycb : 1;
+	/**
+	 * @hdmiphycb:
+	 *
+	 * HDMI PHY callback structure
+	 */
+	struct hdmiphy_callback hdmiphycb;
+	/**
+	 * @tx_params:
+	 *
+	 * Flag to update the tx stream paramerters.
+	 *
+	 * Allowed values: 0, 1
+	 */
+	u8 tx_params : 1;
+	/**
+	 * @cal_mmcm_param:
+	 *
+	 * Flage to update caliculate mmcm parameters.
+	 *
+	 * Allowed values: 0, 1
+	 */
+	u8 cal_mmcm_param : 1;
+	/**
+	 * @tx_tmdsclk:
+	 *
+	 * TX TMDS clock value.
+	 *
+	 */
+	u64 tx_tmdsclk;
+	/**
+	 * @ppc:
+	 *
+	 * pixels per clock.
+	 *
+	 * Allowed values: 1, 2, 4, 8
+	 */
+	u8 ppc;
+	/**
+	 * @bpc:
+	 *
+	 * bits per component.
+	 *
+	 * Allowed  values: 8, 10, 23, 16
+	 */
+	u8 bpc;
+	/**
+	 * @fmt:
+	 *
+	 * color format.
+	 *
+	 * Allowed values: 0, 1, 2, 3
+	 */
+	u8 fmt;
+	/**
+	 * @reset_gt:
+	 *
+	 * Flag to reset the GT
+	 */
+	u8 reset_gt : 1;
+};
+
+#endif /* __PHY_HDMI_H_ */
diff --git a/include/linux/phy/phy.h b/include/linux/phy/phy.h
index e435bdb0b..5cf5912db 100644
--- a/include/linux/phy/phy.h
+++ b/include/linux/phy/phy.h
@@ -17,6 +17,7 @@
 #include <linux/regulator/consumer.h>
 
 #include <linux/phy/phy-dp.h>
+#include <linux/phy/phy-hdmi.h>
 #include <linux/phy/phy-mipi-dphy.h>
 
 struct phy;
@@ -51,10 +52,13 @@ enum phy_mode {
  *		the MIPI_DPHY phy mode.
  * @dp:		Configuration set applicable for phys supporting
  *		the DisplayPort protocol.
+ * @hdmi:	Configuration set applicable for phys supporting
+ *		the HDMI protocol.
  */
 union phy_configure_opts {
 	struct phy_configure_opts_mipi_dphy	mipi_dphy;
 	struct phy_configure_opts_dp		dp;
+	struct phy_configure_opts_hdmi		hdmi;
 };
 
 /**
